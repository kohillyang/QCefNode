From d9ee7ce981df8a05d7644091452b83163082ef93 Mon Sep 17 00:00:00 2001
From: kohill <kohillyang@126.com>
Date: Wed, 5 Oct 2022 15:32:43 +0800
Subject: [PATCH 1/2] cef_node

---
 BUILD.gn                                      |  14 +
 .../embed/electron/pop_node_defines.h         | 275 ++++++++
 .../electron/push_and_undef_node_defines.h    | 550 ++++++++++++++++
 libcef/renderer/embed/node_bindings.cc        | 459 +++++++++++++
 libcef/renderer/embed/node_bindings.h         | 173 +++++
 libcef/renderer/embed/node_bindings_win.cc    |  53 ++
 libcef/renderer/embed/node_bindings_win.h     |  24 +
 libcef/renderer/embed/node_includes.h         |  39 ++
 libcef/renderer/embed/node_util.cc            |  41 ++
 libcef/renderer/embed/node_util.h             |  36 ++
 .../gin_converters/accelerator_converter.cc   |  23 +
 .../gin_converters/accelerator_converter.h    |  25 +
 .../common/gin_converters/base_converter.h    |  47 ++
 .../common/gin_converters/blink_converter.cc  | 603 ++++++++++++++++++
 .../common/gin_converters/blink_converter.h   | 123 ++++
 .../gin_converters/callback_converter.h       |  59 ++
 .../gin_converters/content_converter.cc       | 312 +++++++++
 .../common/gin_converters/content_converter.h |  91 +++
 .../gin_converters/extension_converter.cc     |  30 +
 .../gin_converters/extension_converter.h      |  26 +
 .../gin_converters/file_dialog_converter.cc   |  77 +++
 .../gin_converters/file_dialog_converter.h    |  33 +
 .../gin_converters/file_path_converter.h      |  44 ++
 .../common/gin_converters/frame_converter.cc  |  89 +++
 .../common/gin_converters/frame_converter.h   |  35 +
 .../common/gin_converters/gfx_converter.cc    | 189 ++++++
 .../common/gin_converters/gfx_converter.h     |  74 +++
 .../common/gin_converters/guid_converter.h    |  86 +++
 .../common/gin_converters/gurl_converter.h    |  35 +
 .../common/gin_converters/image_converter.cc  |  54 ++
 .../common/gin_converters/image_converter.h   |  34 +
 .../gin_converters/message_box_converter.cc   |  39 ++
 .../gin_converters/message_box_converter.h    |  22 +
 .../gin_converters/native_window_converter.h  |  35 +
 .../common/gin_converters/net_converter.cc    | 408 ++++++++++++
 .../common/gin_converters/net_converter.h     | 143 +++++
 .../common/gin_converters/std_converter.h     | 215 +++++++
 .../common/gin_converters/time_converter.cc   |  22 +
 .../common/gin_converters/time_converter.h    |  23 +
 .../common/gin_converters/value_converter.cc  |  77 +++
 .../common/gin_converters/value_converter.h   |  47 ++
 .../embed/shell/common/gin_helper/accessor.h  |  27 +
 .../shell/common/gin_helper/arguments.cc      |  23 +
 .../embed/shell/common/gin_helper/arguments.h |  51 ++
 .../embed/shell/common/gin_helper/callback.cc | 154 +++++
 .../embed/shell/common/gin_helper/callback.h  | 152 +++++
 .../common/gin_helper/cleaned_up_at_exit.cc   |  35 +
 .../common/gin_helper/cleaned_up_at_exit.h    |  27 +
 .../shell/common/gin_helper/constructible.h   |  69 ++
 .../shell/common/gin_helper/constructor.h     | 171 +++++
 .../shell/common/gin_helper/destroyable.cc    |  73 +++
 .../shell/common/gin_helper/destroyable.h     |  24 +
 .../shell/common/gin_helper/dictionary.h      | 217 +++++++
 .../shell/common/gin_helper/error_thrower.cc  |  44 ++
 .../shell/common/gin_helper/error_thrower.h   |  37 ++
 .../shell/common/gin_helper/event_emitter.cc  |  80 +++
 .../shell/common/gin_helper/event_emitter.h   | 104 +++
 .../common/gin_helper/event_emitter_caller.cc |  38 ++
 .../common/gin_helper/event_emitter_caller.h  |  91 +++
 .../common/gin_helper/function_template.cc    |  36 ++
 .../common/gin_helper/function_template.h     | 332 ++++++++++
 .../gin_helper/function_template_extensions.h |  60 ++
 .../embed/shell/common/gin_helper/locker.cc   |  16 +
 .../embed/shell/common/gin_helper/locker.h    |  37 ++
 .../common/gin_helper/microtasks_scope.cc     |  25 +
 .../common/gin_helper/microtasks_scope.h      |  34 +
 .../gin_helper/object_template_builder.cc     |  36 ++
 .../gin_helper/object_template_builder.h      |  77 +++
 .../gin_helper/persistent_dictionary.cc       |  32 +
 .../common/gin_helper/persistent_dictionary.h |  63 ++
 .../embed/shell/common/gin_helper/pinnable.h  |  34 +
 .../embed/shell/common/gin_helper/promise.cc  |  96 +++
 .../embed/shell/common/gin_helper/promise.h   | 184 ++++++
 .../common/gin_helper/trackable_object.cc     |  66 ++
 .../common/gin_helper/trackable_object.h      | 140 ++++
 .../shell/common/gin_helper/wrappable.cc      |  93 +++
 .../embed/shell/common/gin_helper/wrappable.h | 101 +++
 .../shell/common/gin_helper/wrappable_base.h  |  70 ++
 libcef/renderer/render_frame_observer.cc      | 101 ++-
 79 files changed, 7831 insertions(+), 3 deletions(-)
 create mode 100644 libcef/renderer/embed/electron/pop_node_defines.h
 create mode 100644 libcef/renderer/embed/electron/push_and_undef_node_defines.h
 create mode 100644 libcef/renderer/embed/node_bindings.cc
 create mode 100644 libcef/renderer/embed/node_bindings.h
 create mode 100644 libcef/renderer/embed/node_bindings_win.cc
 create mode 100644 libcef/renderer/embed/node_bindings_win.h
 create mode 100644 libcef/renderer/embed/node_includes.h
 create mode 100644 libcef/renderer/embed/node_util.cc
 create mode 100644 libcef/renderer/embed/node_util.h
 create mode 100644 libcef/renderer/embed/shell/common/gin_converters/accelerator_converter.cc
 create mode 100644 libcef/renderer/embed/shell/common/gin_converters/accelerator_converter.h
 create mode 100644 libcef/renderer/embed/shell/common/gin_converters/base_converter.h
 create mode 100644 libcef/renderer/embed/shell/common/gin_converters/blink_converter.cc
 create mode 100644 libcef/renderer/embed/shell/common/gin_converters/blink_converter.h
 create mode 100644 libcef/renderer/embed/shell/common/gin_converters/callback_converter.h
 create mode 100644 libcef/renderer/embed/shell/common/gin_converters/content_converter.cc
 create mode 100644 libcef/renderer/embed/shell/common/gin_converters/content_converter.h
 create mode 100644 libcef/renderer/embed/shell/common/gin_converters/extension_converter.cc
 create mode 100644 libcef/renderer/embed/shell/common/gin_converters/extension_converter.h
 create mode 100644 libcef/renderer/embed/shell/common/gin_converters/file_dialog_converter.cc
 create mode 100644 libcef/renderer/embed/shell/common/gin_converters/file_dialog_converter.h
 create mode 100644 libcef/renderer/embed/shell/common/gin_converters/file_path_converter.h
 create mode 100644 libcef/renderer/embed/shell/common/gin_converters/frame_converter.cc
 create mode 100644 libcef/renderer/embed/shell/common/gin_converters/frame_converter.h
 create mode 100644 libcef/renderer/embed/shell/common/gin_converters/gfx_converter.cc
 create mode 100644 libcef/renderer/embed/shell/common/gin_converters/gfx_converter.h
 create mode 100644 libcef/renderer/embed/shell/common/gin_converters/guid_converter.h
 create mode 100644 libcef/renderer/embed/shell/common/gin_converters/gurl_converter.h
 create mode 100644 libcef/renderer/embed/shell/common/gin_converters/image_converter.cc
 create mode 100644 libcef/renderer/embed/shell/common/gin_converters/image_converter.h
 create mode 100644 libcef/renderer/embed/shell/common/gin_converters/message_box_converter.cc
 create mode 100644 libcef/renderer/embed/shell/common/gin_converters/message_box_converter.h
 create mode 100644 libcef/renderer/embed/shell/common/gin_converters/native_window_converter.h
 create mode 100644 libcef/renderer/embed/shell/common/gin_converters/net_converter.cc
 create mode 100644 libcef/renderer/embed/shell/common/gin_converters/net_converter.h
 create mode 100644 libcef/renderer/embed/shell/common/gin_converters/std_converter.h
 create mode 100644 libcef/renderer/embed/shell/common/gin_converters/time_converter.cc
 create mode 100644 libcef/renderer/embed/shell/common/gin_converters/time_converter.h
 create mode 100644 libcef/renderer/embed/shell/common/gin_converters/value_converter.cc
 create mode 100644 libcef/renderer/embed/shell/common/gin_converters/value_converter.h
 create mode 100644 libcef/renderer/embed/shell/common/gin_helper/accessor.h
 create mode 100644 libcef/renderer/embed/shell/common/gin_helper/arguments.cc
 create mode 100644 libcef/renderer/embed/shell/common/gin_helper/arguments.h
 create mode 100644 libcef/renderer/embed/shell/common/gin_helper/callback.cc
 create mode 100644 libcef/renderer/embed/shell/common/gin_helper/callback.h
 create mode 100644 libcef/renderer/embed/shell/common/gin_helper/cleaned_up_at_exit.cc
 create mode 100644 libcef/renderer/embed/shell/common/gin_helper/cleaned_up_at_exit.h
 create mode 100644 libcef/renderer/embed/shell/common/gin_helper/constructible.h
 create mode 100644 libcef/renderer/embed/shell/common/gin_helper/constructor.h
 create mode 100644 libcef/renderer/embed/shell/common/gin_helper/destroyable.cc
 create mode 100644 libcef/renderer/embed/shell/common/gin_helper/destroyable.h
 create mode 100644 libcef/renderer/embed/shell/common/gin_helper/dictionary.h
 create mode 100644 libcef/renderer/embed/shell/common/gin_helper/error_thrower.cc
 create mode 100644 libcef/renderer/embed/shell/common/gin_helper/error_thrower.h
 create mode 100644 libcef/renderer/embed/shell/common/gin_helper/event_emitter.cc
 create mode 100644 libcef/renderer/embed/shell/common/gin_helper/event_emitter.h
 create mode 100644 libcef/renderer/embed/shell/common/gin_helper/event_emitter_caller.cc
 create mode 100644 libcef/renderer/embed/shell/common/gin_helper/event_emitter_caller.h
 create mode 100644 libcef/renderer/embed/shell/common/gin_helper/function_template.cc
 create mode 100644 libcef/renderer/embed/shell/common/gin_helper/function_template.h
 create mode 100644 libcef/renderer/embed/shell/common/gin_helper/function_template_extensions.h
 create mode 100644 libcef/renderer/embed/shell/common/gin_helper/locker.cc
 create mode 100644 libcef/renderer/embed/shell/common/gin_helper/locker.h
 create mode 100644 libcef/renderer/embed/shell/common/gin_helper/microtasks_scope.cc
 create mode 100644 libcef/renderer/embed/shell/common/gin_helper/microtasks_scope.h
 create mode 100644 libcef/renderer/embed/shell/common/gin_helper/object_template_builder.cc
 create mode 100644 libcef/renderer/embed/shell/common/gin_helper/object_template_builder.h
 create mode 100644 libcef/renderer/embed/shell/common/gin_helper/persistent_dictionary.cc
 create mode 100644 libcef/renderer/embed/shell/common/gin_helper/persistent_dictionary.h
 create mode 100644 libcef/renderer/embed/shell/common/gin_helper/pinnable.h
 create mode 100644 libcef/renderer/embed/shell/common/gin_helper/promise.cc
 create mode 100644 libcef/renderer/embed/shell/common/gin_helper/promise.h
 create mode 100644 libcef/renderer/embed/shell/common/gin_helper/trackable_object.cc
 create mode 100644 libcef/renderer/embed/shell/common/gin_helper/trackable_object.h
 create mode 100644 libcef/renderer/embed/shell/common/gin_helper/wrappable.cc
 create mode 100644 libcef/renderer/embed/shell/common/gin_helper/wrappable.h
 create mode 100644 libcef/renderer/embed/shell/common/gin_helper/wrappable_base.h

diff --git a/BUILD.gn b/BUILD.gn
index 57172083f..6a15ee5d5 100644
--- a/BUILD.gn
+++ b/BUILD.gn
@@ -401,8 +401,21 @@ test("libcef_static_unittests") {
 }
 
 static_library("libcef_static") {
+  configs += [ "//cefnode/node:node_internals" ]
   sources = includes_common +
             gypi_paths.autogen_cpp_includes + [
+                  "libcef/renderer/embed/node_bindings_win.cc",
+    "libcef/renderer/embed/node_bindings_win.h",
+    "libcef/renderer/embed/node_bindings.cc",
+    "libcef/renderer/embed/node_bindings.h",
+    "libcef/renderer/embed/node_util.cc",
+    "libcef/renderer/embed/node_util.h",
+    "libcef/renderer/embed/shell/common/gin_helper/microtasks_scope.cc",
+    "libcef/renderer/embed/shell/common/gin_helper/microtasks_scope.h",
+    "libcef/renderer/embed/shell/common/gin_helper/locker.cc",
+    "libcef/renderer/embed/shell/common/gin_helper/locker.h",
+    "libcef/renderer/embed/shell/common/gin_helper/event_emitter_caller.cc",
+    "libcef/renderer/embed/shell/common/gin_helper/event_emitter_caller.h",
     "libcef/browser/alloy/alloy_browser_context.cc",
     "libcef/browser/alloy/alloy_browser_context.h",
     "libcef/browser/alloy/alloy_browser_host_impl.cc",
@@ -818,6 +831,7 @@ static_library("libcef_static") {
   ]
 
   deps = [
+    "//cefnode/node:node_lib",
     ":cef_make_headers",
     "libcef/common/mojom",
 
diff --git a/libcef/renderer/embed/electron/pop_node_defines.h b/libcef/renderer/embed/electron/pop_node_defines.h
new file mode 100644
index 000000000..9ccd6428f
--- /dev/null
+++ b/libcef/renderer/embed/electron/pop_node_defines.h
@@ -0,0 +1,275 @@
+#pragma pop_macro("SRC_TRACE_EVENT_COMMON_H")
+#pragma pop_macro("TRACE_DISABLED_BY_DEFAULT")
+#pragma pop_macro("TRACE_EVENT0")
+#pragma pop_macro("TRACE_EVENT_WITH_FLOW0")
+#pragma pop_macro("TRACE_EVENT1")
+#pragma pop_macro("TRACE_EVENT_WITH_FLOW1")
+#pragma pop_macro("TRACE_EVENT2")
+#pragma pop_macro("TRACE_EVENT_WITH_FLOW2")
+#pragma pop_macro("TRACE_EVENT_INSTANT0")
+#pragma pop_macro("TRACE_EVENT_INSTANT1")
+#pragma pop_macro("TRACE_EVENT_INSTANT2")
+#pragma pop_macro("TRACE_EVENT_COPY_INSTANT0")
+#pragma pop_macro("TRACE_EVENT_COPY_INSTANT1")
+#pragma pop_macro("TRACE_EVENT_COPY_INSTANT2")
+#pragma pop_macro("TRACE_EVENT_INSTANT_WITH_TIMESTAMP0")
+#pragma pop_macro("TRACE_EVENT_INSTANT_WITH_TIMESTAMP1")
+#pragma pop_macro("TRACE_EVENT_BEGIN")
+#pragma pop_macro("TRACE_EVENT_BEGIN0")
+#pragma pop_macro("TRACE_EVENT_BEGIN1")
+#pragma pop_macro("TRACE_EVENT_BEGIN2")
+#pragma pop_macro("TRACE_EVENT_COPY_BEGIN0")
+#pragma pop_macro("TRACE_EVENT_COPY_BEGIN1")
+#pragma pop_macro("TRACE_EVENT_COPY_BEGIN2")
+#pragma pop_macro("TRACE_EVENT_BEGIN_WITH_ID_TID_AND_TIMESTAMP0")
+#pragma pop_macro("TRACE_EVENT_COPY_BEGIN_WITH_ID_TID_AND_TIMESTAMP0")
+#pragma pop_macro("TRACE_EVENT_COPY_BEGIN_WITH_ID_TID_AND_TIMESTAMP1")
+#pragma pop_macro("TRACE_EVENT_COPY_BEGIN_WITH_ID_TID_AND_TIMESTAMP2")
+#pragma pop_macro("TRACE_EVENT_END")
+#pragma pop_macro("TRACE_EVENT_END0")
+#pragma pop_macro("TRACE_EVENT_END1")
+#pragma pop_macro("TRACE_EVENT_END2")
+#pragma pop_macro("TRACE_EVENT_COPY_END0")
+#pragma pop_macro("TRACE_EVENT_COPY_END1")
+#pragma pop_macro("TRACE_EVENT_COPY_END2")
+#pragma pop_macro("TRACE_EVENT_MARK_WITH_TIMESTAMP0")
+#pragma pop_macro("TRACE_EVENT_MARK_WITH_TIMESTAMP1")
+#pragma pop_macro("TRACE_EVENT_MARK_WITH_TIMESTAMP2")
+#pragma pop_macro("TRACE_EVENT_COPY_MARK")
+#pragma pop_macro("TRACE_EVENT_COPY_MARK_WITH_TIMESTAMP")
+#pragma pop_macro("TRACE_EVENT_END_WITH_ID_TID_AND_TIMESTAMP0")
+#pragma pop_macro("TRACE_EVENT_COPY_END_WITH_ID_TID_AND_TIMESTAMP0")
+#pragma pop_macro("TRACE_EVENT_COPY_END_WITH_ID_TID_AND_TIMESTAMP1")
+#pragma pop_macro("TRACE_EVENT_COPY_END_WITH_ID_TID_AND_TIMESTAMP2")
+#pragma pop_macro("TRACE_COUNTER1")
+#pragma pop_macro("TRACE_COPY_COUNTER1")
+#pragma pop_macro("TRACE_COUNTER2")
+#pragma pop_macro("TRACE_COPY_COUNTER2")
+#pragma pop_macro("TRACE_COUNTER_WITH_TIMESTAMP1")
+#pragma pop_macro("TRACE_COUNTER_WITH_TIMESTAMP2")
+#pragma pop_macro("TRACE_COUNTER_ID1")
+#pragma pop_macro("TRACE_COPY_COUNTER_ID1")
+#pragma pop_macro("TRACE_COUNTER_ID2")
+#pragma pop_macro("TRACE_COPY_COUNTER_ID2")
+#pragma pop_macro("TRACE_EVENT_SAMPLE_WITH_TID_AND_TIMESTAMP0")
+#pragma pop_macro("TRACE_EVENT_SAMPLE_WITH_TID_AND_TIMESTAMP1")
+#pragma pop_macro("TRACE_EVENT_SAMPLE_WITH_TID_AND_TIMESTAMP2")
+#pragma pop_macro("TRACE_EVENT_SAMPLE_WITH_ID1")
+#pragma pop_macro("TRACE_EVENT_ASYNC_BEGIN0")
+#pragma pop_macro("TRACE_EVENT_ASYNC_BEGIN1")
+#pragma pop_macro("TRACE_EVENT_ASYNC_BEGIN2")
+#pragma pop_macro("TRACE_EVENT_COPY_ASYNC_BEGIN0")
+#pragma pop_macro("TRACE_EVENT_COPY_ASYNC_BEGIN1")
+#pragma pop_macro("TRACE_EVENT_COPY_ASYNC_BEGIN2")
+#pragma pop_macro("TRACE_EVENT_ASYNC_BEGIN_WITH_TIMESTAMP0")
+#pragma pop_macro("TRACE_EVENT_ASYNC_BEGIN_WITH_TIMESTAMP1")
+#pragma pop_macro("TRACE_EVENT_ASYNC_BEGIN_WITH_TIMESTAMP2")
+#pragma pop_macro("TRACE_EVENT_COPY_ASYNC_BEGIN_WITH_TIMESTAMP0")
+#pragma pop_macro("TRACE_EVENT_ASYNC_STEP_INTO0")
+#pragma pop_macro("TRACE_EVENT_ASYNC_STEP_INTO1")
+#pragma pop_macro("TRACE_EVENT_ASYNC_STEP_INTO_WITH_TIMESTAMP0")
+#pragma pop_macro("TRACE_EVENT_ASYNC_STEP_PAST0")
+#pragma pop_macro("TRACE_EVENT_ASYNC_STEP_PAST1")
+#pragma pop_macro("TRACE_EVENT_ASYNC_END0")
+#pragma pop_macro("TRACE_EVENT_ASYNC_END1")
+#pragma pop_macro("TRACE_EVENT_ASYNC_END2")
+#pragma pop_macro("TRACE_EVENT_COPY_ASYNC_END0")
+#pragma pop_macro("TRACE_EVENT_COPY_ASYNC_END1")
+#pragma pop_macro("TRACE_EVENT_COPY_ASYNC_END2")
+#pragma pop_macro("TRACE_EVENT_ASYNC_END_WITH_TIMESTAMP0")
+#pragma pop_macro("TRACE_EVENT_ASYNC_END_WITH_TIMESTAMP1")
+#pragma pop_macro("TRACE_EVENT_ASYNC_END_WITH_TIMESTAMP2")
+#pragma pop_macro("TRACE_EVENT_NESTABLE_ASYNC_BEGIN0")
+#pragma pop_macro("TRACE_EVENT_NESTABLE_ASYNC_BEGIN1")
+#pragma pop_macro("TRACE_EVENT_NESTABLE_ASYNC_BEGIN2")
+#pragma pop_macro("TRACE_EVENT_NESTABLE_ASYNC_END0")
+#pragma pop_macro("TRACE_EVENT_NESTABLE_ASYNC_END1")
+#pragma pop_macro("TRACE_EVENT_NESTABLE_ASYNC_END2")
+#pragma pop_macro("TRACE_EVENT_NESTABLE_ASYNC_INSTANT0")
+#pragma pop_macro("TRACE_EVENT_NESTABLE_ASYNC_INSTANT1")
+#pragma pop_macro("TRACE_EVENT_NESTABLE_ASYNC_INSTANT2")
+#pragma pop_macro("TRACE_EVENT_COPY_NESTABLE_ASYNC_BEGIN_WITH_TTS2")
+#pragma pop_macro("TRACE_EVENT_COPY_NESTABLE_ASYNC_END_WITH_TTS2")
+#pragma pop_macro("TRACE_EVENT_NESTABLE_ASYNC_BEGIN_WITH_TIMESTAMP0")
+#pragma pop_macro("TRACE_EVENT_NESTABLE_ASYNC_END_WITH_TIMESTAMP0")
+#pragma pop_macro("TRACE_EVENT_NESTABLE_ASYNC_END_WITH_TIMESTAMP1")
+#pragma pop_macro("TRACE_EVENT_NESTABLE_ASYNC_INSTANT_WITH_TIMESTAMP0")
+#pragma pop_macro("TRACE_EVENT_COPY_NESTABLE_ASYNC_BEGIN_WITH_TIMESTAMP0")
+#pragma pop_macro("TRACE_EVENT_COPY_NESTABLE_ASYNC_END_WITH_TIMESTAMP0")
+#pragma pop_macro("TRACE_EVENT_FLOW_BEGIN0")
+#pragma pop_macro("TRACE_EVENT_FLOW_BEGIN1")
+#pragma pop_macro("TRACE_EVENT_FLOW_BEGIN2")
+#pragma pop_macro("TRACE_EVENT_COPY_FLOW_BEGIN0")
+#pragma pop_macro("TRACE_EVENT_COPY_FLOW_BEGIN1")
+#pragma pop_macro("TRACE_EVENT_COPY_FLOW_BEGIN2")
+#pragma pop_macro("TRACE_EVENT_FLOW_STEP0")
+#pragma pop_macro("TRACE_EVENT_FLOW_STEP1")
+#pragma pop_macro("TRACE_EVENT_COPY_FLOW_STEP0")
+#pragma pop_macro("TRACE_EVENT_COPY_FLOW_STEP1")
+#pragma pop_macro("TRACE_EVENT_FLOW_END0")
+#pragma pop_macro("TRACE_EVENT_FLOW_END_BIND_TO_ENCLOSING0")
+#pragma pop_macro("TRACE_EVENT_FLOW_END1")
+#pragma pop_macro("TRACE_EVENT_FLOW_END2")
+#pragma pop_macro("TRACE_EVENT_COPY_FLOW_END0")
+#pragma pop_macro("TRACE_EVENT_COPY_FLOW_END1")
+#pragma pop_macro("TRACE_EVENT_COPY_FLOW_END2")
+#pragma pop_macro("TRACE_TASK_EXECUTION")
+#pragma pop_macro("TRACE_EVENT_METADATA1")
+#pragma pop_macro("TRACE_EVENT_CLOCK_SYNC_RECEIVER")
+#pragma pop_macro("TRACE_EVENT_CLOCK_SYNC_ISSUER")
+#pragma pop_macro("TRACE_EVENT_OBJECT_CREATED_WITH_ID")
+#pragma pop_macro("TRACE_EVENT_OBJECT_SNAPSHOT_WITH_ID")
+#pragma pop_macro("TRACE_EVENT_OBJECT_SNAPSHOT_WITH_ID_AND_TIMESTAMP")
+#pragma pop_macro("TRACE_EVENT_OBJECT_DELETED_WITH_ID")
+#pragma pop_macro("TRACE_EVENT_ENTER_CONTEXT")
+#pragma pop_macro("TRACE_EVENT_LEAVE_CONTEXT")
+#pragma pop_macro("TRACE_EVENT_SCOPED_CONTEXT")
+#pragma pop_macro("TRACE_LINK_IDS")
+#pragma pop_macro("TRACE_EVENT_CATEGORY_GROUP_ENABLED")
+#pragma pop_macro("TRACE_EVENT_WARMUP_CATEGORY")
+#pragma pop_macro("TRACE_EVENT_IS_NEW_TRACE")
+#pragma pop_macro("TRACE_EVENT_PHASE_BEGIN")
+#pragma pop_macro("TRACE_EVENT_PHASE_END")
+#pragma pop_macro("TRACE_EVENT_PHASE_COMPLETE")
+#pragma pop_macro("TRACE_EVENT_PHASE_INSTANT")
+#pragma pop_macro("TRACE_EVENT_PHASE_ASYNC_BEGIN")
+#pragma pop_macro("TRACE_EVENT_PHASE_ASYNC_STEP_INTO")
+#pragma pop_macro("TRACE_EVENT_PHASE_ASYNC_STEP_PAST")
+#pragma pop_macro("TRACE_EVENT_PHASE_ASYNC_END")
+#pragma pop_macro("TRACE_EVENT_PHASE_NESTABLE_ASYNC_BEGIN")
+#pragma pop_macro("TRACE_EVENT_PHASE_NESTABLE_ASYNC_END")
+#pragma pop_macro("TRACE_EVENT_PHASE_NESTABLE_ASYNC_INSTANT")
+#pragma pop_macro("TRACE_EVENT_PHASE_FLOW_BEGIN")
+#pragma pop_macro("TRACE_EVENT_PHASE_FLOW_STEP")
+#pragma pop_macro("TRACE_EVENT_PHASE_FLOW_END")
+#pragma pop_macro("TRACE_EVENT_PHASE_METADATA")
+#pragma pop_macro("TRACE_EVENT_PHASE_COUNTER")
+#pragma pop_macro("TRACE_EVENT_PHASE_SAMPLE")
+#pragma pop_macro("TRACE_EVENT_PHASE_CREATE_OBJECT")
+#pragma pop_macro("TRACE_EVENT_PHASE_SNAPSHOT_OBJECT")
+#pragma pop_macro("TRACE_EVENT_PHASE_DELETE_OBJECT")
+#pragma pop_macro("TRACE_EVENT_PHASE_MEMORY_DUMP")
+#pragma pop_macro("TRACE_EVENT_PHASE_MARK")
+#pragma pop_macro("TRACE_EVENT_PHASE_CLOCK_SYNC")
+#pragma pop_macro("TRACE_EVENT_PHASE_ENTER_CONTEXT")
+#pragma pop_macro("TRACE_EVENT_PHASE_LEAVE_CONTEXT")
+#pragma pop_macro("TRACE_EVENT_PHASE_LINK_IDS")
+#pragma pop_macro("TRACE_EVENT_FLAG_NONE")
+#pragma pop_macro("TRACE_EVENT_FLAG_COPY")
+#pragma pop_macro("TRACE_EVENT_FLAG_HAS_ID")
+#pragma pop_macro("TRACE_EVENT_FLAG_MANGLE_ID")
+#pragma pop_macro("TRACE_EVENT_FLAG_SCOPE_OFFSET")
+#pragma pop_macro("TRACE_EVENT_FLAG_SCOPE_EXTRA")
+#pragma pop_macro("TRACE_EVENT_FLAG_EXPLICIT_TIMESTAMP")
+#pragma pop_macro("TRACE_EVENT_FLAG_ASYNC_TTS")
+#pragma pop_macro("TRACE_EVENT_FLAG_BIND_TO_ENCLOSING")
+#pragma pop_macro("TRACE_EVENT_FLAG_FLOW_IN")
+#pragma pop_macro("TRACE_EVENT_FLAG_FLOW_OUT")
+#pragma pop_macro("TRACE_EVENT_FLAG_HAS_CONTEXT_ID")
+#pragma pop_macro("TRACE_EVENT_FLAG_HAS_PROCESS_ID")
+#pragma pop_macro("TRACE_EVENT_FLAG_HAS_LOCAL_ID")
+#pragma pop_macro("TRACE_EVENT_FLAG_HAS_GLOBAL_ID")
+#pragma pop_macro("TRACE_EVENT_FLAG_SCOPE_MASK")
+#pragma pop_macro("TRACE_VALUE_TYPE_BOOL")
+#pragma pop_macro("TRACE_VALUE_TYPE_UINT")
+#pragma pop_macro("TRACE_VALUE_TYPE_INT")
+#pragma pop_macro("TRACE_VALUE_TYPE_DOUBLE")
+#pragma pop_macro("TRACE_VALUE_TYPE_POINTER")
+#pragma pop_macro("TRACE_VALUE_TYPE_STRING")
+#pragma pop_macro("TRACE_VALUE_TYPE_COPY_STRING")
+#pragma pop_macro("TRACE_VALUE_TYPE_CONVERTABLE")
+#pragma pop_macro("TRACE_EVENT_SCOPE_GLOBAL")
+#pragma pop_macro("TRACE_EVENT_SCOPE_PROCESS")
+#pragma pop_macro("TRACE_EVENT_SCOPE_THREAD")
+#pragma pop_macro("TRACE_EVENT_SCOPE_NAME_GLOBAL")
+#pragma pop_macro("TRACE_EVENT_SCOPE_NAME_PROCESS")
+#pragma pop_macro("TRACE_EVENT_SCOPE_NAME_THREAD")
+#pragma pop_macro("SRC_TRACING_TRACE_EVENT_H_")
+#pragma pop_macro("TRACE_STR_COPY")
+#pragma pop_macro("TRACE_ID_MANGLE")
+#pragma pop_macro("TRACE_ID_DONT_MANGLE")
+#pragma pop_macro("TRACE_ID_WITH_SCOPE")
+#pragma pop_macro("INTERNAL_TRACE_EVENT_CATEGORY_GROUP_ENABLED_FOR_RECORDING_MODE")
+#pragma pop_macro("INTERNAL_TRACE_MEMORY")
+#pragma pop_macro("TRACE_EVENT_API_GET_CATEGORY_GROUP_ENABLED")
+#pragma pop_macro("TRACE_EVENT_API_GET_NUM_TRACES_RECORDED")
+#pragma pop_macro("TRACE_EVENT_API_ADD_TRACE_EVENT")
+#pragma pop_macro("TRACE_EVENT_API_ADD_TRACE_EVENT_WITH_TIMESTAMP")
+#pragma pop_macro("TRACE_EVENT_API_UPDATE_TRACE_EVENT_DURATION")
+#pragma pop_macro("TRACE_EVENT_API_ADD_METADATA_EVENT")
+#pragma pop_macro("TRACE_EVENT_API_ATOMIC_WORD")
+#pragma pop_macro("TRACE_EVENT_API_ATOMIC_WORD_VALUE")
+#pragma pop_macro("TRACE_EVENT_API_ATOMIC_LOAD")
+#pragma pop_macro("TRACE_EVENT_API_ATOMIC_STORE")
+#pragma pop_macro("INTERNAL_TRACE_EVENT_UID3")
+#pragma pop_macro("INTERNAL_TRACE_EVENT_UID2")
+#pragma pop_macro("INTERNAL_TRACE_EVENT_UID")
+#pragma pop_macro("INTERNAL_TRACE_EVENT_GET_CATEGORY_INFO_CUSTOM_VARIABLES")
+#pragma pop_macro("INTERNAL_TRACE_EVENT_GET_CATEGORY_INFO")
+#pragma pop_macro("INTERNAL_TRACE_EVENT_ADD")
+#pragma pop_macro("INTERNAL_TRACE_EVENT_ADD_SCOPED")
+#pragma pop_macro("INTERNAL_TRACE_EVENT_ADD_SCOPED_WITH_FLOW")
+#pragma pop_macro("INTERNAL_TRACE_EVENT_ADD_WITH_ID")
+#pragma pop_macro("INTERNAL_TRACE_EVENT_ADD_WITH_TIMESTAMP")
+#pragma pop_macro("INTERNAL_TRACE_EVENT_ADD_WITH_ID_AND_TIMESTAMP")
+#pragma pop_macro("INTERNAL_TRACE_EVENT_ADD_WITH_ID_TID_AND_TIMESTAMP")
+#pragma pop_macro("INTERNAL_TRACE_EVENT_METADATA_ADD")
+#pragma pop_macro("INTERNAL_TRACE_EVENT_SCOPED_CONTEXT")
+#pragma pop_macro("INTERNAL_DECLARE_SET_TRACE_VALUE")
+#pragma pop_macro("INTERNAL_DECLARE_SET_TRACE_VALUE_INT")
+#pragma pop_macro("SRC_UTIL_H_")
+#pragma pop_macro("MUST_USE_RESULT")
+#pragma pop_macro("MUST_USE_RESULT")
+#pragma pop_macro("PATH_MAX_BYTES")
+#pragma pop_macro("PATH_MAX_BYTES")
+#pragma pop_macro("ABORT_NO_BACKTRACE")
+#pragma pop_macro("ABORT_NO_BACKTRACE")
+#pragma pop_macro("ABORT")
+#pragma pop_macro("ERROR_AND_ABORT")
+#pragma pop_macro("LIKELY")
+#pragma pop_macro("UNLIKELY")
+#pragma pop_macro("PRETTY_FUNCTION_NAME")
+#pragma pop_macro("LIKELY")
+#pragma pop_macro("UNLIKELY")
+#pragma pop_macro("PRETTY_FUNCTION_NAME")
+#pragma pop_macro("STRINGIFY_")
+#pragma pop_macro("STRINGIFY")
+#pragma pop_macro("CHECK")
+#pragma pop_macro("CHECK_EQ")
+#pragma pop_macro("CHECK_GE")
+#pragma pop_macro("CHECK_GT")
+#pragma pop_macro("CHECK_LE")
+#pragma pop_macro("CHECK_LT")
+#pragma pop_macro("CHECK_NE")
+#pragma pop_macro("CHECK_NULL")
+#pragma pop_macro("CHECK_NOT_NULL")
+#pragma pop_macro("CHECK_IMPLIES")
+#pragma pop_macro("DCHECK")
+#pragma pop_macro("DCHECK_EQ")
+#pragma pop_macro("DCHECK_GE")
+#pragma pop_macro("DCHECK_GT")
+#pragma pop_macro("DCHECK_LE")
+#pragma pop_macro("DCHECK_LT")
+#pragma pop_macro("DCHECK_NE")
+#pragma pop_macro("DCHECK_NULL")
+#pragma pop_macro("DCHECK_NOT_NULL")
+#pragma pop_macro("DCHECK_IMPLIES")
+#pragma pop_macro("DCHECK")
+#pragma pop_macro("DCHECK_EQ")
+#pragma pop_macro("DCHECK_GE")
+#pragma pop_macro("DCHECK_GT")
+#pragma pop_macro("DCHECK_LE")
+#pragma pop_macro("DCHECK_LT")
+#pragma pop_macro("DCHECK_NE")
+#pragma pop_macro("DCHECK_NULL")
+#pragma pop_macro("DCHECK_NOT_NULL")
+#pragma pop_macro("DCHECK_IMPLIES")
+#pragma pop_macro("UNREACHABLE")
+#pragma pop_macro("SPREAD_BUFFER_ARG")
+#pragma pop_macro("READONLY_PROPERTY")
+#pragma pop_macro("READONLY_DONT_ENUM_PROPERTY")
+#pragma pop_macro("READONLY_FALSE_PROPERTY")
+#pragma pop_macro("READONLY_TRUE_PROPERTY")
+#pragma pop_macro("READONLY_STRING_PROPERTY")
+#pragma pop_macro("NODE_DEFINE_STRING_CONSTANT")
+#pragma pop_macro("MAYBE_FIELD_PTR")
diff --git a/libcef/renderer/embed/electron/push_and_undef_node_defines.h b/libcef/renderer/embed/electron/push_and_undef_node_defines.h
new file mode 100644
index 000000000..9fb69136e
--- /dev/null
+++ b/libcef/renderer/embed/electron/push_and_undef_node_defines.h
@@ -0,0 +1,550 @@
+#pragma push_macro("SRC_TRACE_EVENT_COMMON_H")
+#undef SRC_TRACE_EVENT_COMMON_H
+#pragma push_macro("TRACE_DISABLED_BY_DEFAULT")
+#undef TRACE_DISABLED_BY_DEFAULT
+#pragma push_macro("TRACE_EVENT0")
+#undef TRACE_EVENT0
+#pragma push_macro("TRACE_EVENT_WITH_FLOW0")
+#undef TRACE_EVENT_WITH_FLOW0
+#pragma push_macro("TRACE_EVENT1")
+#undef TRACE_EVENT1
+#pragma push_macro("TRACE_EVENT_WITH_FLOW1")
+#undef TRACE_EVENT_WITH_FLOW1
+#pragma push_macro("TRACE_EVENT2")
+#undef TRACE_EVENT2
+#pragma push_macro("TRACE_EVENT_WITH_FLOW2")
+#undef TRACE_EVENT_WITH_FLOW2
+#pragma push_macro("TRACE_EVENT_INSTANT0")
+#undef TRACE_EVENT_INSTANT0
+#pragma push_macro("TRACE_EVENT_INSTANT1")
+#undef TRACE_EVENT_INSTANT1
+#pragma push_macro("TRACE_EVENT_INSTANT2")
+#undef TRACE_EVENT_INSTANT2
+#pragma push_macro("TRACE_EVENT_COPY_INSTANT0")
+#undef TRACE_EVENT_COPY_INSTANT0
+#pragma push_macro("TRACE_EVENT_COPY_INSTANT1")
+#undef TRACE_EVENT_COPY_INSTANT1
+#pragma push_macro("TRACE_EVENT_COPY_INSTANT2")
+#undef TRACE_EVENT_COPY_INSTANT2
+#pragma push_macro("TRACE_EVENT_INSTANT_WITH_TIMESTAMP0")
+#undef TRACE_EVENT_INSTANT_WITH_TIMESTAMP0
+#pragma push_macro("TRACE_EVENT_INSTANT_WITH_TIMESTAMP1")
+#undef TRACE_EVENT_INSTANT_WITH_TIMESTAMP1
+#pragma push_macro("TRACE_EVENT_BEGIN")
+#undef TRACE_EVENT_BEGIN
+#pragma push_macro("TRACE_EVENT_BEGIN0")
+#undef TRACE_EVENT_BEGIN0
+#pragma push_macro("TRACE_EVENT_BEGIN1")
+#undef TRACE_EVENT_BEGIN1
+#pragma push_macro("TRACE_EVENT_BEGIN2")
+#undef TRACE_EVENT_BEGIN2
+#pragma push_macro("TRACE_EVENT_COPY_BEGIN0")
+#undef TRACE_EVENT_COPY_BEGIN0
+#pragma push_macro("TRACE_EVENT_COPY_BEGIN1")
+#undef TRACE_EVENT_COPY_BEGIN1
+#pragma push_macro("TRACE_EVENT_COPY_BEGIN2")
+#undef TRACE_EVENT_COPY_BEGIN2
+#pragma push_macro("TRACE_EVENT_BEGIN_WITH_ID_TID_AND_TIMESTAMP0")
+#undef TRACE_EVENT_BEGIN_WITH_ID_TID_AND_TIMESTAMP0
+#pragma push_macro("TRACE_EVENT_COPY_BEGIN_WITH_ID_TID_AND_TIMESTAMP0")
+#undef TRACE_EVENT_COPY_BEGIN_WITH_ID_TID_AND_TIMESTAMP0
+#pragma push_macro("TRACE_EVENT_COPY_BEGIN_WITH_ID_TID_AND_TIMESTAMP1")
+#undef TRACE_EVENT_COPY_BEGIN_WITH_ID_TID_AND_TIMESTAMP1
+#pragma push_macro("TRACE_EVENT_COPY_BEGIN_WITH_ID_TID_AND_TIMESTAMP2")
+#undef TRACE_EVENT_COPY_BEGIN_WITH_ID_TID_AND_TIMESTAMP2
+#pragma push_macro("TRACE_EVENT_END")
+#undef TRACE_EVENT_END
+#pragma push_macro("TRACE_EVENT_END0")
+#undef TRACE_EVENT_END0
+#pragma push_macro("TRACE_EVENT_END1")
+#undef TRACE_EVENT_END1
+#pragma push_macro("TRACE_EVENT_END2")
+#undef TRACE_EVENT_END2
+#pragma push_macro("TRACE_EVENT_COPY_END0")
+#undef TRACE_EVENT_COPY_END0
+#pragma push_macro("TRACE_EVENT_COPY_END1")
+#undef TRACE_EVENT_COPY_END1
+#pragma push_macro("TRACE_EVENT_COPY_END2")
+#undef TRACE_EVENT_COPY_END2
+#pragma push_macro("TRACE_EVENT_MARK_WITH_TIMESTAMP0")
+#undef TRACE_EVENT_MARK_WITH_TIMESTAMP0
+#pragma push_macro("TRACE_EVENT_MARK_WITH_TIMESTAMP1")
+#undef TRACE_EVENT_MARK_WITH_TIMESTAMP1
+#pragma push_macro("TRACE_EVENT_MARK_WITH_TIMESTAMP2")
+#undef TRACE_EVENT_MARK_WITH_TIMESTAMP2
+#pragma push_macro("TRACE_EVENT_COPY_MARK")
+#undef TRACE_EVENT_COPY_MARK
+#pragma push_macro("TRACE_EVENT_COPY_MARK_WITH_TIMESTAMP")
+#undef TRACE_EVENT_COPY_MARK_WITH_TIMESTAMP
+#pragma push_macro("TRACE_EVENT_END_WITH_ID_TID_AND_TIMESTAMP0")
+#undef TRACE_EVENT_END_WITH_ID_TID_AND_TIMESTAMP0
+#pragma push_macro("TRACE_EVENT_COPY_END_WITH_ID_TID_AND_TIMESTAMP0")
+#undef TRACE_EVENT_COPY_END_WITH_ID_TID_AND_TIMESTAMP0
+#pragma push_macro("TRACE_EVENT_COPY_END_WITH_ID_TID_AND_TIMESTAMP1")
+#undef TRACE_EVENT_COPY_END_WITH_ID_TID_AND_TIMESTAMP1
+#pragma push_macro("TRACE_EVENT_COPY_END_WITH_ID_TID_AND_TIMESTAMP2")
+#undef TRACE_EVENT_COPY_END_WITH_ID_TID_AND_TIMESTAMP2
+#pragma push_macro("TRACE_COUNTER1")
+#undef TRACE_COUNTER1
+#pragma push_macro("TRACE_COPY_COUNTER1")
+#undef TRACE_COPY_COUNTER1
+#pragma push_macro("TRACE_COUNTER2")
+#undef TRACE_COUNTER2
+#pragma push_macro("TRACE_COPY_COUNTER2")
+#undef TRACE_COPY_COUNTER2
+#pragma push_macro("TRACE_COUNTER_WITH_TIMESTAMP1")
+#undef TRACE_COUNTER_WITH_TIMESTAMP1
+#pragma push_macro("TRACE_COUNTER_WITH_TIMESTAMP2")
+#undef TRACE_COUNTER_WITH_TIMESTAMP2
+#pragma push_macro("TRACE_COUNTER_ID1")
+#undef TRACE_COUNTER_ID1
+#pragma push_macro("TRACE_COPY_COUNTER_ID1")
+#undef TRACE_COPY_COUNTER_ID1
+#pragma push_macro("TRACE_COUNTER_ID2")
+#undef TRACE_COUNTER_ID2
+#pragma push_macro("TRACE_COPY_COUNTER_ID2")
+#undef TRACE_COPY_COUNTER_ID2
+#pragma push_macro("TRACE_EVENT_SAMPLE_WITH_TID_AND_TIMESTAMP0")
+#undef TRACE_EVENT_SAMPLE_WITH_TID_AND_TIMESTAMP0
+#pragma push_macro("TRACE_EVENT_SAMPLE_WITH_TID_AND_TIMESTAMP1")
+#undef TRACE_EVENT_SAMPLE_WITH_TID_AND_TIMESTAMP1
+#pragma push_macro("TRACE_EVENT_SAMPLE_WITH_TID_AND_TIMESTAMP2")
+#undef TRACE_EVENT_SAMPLE_WITH_TID_AND_TIMESTAMP2
+#pragma push_macro("TRACE_EVENT_SAMPLE_WITH_ID1")
+#undef TRACE_EVENT_SAMPLE_WITH_ID1
+#pragma push_macro("TRACE_EVENT_ASYNC_BEGIN0")
+#undef TRACE_EVENT_ASYNC_BEGIN0
+#pragma push_macro("TRACE_EVENT_ASYNC_BEGIN1")
+#undef TRACE_EVENT_ASYNC_BEGIN1
+#pragma push_macro("TRACE_EVENT_ASYNC_BEGIN2")
+#undef TRACE_EVENT_ASYNC_BEGIN2
+#pragma push_macro("TRACE_EVENT_COPY_ASYNC_BEGIN0")
+#undef TRACE_EVENT_COPY_ASYNC_BEGIN0
+#pragma push_macro("TRACE_EVENT_COPY_ASYNC_BEGIN1")
+#undef TRACE_EVENT_COPY_ASYNC_BEGIN1
+#pragma push_macro("TRACE_EVENT_COPY_ASYNC_BEGIN2")
+#undef TRACE_EVENT_COPY_ASYNC_BEGIN2
+#pragma push_macro("TRACE_EVENT_ASYNC_BEGIN_WITH_TIMESTAMP0")
+#undef TRACE_EVENT_ASYNC_BEGIN_WITH_TIMESTAMP0
+#pragma push_macro("TRACE_EVENT_ASYNC_BEGIN_WITH_TIMESTAMP1")
+#undef TRACE_EVENT_ASYNC_BEGIN_WITH_TIMESTAMP1
+#pragma push_macro("TRACE_EVENT_ASYNC_BEGIN_WITH_TIMESTAMP2")
+#undef TRACE_EVENT_ASYNC_BEGIN_WITH_TIMESTAMP2
+#pragma push_macro("TRACE_EVENT_COPY_ASYNC_BEGIN_WITH_TIMESTAMP0")
+#undef TRACE_EVENT_COPY_ASYNC_BEGIN_WITH_TIMESTAMP0
+#pragma push_macro("TRACE_EVENT_ASYNC_STEP_INTO0")
+#undef TRACE_EVENT_ASYNC_STEP_INTO0
+#pragma push_macro("TRACE_EVENT_ASYNC_STEP_INTO1")
+#undef TRACE_EVENT_ASYNC_STEP_INTO1
+#pragma push_macro("TRACE_EVENT_ASYNC_STEP_INTO_WITH_TIMESTAMP0")
+#undef TRACE_EVENT_ASYNC_STEP_INTO_WITH_TIMESTAMP0
+#pragma push_macro("TRACE_EVENT_ASYNC_STEP_PAST0")
+#undef TRACE_EVENT_ASYNC_STEP_PAST0
+#pragma push_macro("TRACE_EVENT_ASYNC_STEP_PAST1")
+#undef TRACE_EVENT_ASYNC_STEP_PAST1
+#pragma push_macro("TRACE_EVENT_ASYNC_END0")
+#undef TRACE_EVENT_ASYNC_END0
+#pragma push_macro("TRACE_EVENT_ASYNC_END1")
+#undef TRACE_EVENT_ASYNC_END1
+#pragma push_macro("TRACE_EVENT_ASYNC_END2")
+#undef TRACE_EVENT_ASYNC_END2
+#pragma push_macro("TRACE_EVENT_COPY_ASYNC_END0")
+#undef TRACE_EVENT_COPY_ASYNC_END0
+#pragma push_macro("TRACE_EVENT_COPY_ASYNC_END1")
+#undef TRACE_EVENT_COPY_ASYNC_END1
+#pragma push_macro("TRACE_EVENT_COPY_ASYNC_END2")
+#undef TRACE_EVENT_COPY_ASYNC_END2
+#pragma push_macro("TRACE_EVENT_ASYNC_END_WITH_TIMESTAMP0")
+#undef TRACE_EVENT_ASYNC_END_WITH_TIMESTAMP0
+#pragma push_macro("TRACE_EVENT_ASYNC_END_WITH_TIMESTAMP1")
+#undef TRACE_EVENT_ASYNC_END_WITH_TIMESTAMP1
+#pragma push_macro("TRACE_EVENT_ASYNC_END_WITH_TIMESTAMP2")
+#undef TRACE_EVENT_ASYNC_END_WITH_TIMESTAMP2
+#pragma push_macro("TRACE_EVENT_NESTABLE_ASYNC_BEGIN0")
+#undef TRACE_EVENT_NESTABLE_ASYNC_BEGIN0
+#pragma push_macro("TRACE_EVENT_NESTABLE_ASYNC_BEGIN1")
+#undef TRACE_EVENT_NESTABLE_ASYNC_BEGIN1
+#pragma push_macro("TRACE_EVENT_NESTABLE_ASYNC_BEGIN2")
+#undef TRACE_EVENT_NESTABLE_ASYNC_BEGIN2
+#pragma push_macro("TRACE_EVENT_NESTABLE_ASYNC_END0")
+#undef TRACE_EVENT_NESTABLE_ASYNC_END0
+#pragma push_macro("TRACE_EVENT_NESTABLE_ASYNC_END1")
+#undef TRACE_EVENT_NESTABLE_ASYNC_END1
+#pragma push_macro("TRACE_EVENT_NESTABLE_ASYNC_END2")
+#undef TRACE_EVENT_NESTABLE_ASYNC_END2
+#pragma push_macro("TRACE_EVENT_NESTABLE_ASYNC_INSTANT0")
+#undef TRACE_EVENT_NESTABLE_ASYNC_INSTANT0
+#pragma push_macro("TRACE_EVENT_NESTABLE_ASYNC_INSTANT1")
+#undef TRACE_EVENT_NESTABLE_ASYNC_INSTANT1
+#pragma push_macro("TRACE_EVENT_NESTABLE_ASYNC_INSTANT2")
+#undef TRACE_EVENT_NESTABLE_ASYNC_INSTANT2
+#pragma push_macro("TRACE_EVENT_COPY_NESTABLE_ASYNC_BEGIN_WITH_TTS2")
+#undef TRACE_EVENT_COPY_NESTABLE_ASYNC_BEGIN_WITH_TTS2
+#pragma push_macro("TRACE_EVENT_COPY_NESTABLE_ASYNC_END_WITH_TTS2")
+#undef TRACE_EVENT_COPY_NESTABLE_ASYNC_END_WITH_TTS2
+#pragma push_macro("TRACE_EVENT_NESTABLE_ASYNC_BEGIN_WITH_TIMESTAMP0")
+#undef TRACE_EVENT_NESTABLE_ASYNC_BEGIN_WITH_TIMESTAMP0
+#pragma push_macro("TRACE_EVENT_NESTABLE_ASYNC_END_WITH_TIMESTAMP0")
+#undef TRACE_EVENT_NESTABLE_ASYNC_END_WITH_TIMESTAMP0
+#pragma push_macro("TRACE_EVENT_NESTABLE_ASYNC_END_WITH_TIMESTAMP1")
+#undef TRACE_EVENT_NESTABLE_ASYNC_END_WITH_TIMESTAMP1
+#pragma push_macro("TRACE_EVENT_NESTABLE_ASYNC_INSTANT_WITH_TIMESTAMP0")
+#undef TRACE_EVENT_NESTABLE_ASYNC_INSTANT_WITH_TIMESTAMP0
+#pragma push_macro("TRACE_EVENT_COPY_NESTABLE_ASYNC_BEGIN_WITH_TIMESTAMP0")
+#undef TRACE_EVENT_COPY_NESTABLE_ASYNC_BEGIN_WITH_TIMESTAMP0
+#pragma push_macro("TRACE_EVENT_COPY_NESTABLE_ASYNC_END_WITH_TIMESTAMP0")
+#undef TRACE_EVENT_COPY_NESTABLE_ASYNC_END_WITH_TIMESTAMP0
+#pragma push_macro("TRACE_EVENT_FLOW_BEGIN0")
+#undef TRACE_EVENT_FLOW_BEGIN0
+#pragma push_macro("TRACE_EVENT_FLOW_BEGIN1")
+#undef TRACE_EVENT_FLOW_BEGIN1
+#pragma push_macro("TRACE_EVENT_FLOW_BEGIN2")
+#undef TRACE_EVENT_FLOW_BEGIN2
+#pragma push_macro("TRACE_EVENT_COPY_FLOW_BEGIN0")
+#undef TRACE_EVENT_COPY_FLOW_BEGIN0
+#pragma push_macro("TRACE_EVENT_COPY_FLOW_BEGIN1")
+#undef TRACE_EVENT_COPY_FLOW_BEGIN1
+#pragma push_macro("TRACE_EVENT_COPY_FLOW_BEGIN2")
+#undef TRACE_EVENT_COPY_FLOW_BEGIN2
+#pragma push_macro("TRACE_EVENT_FLOW_STEP0")
+#undef TRACE_EVENT_FLOW_STEP0
+#pragma push_macro("TRACE_EVENT_FLOW_STEP1")
+#undef TRACE_EVENT_FLOW_STEP1
+#pragma push_macro("TRACE_EVENT_COPY_FLOW_STEP0")
+#undef TRACE_EVENT_COPY_FLOW_STEP0
+#pragma push_macro("TRACE_EVENT_COPY_FLOW_STEP1")
+#undef TRACE_EVENT_COPY_FLOW_STEP1
+#pragma push_macro("TRACE_EVENT_FLOW_END0")
+#undef TRACE_EVENT_FLOW_END0
+#pragma push_macro("TRACE_EVENT_FLOW_END_BIND_TO_ENCLOSING0")
+#undef TRACE_EVENT_FLOW_END_BIND_TO_ENCLOSING0
+#pragma push_macro("TRACE_EVENT_FLOW_END1")
+#undef TRACE_EVENT_FLOW_END1
+#pragma push_macro("TRACE_EVENT_FLOW_END2")
+#undef TRACE_EVENT_FLOW_END2
+#pragma push_macro("TRACE_EVENT_COPY_FLOW_END0")
+#undef TRACE_EVENT_COPY_FLOW_END0
+#pragma push_macro("TRACE_EVENT_COPY_FLOW_END1")
+#undef TRACE_EVENT_COPY_FLOW_END1
+#pragma push_macro("TRACE_EVENT_COPY_FLOW_END2")
+#undef TRACE_EVENT_COPY_FLOW_END2
+#pragma push_macro("TRACE_TASK_EXECUTION")
+#undef TRACE_TASK_EXECUTION
+#pragma push_macro("TRACE_EVENT_METADATA1")
+#undef TRACE_EVENT_METADATA1
+#pragma push_macro("TRACE_EVENT_CLOCK_SYNC_RECEIVER")
+#undef TRACE_EVENT_CLOCK_SYNC_RECEIVER
+#pragma push_macro("TRACE_EVENT_CLOCK_SYNC_ISSUER")
+#undef TRACE_EVENT_CLOCK_SYNC_ISSUER
+#pragma push_macro("TRACE_EVENT_OBJECT_CREATED_WITH_ID")
+#undef TRACE_EVENT_OBJECT_CREATED_WITH_ID
+#pragma push_macro("TRACE_EVENT_OBJECT_SNAPSHOT_WITH_ID")
+#undef TRACE_EVENT_OBJECT_SNAPSHOT_WITH_ID
+#pragma push_macro("TRACE_EVENT_OBJECT_SNAPSHOT_WITH_ID_AND_TIMESTAMP")
+#undef TRACE_EVENT_OBJECT_SNAPSHOT_WITH_ID_AND_TIMESTAMP
+#pragma push_macro("TRACE_EVENT_OBJECT_DELETED_WITH_ID")
+#undef TRACE_EVENT_OBJECT_DELETED_WITH_ID
+#pragma push_macro("TRACE_EVENT_ENTER_CONTEXT")
+#undef TRACE_EVENT_ENTER_CONTEXT
+#pragma push_macro("TRACE_EVENT_LEAVE_CONTEXT")
+#undef TRACE_EVENT_LEAVE_CONTEXT
+#pragma push_macro("TRACE_EVENT_SCOPED_CONTEXT")
+#undef TRACE_EVENT_SCOPED_CONTEXT
+#pragma push_macro("TRACE_LINK_IDS")
+#undef TRACE_LINK_IDS
+#pragma push_macro("TRACE_EVENT_CATEGORY_GROUP_ENABLED")
+#undef TRACE_EVENT_CATEGORY_GROUP_ENABLED
+#pragma push_macro("TRACE_EVENT_WARMUP_CATEGORY")
+#undef TRACE_EVENT_WARMUP_CATEGORY
+#pragma push_macro("TRACE_EVENT_IS_NEW_TRACE")
+#undef TRACE_EVENT_IS_NEW_TRACE
+#pragma push_macro("TRACE_EVENT_PHASE_BEGIN")
+#undef TRACE_EVENT_PHASE_BEGIN
+#pragma push_macro("TRACE_EVENT_PHASE_END")
+#undef TRACE_EVENT_PHASE_END
+#pragma push_macro("TRACE_EVENT_PHASE_COMPLETE")
+#undef TRACE_EVENT_PHASE_COMPLETE
+#pragma push_macro("TRACE_EVENT_PHASE_INSTANT")
+#undef TRACE_EVENT_PHASE_INSTANT
+#pragma push_macro("TRACE_EVENT_PHASE_ASYNC_BEGIN")
+#undef TRACE_EVENT_PHASE_ASYNC_BEGIN
+#pragma push_macro("TRACE_EVENT_PHASE_ASYNC_STEP_INTO")
+#undef TRACE_EVENT_PHASE_ASYNC_STEP_INTO
+#pragma push_macro("TRACE_EVENT_PHASE_ASYNC_STEP_PAST")
+#undef TRACE_EVENT_PHASE_ASYNC_STEP_PAST
+#pragma push_macro("TRACE_EVENT_PHASE_ASYNC_END")
+#undef TRACE_EVENT_PHASE_ASYNC_END
+#pragma push_macro("TRACE_EVENT_PHASE_NESTABLE_ASYNC_BEGIN")
+#undef TRACE_EVENT_PHASE_NESTABLE_ASYNC_BEGIN
+#pragma push_macro("TRACE_EVENT_PHASE_NESTABLE_ASYNC_END")
+#undef TRACE_EVENT_PHASE_NESTABLE_ASYNC_END
+#pragma push_macro("TRACE_EVENT_PHASE_NESTABLE_ASYNC_INSTANT")
+#undef TRACE_EVENT_PHASE_NESTABLE_ASYNC_INSTANT
+#pragma push_macro("TRACE_EVENT_PHASE_FLOW_BEGIN")
+#undef TRACE_EVENT_PHASE_FLOW_BEGIN
+#pragma push_macro("TRACE_EVENT_PHASE_FLOW_STEP")
+#undef TRACE_EVENT_PHASE_FLOW_STEP
+#pragma push_macro("TRACE_EVENT_PHASE_FLOW_END")
+#undef TRACE_EVENT_PHASE_FLOW_END
+#pragma push_macro("TRACE_EVENT_PHASE_METADATA")
+#undef TRACE_EVENT_PHASE_METADATA
+#pragma push_macro("TRACE_EVENT_PHASE_COUNTER")
+#undef TRACE_EVENT_PHASE_COUNTER
+#pragma push_macro("TRACE_EVENT_PHASE_SAMPLE")
+#undef TRACE_EVENT_PHASE_SAMPLE
+#pragma push_macro("TRACE_EVENT_PHASE_CREATE_OBJECT")
+#undef TRACE_EVENT_PHASE_CREATE_OBJECT
+#pragma push_macro("TRACE_EVENT_PHASE_SNAPSHOT_OBJECT")
+#undef TRACE_EVENT_PHASE_SNAPSHOT_OBJECT
+#pragma push_macro("TRACE_EVENT_PHASE_DELETE_OBJECT")
+#undef TRACE_EVENT_PHASE_DELETE_OBJECT
+#pragma push_macro("TRACE_EVENT_PHASE_MEMORY_DUMP")
+#undef TRACE_EVENT_PHASE_MEMORY_DUMP
+#pragma push_macro("TRACE_EVENT_PHASE_MARK")
+#undef TRACE_EVENT_PHASE_MARK
+#pragma push_macro("TRACE_EVENT_PHASE_CLOCK_SYNC")
+#undef TRACE_EVENT_PHASE_CLOCK_SYNC
+#pragma push_macro("TRACE_EVENT_PHASE_ENTER_CONTEXT")
+#undef TRACE_EVENT_PHASE_ENTER_CONTEXT
+#pragma push_macro("TRACE_EVENT_PHASE_LEAVE_CONTEXT")
+#undef TRACE_EVENT_PHASE_LEAVE_CONTEXT
+#pragma push_macro("TRACE_EVENT_PHASE_LINK_IDS")
+#undef TRACE_EVENT_PHASE_LINK_IDS
+#pragma push_macro("TRACE_EVENT_FLAG_NONE")
+#undef TRACE_EVENT_FLAG_NONE
+#pragma push_macro("TRACE_EVENT_FLAG_COPY")
+#undef TRACE_EVENT_FLAG_COPY
+#pragma push_macro("TRACE_EVENT_FLAG_HAS_ID")
+#undef TRACE_EVENT_FLAG_HAS_ID
+#pragma push_macro("TRACE_EVENT_FLAG_MANGLE_ID")
+#undef TRACE_EVENT_FLAG_MANGLE_ID
+#pragma push_macro("TRACE_EVENT_FLAG_SCOPE_OFFSET")
+#undef TRACE_EVENT_FLAG_SCOPE_OFFSET
+#pragma push_macro("TRACE_EVENT_FLAG_SCOPE_EXTRA")
+#undef TRACE_EVENT_FLAG_SCOPE_EXTRA
+#pragma push_macro("TRACE_EVENT_FLAG_EXPLICIT_TIMESTAMP")
+#undef TRACE_EVENT_FLAG_EXPLICIT_TIMESTAMP
+#pragma push_macro("TRACE_EVENT_FLAG_ASYNC_TTS")
+#undef TRACE_EVENT_FLAG_ASYNC_TTS
+#pragma push_macro("TRACE_EVENT_FLAG_BIND_TO_ENCLOSING")
+#undef TRACE_EVENT_FLAG_BIND_TO_ENCLOSING
+#pragma push_macro("TRACE_EVENT_FLAG_FLOW_IN")
+#undef TRACE_EVENT_FLAG_FLOW_IN
+#pragma push_macro("TRACE_EVENT_FLAG_FLOW_OUT")
+#undef TRACE_EVENT_FLAG_FLOW_OUT
+#pragma push_macro("TRACE_EVENT_FLAG_HAS_CONTEXT_ID")
+#undef TRACE_EVENT_FLAG_HAS_CONTEXT_ID
+#pragma push_macro("TRACE_EVENT_FLAG_HAS_PROCESS_ID")
+#undef TRACE_EVENT_FLAG_HAS_PROCESS_ID
+#pragma push_macro("TRACE_EVENT_FLAG_HAS_LOCAL_ID")
+#undef TRACE_EVENT_FLAG_HAS_LOCAL_ID
+#pragma push_macro("TRACE_EVENT_FLAG_HAS_GLOBAL_ID")
+#undef TRACE_EVENT_FLAG_HAS_GLOBAL_ID
+#pragma push_macro("TRACE_EVENT_FLAG_SCOPE_MASK")
+#undef TRACE_EVENT_FLAG_SCOPE_MASK
+#pragma push_macro("TRACE_VALUE_TYPE_BOOL")
+#undef TRACE_VALUE_TYPE_BOOL
+#pragma push_macro("TRACE_VALUE_TYPE_UINT")
+#undef TRACE_VALUE_TYPE_UINT
+#pragma push_macro("TRACE_VALUE_TYPE_INT")
+#undef TRACE_VALUE_TYPE_INT
+#pragma push_macro("TRACE_VALUE_TYPE_DOUBLE")
+#undef TRACE_VALUE_TYPE_DOUBLE
+#pragma push_macro("TRACE_VALUE_TYPE_POINTER")
+#undef TRACE_VALUE_TYPE_POINTER
+#pragma push_macro("TRACE_VALUE_TYPE_STRING")
+#undef TRACE_VALUE_TYPE_STRING
+#pragma push_macro("TRACE_VALUE_TYPE_COPY_STRING")
+#undef TRACE_VALUE_TYPE_COPY_STRING
+#pragma push_macro("TRACE_VALUE_TYPE_CONVERTABLE")
+#undef TRACE_VALUE_TYPE_CONVERTABLE
+#pragma push_macro("TRACE_EVENT_SCOPE_GLOBAL")
+#undef TRACE_EVENT_SCOPE_GLOBAL
+#pragma push_macro("TRACE_EVENT_SCOPE_PROCESS")
+#undef TRACE_EVENT_SCOPE_PROCESS
+#pragma push_macro("TRACE_EVENT_SCOPE_THREAD")
+#undef TRACE_EVENT_SCOPE_THREAD
+#pragma push_macro("TRACE_EVENT_SCOPE_NAME_GLOBAL")
+#undef TRACE_EVENT_SCOPE_NAME_GLOBAL
+#pragma push_macro("TRACE_EVENT_SCOPE_NAME_PROCESS")
+#undef TRACE_EVENT_SCOPE_NAME_PROCESS
+#pragma push_macro("TRACE_EVENT_SCOPE_NAME_THREAD")
+#undef TRACE_EVENT_SCOPE_NAME_THREAD
+#pragma push_macro("SRC_TRACING_TRACE_EVENT_H_")
+#undef SRC_TRACING_TRACE_EVENT_H_
+#pragma push_macro("TRACE_STR_COPY")
+#undef TRACE_STR_COPY
+#pragma push_macro("TRACE_ID_MANGLE")
+#undef TRACE_ID_MANGLE
+#pragma push_macro("TRACE_ID_DONT_MANGLE")
+#undef TRACE_ID_DONT_MANGLE
+#pragma push_macro("TRACE_ID_WITH_SCOPE")
+#undef TRACE_ID_WITH_SCOPE
+#pragma push_macro("INTERNAL_TRACE_EVENT_CATEGORY_GROUP_ENABLED_FOR_RECORDING_MODE")
+#undef INTERNAL_TRACE_EVENT_CATEGORY_GROUP_ENABLED_FOR_RECORDING_MODE
+#pragma push_macro("INTERNAL_TRACE_MEMORY")
+#undef INTERNAL_TRACE_MEMORY
+#pragma push_macro("TRACE_EVENT_API_GET_CATEGORY_GROUP_ENABLED")
+#undef TRACE_EVENT_API_GET_CATEGORY_GROUP_ENABLED
+#pragma push_macro("TRACE_EVENT_API_GET_NUM_TRACES_RECORDED")
+#undef TRACE_EVENT_API_GET_NUM_TRACES_RECORDED
+#pragma push_macro("TRACE_EVENT_API_ADD_TRACE_EVENT")
+#undef TRACE_EVENT_API_ADD_TRACE_EVENT
+#pragma push_macro("TRACE_EVENT_API_ADD_TRACE_EVENT_WITH_TIMESTAMP")
+#undef TRACE_EVENT_API_ADD_TRACE_EVENT_WITH_TIMESTAMP
+#pragma push_macro("TRACE_EVENT_API_UPDATE_TRACE_EVENT_DURATION")
+#undef TRACE_EVENT_API_UPDATE_TRACE_EVENT_DURATION
+#pragma push_macro("TRACE_EVENT_API_ADD_METADATA_EVENT")
+#undef TRACE_EVENT_API_ADD_METADATA_EVENT
+#pragma push_macro("TRACE_EVENT_API_ATOMIC_WORD")
+#undef TRACE_EVENT_API_ATOMIC_WORD
+#pragma push_macro("TRACE_EVENT_API_ATOMIC_WORD_VALUE")
+#undef TRACE_EVENT_API_ATOMIC_WORD_VALUE
+#pragma push_macro("TRACE_EVENT_API_ATOMIC_LOAD")
+#undef TRACE_EVENT_API_ATOMIC_LOAD
+#pragma push_macro("TRACE_EVENT_API_ATOMIC_STORE")
+#undef TRACE_EVENT_API_ATOMIC_STORE
+#pragma push_macro("INTERNAL_TRACE_EVENT_UID3")
+#undef INTERNAL_TRACE_EVENT_UID3
+#pragma push_macro("INTERNAL_TRACE_EVENT_UID2")
+#undef INTERNAL_TRACE_EVENT_UID2
+#pragma push_macro("INTERNAL_TRACE_EVENT_UID")
+#undef INTERNAL_TRACE_EVENT_UID
+#pragma push_macro("INTERNAL_TRACE_EVENT_GET_CATEGORY_INFO_CUSTOM_VARIABLES")
+#undef INTERNAL_TRACE_EVENT_GET_CATEGORY_INFO_CUSTOM_VARIABLES
+#pragma push_macro("INTERNAL_TRACE_EVENT_GET_CATEGORY_INFO")
+#undef INTERNAL_TRACE_EVENT_GET_CATEGORY_INFO
+#pragma push_macro("INTERNAL_TRACE_EVENT_ADD")
+#undef INTERNAL_TRACE_EVENT_ADD
+#pragma push_macro("INTERNAL_TRACE_EVENT_ADD_SCOPED")
+#undef INTERNAL_TRACE_EVENT_ADD_SCOPED
+#pragma push_macro("INTERNAL_TRACE_EVENT_ADD_SCOPED_WITH_FLOW")
+#undef INTERNAL_TRACE_EVENT_ADD_SCOPED_WITH_FLOW
+#pragma push_macro("INTERNAL_TRACE_EVENT_ADD_WITH_ID")
+#undef INTERNAL_TRACE_EVENT_ADD_WITH_ID
+#pragma push_macro("INTERNAL_TRACE_EVENT_ADD_WITH_TIMESTAMP")
+#undef INTERNAL_TRACE_EVENT_ADD_WITH_TIMESTAMP
+#pragma push_macro("INTERNAL_TRACE_EVENT_ADD_WITH_ID_AND_TIMESTAMP")
+#undef INTERNAL_TRACE_EVENT_ADD_WITH_ID_AND_TIMESTAMP
+#pragma push_macro("INTERNAL_TRACE_EVENT_ADD_WITH_ID_TID_AND_TIMESTAMP")
+#undef INTERNAL_TRACE_EVENT_ADD_WITH_ID_TID_AND_TIMESTAMP
+#pragma push_macro("INTERNAL_TRACE_EVENT_METADATA_ADD")
+#undef INTERNAL_TRACE_EVENT_METADATA_ADD
+#pragma push_macro("INTERNAL_TRACE_EVENT_SCOPED_CONTEXT")
+#undef INTERNAL_TRACE_EVENT_SCOPED_CONTEXT
+#pragma push_macro("INTERNAL_DECLARE_SET_TRACE_VALUE")
+#undef INTERNAL_DECLARE_SET_TRACE_VALUE
+#pragma push_macro("INTERNAL_DECLARE_SET_TRACE_VALUE_INT")
+#undef INTERNAL_DECLARE_SET_TRACE_VALUE_INT
+#pragma push_macro("SRC_UTIL_H_")
+#undef SRC_UTIL_H_
+#pragma push_macro("MUST_USE_RESULT")
+#undef MUST_USE_RESULT
+#pragma push_macro("MUST_USE_RESULT")
+#undef MUST_USE_RESULT
+#pragma push_macro("PATH_MAX_BYTES")
+#undef PATH_MAX_BYTES
+#pragma push_macro("PATH_MAX_BYTES")
+#undef PATH_MAX_BYTES
+#pragma push_macro("ABORT_NO_BACKTRACE")
+#undef ABORT_NO_BACKTRACE
+#pragma push_macro("ABORT_NO_BACKTRACE")
+#undef ABORT_NO_BACKTRACE
+#pragma push_macro("ABORT")
+#undef ABORT
+#pragma push_macro("ERROR_AND_ABORT")
+#undef ERROR_AND_ABORT
+#pragma push_macro("LIKELY")
+#undef LIKELY
+#pragma push_macro("UNLIKELY")
+#undef UNLIKELY
+#pragma push_macro("PRETTY_FUNCTION_NAME")
+#undef PRETTY_FUNCTION_NAME
+#pragma push_macro("LIKELY")
+#undef LIKELY
+#pragma push_macro("UNLIKELY")
+#undef UNLIKELY
+#pragma push_macro("PRETTY_FUNCTION_NAME")
+#undef PRETTY_FUNCTION_NAME
+#pragma push_macro("STRINGIFY_")
+#undef STRINGIFY_
+#pragma push_macro("STRINGIFY")
+#undef STRINGIFY
+#pragma push_macro("CHECK")
+#undef CHECK
+#pragma push_macro("CHECK_EQ")
+#undef CHECK_EQ
+#pragma push_macro("CHECK_GE")
+#undef CHECK_GE
+#pragma push_macro("CHECK_GT")
+#undef CHECK_GT
+#pragma push_macro("CHECK_LE")
+#undef CHECK_LE
+#pragma push_macro("CHECK_LT")
+#undef CHECK_LT
+#pragma push_macro("CHECK_NE")
+#undef CHECK_NE
+#pragma push_macro("CHECK_NULL")
+#undef CHECK_NULL
+#pragma push_macro("CHECK_NOT_NULL")
+#undef CHECK_NOT_NULL
+#pragma push_macro("CHECK_IMPLIES")
+#undef CHECK_IMPLIES
+#pragma push_macro("DCHECK")
+#undef DCHECK
+#pragma push_macro("DCHECK_EQ")
+#undef DCHECK_EQ
+#pragma push_macro("DCHECK_GE")
+#undef DCHECK_GE
+#pragma push_macro("DCHECK_GT")
+#undef DCHECK_GT
+#pragma push_macro("DCHECK_LE")
+#undef DCHECK_LE
+#pragma push_macro("DCHECK_LT")
+#undef DCHECK_LT
+#pragma push_macro("DCHECK_NE")
+#undef DCHECK_NE
+#pragma push_macro("DCHECK_NULL")
+#undef DCHECK_NULL
+#pragma push_macro("DCHECK_NOT_NULL")
+#undef DCHECK_NOT_NULL
+#pragma push_macro("DCHECK_IMPLIES")
+#undef DCHECK_IMPLIES
+#pragma push_macro("DCHECK")
+#undef DCHECK
+#pragma push_macro("DCHECK_EQ")
+#undef DCHECK_EQ
+#pragma push_macro("DCHECK_GE")
+#undef DCHECK_GE
+#pragma push_macro("DCHECK_GT")
+#undef DCHECK_GT
+#pragma push_macro("DCHECK_LE")
+#undef DCHECK_LE
+#pragma push_macro("DCHECK_LT")
+#undef DCHECK_LT
+#pragma push_macro("DCHECK_NE")
+#undef DCHECK_NE
+#pragma push_macro("DCHECK_NULL")
+#undef DCHECK_NULL
+#pragma push_macro("DCHECK_NOT_NULL")
+#undef DCHECK_NOT_NULL
+#pragma push_macro("DCHECK_IMPLIES")
+#undef DCHECK_IMPLIES
+#pragma push_macro("UNREACHABLE")
+#undef UNREACHABLE
+#pragma push_macro("SPREAD_BUFFER_ARG")
+#undef SPREAD_BUFFER_ARG
+#pragma push_macro("READONLY_PROPERTY")
+#undef READONLY_PROPERTY
+#pragma push_macro("READONLY_DONT_ENUM_PROPERTY")
+#undef READONLY_DONT_ENUM_PROPERTY
+#pragma push_macro("READONLY_FALSE_PROPERTY")
+#undef READONLY_FALSE_PROPERTY
+#pragma push_macro("READONLY_TRUE_PROPERTY")
+#undef READONLY_TRUE_PROPERTY
+#pragma push_macro("READONLY_STRING_PROPERTY")
+#undef READONLY_STRING_PROPERTY
+#pragma push_macro("NODE_DEFINE_STRING_CONSTANT")
+#undef NODE_DEFINE_STRING_CONSTANT
+#pragma push_macro("MAYBE_FIELD_PTR")
+#undef MAYBE_FIELD_PTR
diff --git a/libcef/renderer/embed/node_bindings.cc b/libcef/renderer/embed/node_bindings.cc
new file mode 100644
index 000000000..c249525b4
--- /dev/null
+++ b/libcef/renderer/embed/node_bindings.cc
@@ -0,0 +1,459 @@
+// Copyright (c) 2013 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#include "node_bindings.h"
+
+#include <algorithm>
+#include <memory>
+#include <set>
+#include <string>
+#include <unordered_set>
+#include <utility>
+#include <vector>
+
+#include "base/base_paths.h"
+#include "base/command_line.h"
+#include "base/environment.h"
+#include "base/path_service.h"
+#include "base/run_loop.h"
+#include "base/strings/string_split.h"
+#include "base/strings/utf_string_conversions.h"
+#include "base/task/single_thread_task_runner.h"
+#include "base/threading/thread_task_runner_handle.h"
+#include "base/trace_event/trace_event.h"
+#include "content/public/browser/browser_thread.h"
+#include "content/public/common/content_paths.h"
+//#include "electron/buildflags/buildflags.h"
+//#include "electron/fuses.h"
+//#include "shell/browser/api/electron_api_app.h"
+//#include "shell/common/api/electron_bindings.h"
+//#include "shell/common/electron_command_line.h"
+//#include "shell/common/gin_converters/file_path_converter.h"
+#include "shell/common/gin_helper/dictionary.h"
+#include "shell/common/gin_helper/event_emitter_caller.h"
+#include "shell/common/gin_helper/locker.h"
+//#include "shell/common/gin_helper/microtasks_scope.h"
+//#include "shell/common/mac/main_application_bundle.h"
+#include "node_includes.h"
+#include "third_party/blink/renderer/bindings/core/v8/v8_initializer.h"  // nogncheck
+
+#if !defined(MAS_BUILD)
+//#include "shell/common/crash_keys.h"
+#endif
+
+namespace {
+
+void stop_and_close_uv_loop(uv_loop_t* loop) {
+  uv_stop(loop);
+
+  auto const ensure_closing = [](uv_handle_t* handle, void*) {
+    // We should be using the UvHandle wrapper everywhere, in which case
+    // all handles should already be in a closing state...
+    DCHECK(uv_is_closing(handle));
+    // ...but if a raw handle got through, through, do the right thing anyway
+    if (!uv_is_closing(handle)) {
+      uv_close(handle, nullptr);
+    }
+  };
+
+  uv_walk(loop, ensure_closing, nullptr);
+
+  // All remaining handles are in a closing state now.
+  // Pump the event loop so that they can finish closing.
+  for (;;)
+    if (uv_run(loop, UV_RUN_DEFAULT) == 0)
+      break;
+
+  DCHECK_EQ(0, uv_loop_alive(loop));
+}
+
+bool g_is_initialized = false;
+
+void V8FatalErrorCallback(const char* location, const char* message) {
+  volatile int* zero = nullptr;
+  *zero = 0;
+}
+
+bool AllowWasmCodeGenerationCallback(v8::Local<v8::Context> context,
+                                     v8::Local<v8::String>) {
+  // If we're running with contextIsolation enabled in the renderer process,
+  // fall back to Blink's logic.
+  v8::Isolate* isolate = context->GetIsolate();
+  if (node::Environment::GetCurrent(isolate) == nullptr) {
+    if (gin_helper::Locker::IsBrowserProcess())
+      return false;
+    return blink::V8Initializer::WasmCodeGenerationCheckCallbackInMainThread(
+        context, v8::String::Empty(isolate));
+  }
+
+  return node::AllowWasmCodeGenerationCallback(context,
+                                               v8::String::Empty(isolate));
+}
+
+void ErrorMessageListener(v8::Local<v8::Message> message,
+                          v8::Local<v8::Value> data) {
+  v8::Isolate* isolate = v8::Isolate::GetCurrent();
+  gin_helper::MicrotasksScope microtasks_scope(
+      isolate, v8::MicrotasksScope::kDoNotRunMicrotasks);
+  node::Environment* env = node::Environment::GetCurrent(isolate);
+
+  if (env) {
+    // Emit the after() hooks now that the exception has been handled.
+    // Analogous to node/lib/internal/process/execution.js#L176-L180
+    if (env->async_hooks()->fields()[node::AsyncHooks::kAfter]) {
+      while (env->async_hooks()->fields()[node::AsyncHooks::kStackLength]) {
+        node::AsyncWrap::EmitAfter(env, env->execution_async_id());
+        env->async_hooks()->pop_async_context(env->execution_async_id());
+      }
+    }
+
+    // Ensure that the async id stack is properly cleared so the async
+    // hook stack does not become corrupted.
+    env->async_hooks()->clear_async_id_stack();
+  }
+}
+
+}  // namespace
+
+namespace electron {
+
+namespace {
+
+base::FilePath GetResourcesPath() {
+#if defined(OS_MAC)
+  return MainApplicationBundlePath().Append("Contents").Append("Resources");
+#else
+  auto* command_line = base::CommandLine::ForCurrentProcess();
+  base::FilePath exec_path(command_line->GetProgram());
+  base::PathService::Get(base::FILE_EXE, &exec_path);
+
+  return exec_path.DirName().Append(FILE_PATH_LITERAL("resources"));
+#endif
+}
+
+}  // namespace
+
+NodeBindings::NodeBindings(BrowserEnvironment browser_env)
+    : browser_env_(browser_env) {
+  if (browser_env == BrowserEnvironment::kWorker) {
+    uv_loop_init(&worker_loop_);
+    uv_loop_ = &worker_loop_;
+  } else {
+    uv_loop_ = uv_default_loop();
+  }
+}
+
+NodeBindings::~NodeBindings() {
+  // Quit the embed thread.
+  embed_closed_ = true;
+  uv_sem_post(&embed_sem_);
+
+  WakeupEmbedThread();
+
+  // Wait for everything to be done.
+  uv_thread_join(&embed_thread_);
+
+  // Clear uv.
+  uv_sem_destroy(&embed_sem_);
+  dummy_uv_handle_.reset();
+
+  // Clean up worker loop
+  if (in_worker_loop())
+    stop_and_close_uv_loop(uv_loop_);
+}
+
+void NodeBindings::RegisterBuiltinModules() {
+
+}
+
+bool NodeBindings::IsInitialized() {
+  return g_is_initialized;
+}
+
+void NodeBindings::Initialize() {
+  // TRACE_EVENT0("electron", "NodeBindings::Initialize");
+  // Open node's error reporting system for browser process.
+  // node::g_upstream_node_mode = false;
+
+#if defined(OS_LINUX)
+  // Get real command line in renderer process forked by zygote.
+  if (browser_env_ != BrowserEnvironment::kBrowser)
+    ElectronCommandLine::InitializeFromCommandLine();
+#endif
+
+  // Explicitly register electron's builtin modules.
+  // RegisterBuiltinModules();
+
+  auto env = base::Environment::Create();
+
+  std::vector<std::string> argv = {"electron"};
+  std::vector<std::string> exec_argv;
+  std::vector<std::string> errors;
+
+  int exit_code = node::InitializeNodeWithArgs(&argv, &exec_argv, &errors);
+
+  for (const std::string& error : errors)
+    fprintf(stderr, "%s: %s\n", argv[0].c_str(), error.c_str());
+
+  if (exit_code != 0)
+    exit(exit_code);
+
+#if defined(OS_WIN)
+  // uv_init overrides error mode to suppress the default crash dialog, bring
+  // it back if user wants to show it.
+  if (browser_env_ == BrowserEnvironment::kBrowser ||
+      env->HasVar("ELECTRON_DEFAULT_ERROR_MODE"))
+    SetErrorMode(GetErrorMode() & ~SEM_NOGPFAULTERRORBOX);
+#endif
+
+  g_is_initialized = true;
+}
+
+node::Environment* NodeBindings::CreateEnvironment(
+    v8::Handle<v8::Context> context,
+    node::MultiIsolatePlatform* platform) {
+  // Feed node the path to initialization script.
+  std::string process_type;
+  switch (browser_env_) {
+    case BrowserEnvironment::kBrowser:
+      process_type = "browser";
+      break;
+    case BrowserEnvironment::kRenderer:
+      process_type = "renderer";
+      break;
+    case BrowserEnvironment::kWorker:
+      process_type = "worker";
+      break;
+  }
+
+  v8::Isolate* isolate = context->GetIsolate();
+  gin_helper::Dictionary global(isolate, context->Global());
+  // Do not set DOM globals for renderer process.
+  // We must set this before the node bootstrapper which is run inside
+  // CreateEnvironment
+  if (browser_env_ != BrowserEnvironment::kBrowser)
+    global.Set("_noBrowserGlobals", true);
+
+  if (browser_env_ == BrowserEnvironment::kBrowser) {
+    CHECK(false);
+  }
+
+  std::vector<std::string> exec_args;
+  base::FilePath resources_path = GetResourcesPath();
+  std::vector<std::string> args;
+  args.emplace_back("electron");
+
+  isolate_data_ =
+      node::CreateIsolateData(context->GetIsolate(), uv_loop_, platform);
+
+  node::Environment* env;
+  uint64_t flags = node::EnvironmentFlags::kDefaultFlags |
+                   node::EnvironmentFlags::kHideConsoleWindows |
+                   node::EnvironmentFlags::kNoGlobalSearchPaths;
+
+  if (browser_env_ != BrowserEnvironment::kBrowser) {
+    // Only one ESM loader can be registered per isolate -
+    // in renderer processes this should be blink. We need to tell Node.js
+    // not to register its handler (overriding blinks) in non-browser processes.
+    flags |= node::EnvironmentFlags::kNoRegisterESMLoader;
+    v8::TryCatch try_catch(context->GetIsolate());
+    env = node::CreateEnvironment(
+        isolate_data_, context, args, exec_args,
+        static_cast<node::EnvironmentFlags::Flags>(flags));
+    DCHECK(env);
+
+    // This will only be caught when something has gone terrible wrong as all
+    // electron scripts are wrapped in a try {} catch {} by webpack
+    if (try_catch.HasCaught()) {
+      CHECK(false) << "Failed to initialize node environment in process: "
+                 << process_type;
+    }
+  } else {
+    env = node::CreateEnvironment(
+        isolate_data_, context, args, exec_args,
+        static_cast<node::EnvironmentFlags::Flags>(flags));
+    DCHECK(env);
+  }
+
+  // Clean up the global _noBrowserGlobals that we unironically injected into
+  // the global scope
+  if (browser_env_ != BrowserEnvironment::kBrowser) {
+    // We need to bootstrap the env in non-browser processes so that
+    // _noBrowserGlobals is read correctly before we remove it
+    global.Delete("_noBrowserGlobals");
+  }
+
+  node::IsolateSettings is;
+
+  // Use a custom fatal error callback to allow us to add
+  // crash message and location to CrashReports.
+  is.fatal_error_callback = V8FatalErrorCallback;
+
+  // We don't want to abort either in the renderer or browser processes.
+  // We already listen for uncaught exceptions and handle them there.
+  is.should_abort_on_uncaught_exception_callback = [](v8::Isolate*) {
+    return false;
+  };
+
+  // Use a custom callback here to allow us to leverage Blink's logic in the
+  // renderer process.
+  is.allow_wasm_code_generation_callback = AllowWasmCodeGenerationCallback;
+
+  if (browser_env_ == BrowserEnvironment::kBrowser) {
+    // Node.js requires that microtask checkpoints be explicitly invoked.
+    is.policy = v8::MicrotasksPolicy::kExplicit;
+  } else {
+    // Blink expects the microtasks policy to be kScoped, but Node.js expects it
+    // to be kExplicit. In the renderer, there can be many contexts within the
+    // same isolate, so we don't want to change the existing policy here, which
+    // could be either kExplicit or kScoped depending on whether we're executing
+    // from within a Node.js or a Blink entrypoint. Instead, the policy is
+    // toggled to kExplicit when entering Node.js through UvRunOnce.
+    is.policy = context->GetIsolate()->GetMicrotasksPolicy();
+
+    // We do not want to use Node.js' message listener as it interferes with
+    // Blink's.
+    is.flags &= ~node::IsolateSettingsFlags::MESSAGE_LISTENER_WITH_ERROR_LEVEL;
+
+    // Isolate message listeners are additive (you can add multiple), so instead
+    // we add an extra one here to ensure that the async hook stack is properly
+    // cleared when errors are thrown.
+    context->GetIsolate()->AddMessageListenerWithErrorLevel(
+        ErrorMessageListener, v8::Isolate::kMessageError);
+
+    // We do not want to use the promise rejection callback that Node.js uses,
+    // because it does not send PromiseRejectionEvents to the global script
+    // context. We need to use the one Blink already provides.
+    is.flags |=
+        node::IsolateSettingsFlags::SHOULD_NOT_SET_PROMISE_REJECTION_CALLBACK;
+
+    // We do not want to use the stack trace callback that Node.js uses,
+    // because it relies on Node.js being aware of the current Context and
+    // that's not always the case. We need to use the one Blink already
+    // provides.
+    is.flags |=
+        node::IsolateSettingsFlags::SHOULD_NOT_SET_PREPARE_STACK_TRACE_CALLBACK;
+  }
+
+  node::SetIsolateUpForNode(context->GetIsolate(), is);
+  
+  // If we have disabled the site instance overrides we should prevent loading
+  // any non-context aware native module.
+  env->options()->force_context_aware = true;
+
+  // We do not want to crash the renderer process on unhandled rejections.
+  env->options()->unhandled_rejections = "warn";
+  return env;
+}
+
+void NodeBindings::LoadEnvironment(node::Environment* env) {
+  node::LoadEnvironment(env, node::StartExecutionCallback{});
+  gin_helper::EmitEvent(env->isolate(), env->process_object(), "loaded");
+}
+
+void NodeBindings::PrepareMessageLoop() {
+#if !defined(OS_WIN)
+  int handle = uv_backend_fd(uv_loop_);
+
+  // If the backend fd hasn't changed, don't proceed.
+  if (handle == handle_)
+    return;
+
+  handle_ = handle;
+#endif
+
+  // Add dummy handle for libuv, otherwise libuv would quit when there is
+  // nothing to do.
+  uv_async_init(uv_loop_, dummy_uv_handle_.get(), nullptr);
+
+  // Start worker that will interrupt main loop when having uv events.
+  uv_sem_init(&embed_sem_, 0);
+  uv_thread_create(&embed_thread_, EmbedThreadRunner, this);
+}
+
+void NodeBindings::RunMessageLoop() {
+  // The MessageLoop should have been created, remember the one in main thread.
+  task_runner_ = base::ThreadTaskRunnerHandle::Get();
+
+  // Run uv loop for once to give the uv__io_poll a chance to add all events.
+  UvRunOnce();
+}
+
+void NodeBindings::UvRunOnce() {
+  node::Environment* env = uv_env();
+
+  // When doing navigation without restarting renderer process, it may happen
+  // that the node environment is destroyed but the message loop is still there.
+  // In this case we should not run uv loop.
+  if (!env)
+    return;
+
+  // Use Locker in browser process.
+  gin_helper::Locker locker(env->isolate());
+  v8::HandleScope handle_scope(env->isolate());
+
+  // Enter node context while dealing with uv events.
+  v8::Context::Scope context_scope(env->context());
+
+  // Node.js expects `kExplicit` microtasks policy and will run microtasks
+  // checkpoints after every call into JavaScript. Since we use a different
+  // policy in the renderer - switch to `kExplicit` and then drop back to the
+  // previous policy value.
+  auto old_policy = env->isolate()->GetMicrotasksPolicy();
+  DCHECK_EQ(v8::MicrotasksScope::GetCurrentDepth(env->isolate()), 0);
+  env->isolate()->SetMicrotasksPolicy(v8::MicrotasksPolicy::kExplicit);
+
+  if (browser_env_ != BrowserEnvironment::kBrowser)
+    TRACE_EVENT_BEGIN0("devtools.timeline", "FunctionCall");
+
+  // Deal with uv events.
+  int r = uv_run(uv_loop_, UV_RUN_NOWAIT);
+
+  if (browser_env_ != BrowserEnvironment::kBrowser)
+    TRACE_EVENT_END0("devtools.timeline", "FunctionCall");
+
+  env->isolate()->SetMicrotasksPolicy(old_policy);
+
+  if (r == 0)
+    base::RunLoop().QuitWhenIdle();  // Quit from uv.
+
+  // Tell the worker thread to continue polling.
+  uv_sem_post(&embed_sem_);
+}
+
+void NodeBindings::WakeupMainThread() {
+  DCHECK(task_runner_);
+  task_runner_->PostTask(FROM_HERE, base::BindOnce(&NodeBindings::UvRunOnce,
+                                                   weak_factory_.GetWeakPtr()));
+}
+
+void NodeBindings::WakeupEmbedThread() {
+  uv_async_send(dummy_uv_handle_.get());
+}
+
+// static
+void NodeBindings::EmbedThreadRunner(void* arg) {
+  auto* self = static_cast<NodeBindings*>(arg);
+
+  while (true) {
+    // Wait for the main loop to deal with events.
+    uv_sem_wait(&self->embed_sem_);
+    if (self->embed_closed_)
+      break;
+
+    // Wait for something to happen in uv loop.
+    // Note that the PollEvents() is implemented by derived classes, so when
+    // this class is being destructed the PollEvents() would not be available
+    // anymore. Because of it we must make sure we only invoke PollEvents()
+    // when this class is alive.
+    self->PollEvents();
+    if (self->embed_closed_)
+      break;
+
+    // Deal with event in main thread.
+    self->WakeupMainThread();
+  }
+}
+
+}  // namespace electron
diff --git a/libcef/renderer/embed/node_bindings.h b/libcef/renderer/embed/node_bindings.h
new file mode 100644
index 000000000..9789d0b68
--- /dev/null
+++ b/libcef/renderer/embed/node_bindings.h
@@ -0,0 +1,173 @@
+// Copyright (c) 2013 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#ifndef ELECTRON_SHELL_COMMON_NODE_BINDINGS_H_
+#define ELECTRON_SHELL_COMMON_NODE_BINDINGS_H_
+
+#include <type_traits>
+
+#include "base/files/file_path.h"
+#include "base/memory/weak_ptr.h"
+#include "uv.h"  // NOLINT(build/include_directory)
+#include "v8/include/v8.h"
+
+namespace base {
+class SingleThreadTaskRunner;
+}
+
+namespace node {
+class Environment;
+class MultiIsolatePlatform;
+class IsolateData;
+}  // namespace node
+
+namespace electron {
+
+// A helper class to manage uv_handle_t types, e.g. uv_async_t.
+//
+// As per the uv docs: "uv_close() MUST be called on each handle before
+// memory is released. Moreover, the memory can only be released in
+// close_cb or after it has returned." This class encapsulates the work
+// needed to follow those requirements.
+template <typename T,
+          typename std::enable_if<
+              // these are the C-style 'subclasses' of uv_handle_t
+              std::is_same<T, uv_async_t>::value ||
+              std::is_same<T, uv_check_t>::value ||
+              std::is_same<T, uv_fs_event_t>::value ||
+              std::is_same<T, uv_fs_poll_t>::value ||
+              std::is_same<T, uv_idle_t>::value ||
+              std::is_same<T, uv_pipe_t>::value ||
+              std::is_same<T, uv_poll_t>::value ||
+              std::is_same<T, uv_prepare_t>::value ||
+              std::is_same<T, uv_process_t>::value ||
+              std::is_same<T, uv_signal_t>::value ||
+              std::is_same<T, uv_stream_t>::value ||
+              std::is_same<T, uv_tcp_t>::value ||
+              std::is_same<T, uv_timer_t>::value ||
+              std::is_same<T, uv_tty_t>::value ||
+              std::is_same<T, uv_udp_t>::value>::type* = nullptr>
+class UvHandle {
+ public:
+  UvHandle() : t_(new T) {}
+  ~UvHandle() { reset(); }
+  T* get() { return t_; }
+  uv_handle_t* handle() { return reinterpret_cast<uv_handle_t*>(t_); }
+
+  void reset() {
+    auto* h = handle();
+    if (h != nullptr) {
+      DCHECK_EQ(0, uv_is_closing(h));
+      uv_close(h, OnClosed);
+      t_ = nullptr;
+    }
+  }
+
+ private:
+  static void OnClosed(uv_handle_t* handle) {
+    delete reinterpret_cast<T*>(handle);
+  }
+
+  T* t_ = {};
+};
+
+class NodeBindings {
+ public:
+  enum class BrowserEnvironment { kBrowser, kRenderer, kWorker };
+
+  static NodeBindings* Create(BrowserEnvironment browser_env);
+  static void RegisterBuiltinModules();
+  static bool IsInitialized();
+
+  virtual ~NodeBindings();
+
+  // Setup V8, libuv.
+  void Initialize();
+
+  // Create the environment and load node.js.
+  node::Environment* CreateEnvironment(v8::Handle<v8::Context> context,
+                                       node::MultiIsolatePlatform* platform);
+
+  // Load node.js in the environment.
+  void LoadEnvironment(node::Environment* env);
+
+  // Prepare for message loop integration.
+  void PrepareMessageLoop();
+
+  // Do message loop integration.
+  virtual void RunMessageLoop();
+
+  node::IsolateData* isolate_data() const { return isolate_data_; }
+
+  // Gets/sets the environment to wrap uv loop.
+  void set_uv_env(node::Environment* env) { uv_env_ = env; }
+  node::Environment* uv_env() const { return uv_env_; }
+
+  uv_loop_t* uv_loop() const { return uv_loop_; }
+
+  bool in_worker_loop() const { return uv_loop_ == &worker_loop_; }
+
+  // disable copy
+  NodeBindings(const NodeBindings&) = delete;
+  NodeBindings& operator=(const NodeBindings&) = delete;
+
+ protected:
+  explicit NodeBindings(BrowserEnvironment browser_env);
+
+  // Called to poll events in new thread.
+  virtual void PollEvents() = 0;
+
+  // Run the libuv loop for once.
+  void UvRunOnce();
+
+  // Make the main thread run libuv loop.
+  void WakeupMainThread();
+
+  // Interrupt the PollEvents.
+  void WakeupEmbedThread();
+
+  // Which environment we are running.
+  const BrowserEnvironment browser_env_;
+
+  // Current thread's MessageLoop.
+  scoped_refptr<base::SingleThreadTaskRunner> task_runner_;
+
+  // Current thread's libuv loop.
+  uv_loop_t* uv_loop_;
+
+ private:
+  // Thread to poll uv events.
+  static void EmbedThreadRunner(void* arg);
+
+  // Whether the libuv loop has ended.
+  bool embed_closed_ = false;
+
+  // Loop used when constructed in WORKER mode
+  uv_loop_t worker_loop_;
+
+  // Dummy handle to make uv's loop not quit.
+  UvHandle<uv_async_t> dummy_uv_handle_;
+
+  // Thread for polling events.
+  uv_thread_t embed_thread_;
+
+  // Semaphore to wait for main loop in the embed thread.
+  uv_sem_t embed_sem_;
+
+  // Environment that to wrap the uv loop.
+  node::Environment* uv_env_ = nullptr;
+
+  // Isolate data used in creating the environment
+  node::IsolateData* isolate_data_ = nullptr;
+
+#if !defined(OS_WIN)
+  int handle_ = -1;
+#endif
+
+  base::WeakPtrFactory<NodeBindings> weak_factory_{this};
+};
+
+}  // namespace electron
+
+#endif  // ELECTRON_SHELL_COMMON_NODE_BINDINGS_H_
diff --git a/libcef/renderer/embed/node_bindings_win.cc b/libcef/renderer/embed/node_bindings_win.cc
new file mode 100644
index 000000000..b23ef8e0a
--- /dev/null
+++ b/libcef/renderer/embed/node_bindings_win.cc
@@ -0,0 +1,53 @@
+// Copyright (c) 2013 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#include "node_bindings_win.h"
+
+#include <windows.h>
+
+#include "base/logging.h"
+#include "base/system/sys_info.h"
+
+namespace electron {
+
+NodeBindingsWin::NodeBindingsWin(BrowserEnvironment browser_env)
+    : NodeBindings(browser_env) {
+  // on single-core the io comp port NumberOfConcurrentThreads needs to be 2
+  // to avoid cpu pegging likely caused by a busy loop in PollEvents
+  if (base::SysInfo::NumberOfProcessors() == 1) {
+    // the expectation is the uv_loop_ has just been initialized
+    // which makes iocp replacement safe
+    CHECK_EQ(0u, uv_loop_->active_handles);
+    CHECK_EQ(0u, uv_loop_->active_reqs.count);
+
+    if (uv_loop_->iocp && uv_loop_->iocp != INVALID_HANDLE_VALUE)
+      CloseHandle(uv_loop_->iocp);
+    uv_loop_->iocp = CreateIoCompletionPort(INVALID_HANDLE_VALUE, NULL, 0, 2);
+  }
+}
+
+NodeBindingsWin::~NodeBindingsWin() = default;
+
+void NodeBindingsWin::PollEvents() {
+  // If there are other kinds of events pending, uv_backend_timeout will
+  // instruct us not to wait.
+  DWORD bytes, timeout;
+  ULONG_PTR key;
+  OVERLAPPED* overlapped;
+
+  timeout = uv_backend_timeout(uv_loop_);
+
+  GetQueuedCompletionStatus(uv_loop_->iocp, &bytes, &key, &overlapped, timeout);
+
+  // Give the event back so libuv can deal with it.
+  if (overlapped != NULL)
+    PostQueuedCompletionStatus(uv_loop_->iocp, bytes, key, overlapped);
+}
+
+// static
+NodeBindings* NodeBindings::Create(BrowserEnvironment browser_env) {
+  return new NodeBindingsWin(browser_env);
+}
+
+}  // namespace electron
diff --git a/libcef/renderer/embed/node_bindings_win.h b/libcef/renderer/embed/node_bindings_win.h
new file mode 100644
index 000000000..116571f43
--- /dev/null
+++ b/libcef/renderer/embed/node_bindings_win.h
@@ -0,0 +1,24 @@
+// Copyright (c) 2013 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#ifndef ELECTRON_SHELL_COMMON_NODE_BINDINGS_WIN_H_
+#define ELECTRON_SHELL_COMMON_NODE_BINDINGS_WIN_H_
+
+#include "base/compiler_specific.h"
+#include "node_bindings.h"
+
+namespace electron {
+
+class NodeBindingsWin : public NodeBindings {
+ public:
+  explicit NodeBindingsWin(BrowserEnvironment browser_env);
+  ~NodeBindingsWin() override;
+
+ private:
+  void PollEvents() override;
+};
+
+}  // namespace electron
+
+#endif  // ELECTRON_SHELL_COMMON_NODE_BINDINGS_WIN_H_
diff --git a/libcef/renderer/embed/node_includes.h b/libcef/renderer/embed/node_includes.h
new file mode 100644
index 000000000..f4f026df6
--- /dev/null
+++ b/libcef/renderer/embed/node_includes.h
@@ -0,0 +1,39 @@
+// Copyright (c) 2013 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#ifndef ELECTRON_SHELL_COMMON_NODE_INCLUDES_H_
+#define ELECTRON_SHELL_COMMON_NODE_INCLUDES_H_
+
+// Include common headers for using node APIs.
+
+#ifdef NODE_SHARED_MODE
+#define BUILDING_NODE_EXTENSION
+#endif
+
+#undef debug_string    // This is defined in macOS SDK in AssertMacros.h.
+#undef require_string  // This is defined in macOS SDK in AssertMacros.h.
+
+#include "electron/push_and_undef_node_defines.h"
+
+#include "env-inl.h"
+#include "env.h"
+#include "node.h"
+#include "node_buffer.h"
+#include "node_errors.h"
+#include "node_internals.h"
+#include "node_native_module_env.h"
+#include "node_options-inl.h"
+#include "node_options.h"
+#include "node_platform.h"
+#include "tracing/agent.h"
+
+#include "electron/pop_node_defines.h"
+
+// Alternative to NODE_MODULE_CONTEXT_AWARE_X.
+// Allows to explicitly register builtin modules instead of using
+// __attribute__((constructor)).
+#define NODE_LINKED_MODULE_CONTEXT_AWARE(modname, regfunc) \
+  NODE_MODULE_CONTEXT_AWARE_CPP(modname, regfunc, nullptr, NM_F_LINKED)
+
+#endif  // ELECTRON_SHELL_COMMON_NODE_INCLUDES_H_
diff --git a/libcef/renderer/embed/node_util.cc b/libcef/renderer/embed/node_util.cc
new file mode 100644
index 000000000..1bcb6446d
--- /dev/null
+++ b/libcef/renderer/embed/node_util.cc
@@ -0,0 +1,41 @@
+// Copyright (c) 2019 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#include "node_util.h"
+
+#include "base/logging.h"
+#include "node_includes.h"
+
+namespace electron {
+
+namespace util {
+
+v8::MaybeLocal<v8::Value> CompileAndCall(
+    v8::Local<v8::Context> context,
+    const char* id,
+    std::vector<v8::Local<v8::String>>* parameters,
+    std::vector<v8::Local<v8::Value>>* arguments,
+    node::Environment* optional_env) {
+  v8::Isolate* isolate = context->GetIsolate();
+  v8::TryCatch try_catch(isolate);
+  v8::MaybeLocal<v8::Function> compiled =
+      node::native_module::NativeModuleEnv::LookupAndCompile(
+          context, id, parameters, optional_env);
+  if (compiled.IsEmpty()) {
+    return v8::MaybeLocal<v8::Value>();
+  }
+  v8::Local<v8::Function> fn = compiled.ToLocalChecked().As<v8::Function>();
+  v8::MaybeLocal<v8::Value> ret = fn->Call(
+      context, v8::Null(isolate), arguments->size(), arguments->data());
+  // This will only be caught when something has gone terrible wrong as all
+  // electron scripts are wrapped in a try {} catch {} by webpack
+  if (try_catch.HasCaught()) {
+    LOG(ERROR) << "Failed to CompileAndCall electron script: " << id;
+  }
+  return ret;
+}
+
+}  // namespace util
+
+}  // namespace electron
diff --git a/libcef/renderer/embed/node_util.h b/libcef/renderer/embed/node_util.h
new file mode 100644
index 000000000..fd7db87a4
--- /dev/null
+++ b/libcef/renderer/embed/node_util.h
@@ -0,0 +1,36 @@
+// Copyright (c) 2019 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#ifndef ELECTRON_SHELL_COMMON_NODE_UTIL_H_
+#define ELECTRON_SHELL_COMMON_NODE_UTIL_H_
+
+#include <vector>
+
+#include "v8/include/v8.h"
+
+namespace node {
+class Environment;
+}
+
+namespace electron {
+
+namespace util {
+
+// Run a script with JS source bundled inside the binary as if it's wrapped
+// in a function called with a null receiver and arguments specified in C++.
+// The returned value is empty if an exception is encountered.
+// JS code run with this method can assume that their top-level
+// declarations won't affect the global scope.
+v8::MaybeLocal<v8::Value> CompileAndCall(
+    v8::Local<v8::Context> context,
+    const char* id,
+    std::vector<v8::Local<v8::String>>* parameters,
+    std::vector<v8::Local<v8::Value>>* arguments,
+    node::Environment* optional_env);
+
+}  // namespace util
+
+}  // namespace electron
+
+#endif  // ELECTRON_SHELL_COMMON_NODE_UTIL_H_
diff --git a/libcef/renderer/embed/shell/common/gin_converters/accelerator_converter.cc b/libcef/renderer/embed/shell/common/gin_converters/accelerator_converter.cc
new file mode 100644
index 000000000..4d883ae8a
--- /dev/null
+++ b/libcef/renderer/embed/shell/common/gin_converters/accelerator_converter.cc
@@ -0,0 +1,23 @@
+// Copyright (c) 2014 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#include "shell/common/gin_converters/accelerator_converter.h"
+
+#include <string>
+
+#include "shell/browser/ui/accelerator_util.h"
+
+namespace gin {
+
+// static
+bool Converter<ui::Accelerator>::FromV8(v8::Isolate* isolate,
+                                        v8::Local<v8::Value> val,
+                                        ui::Accelerator* out) {
+  std::string keycode;
+  if (!ConvertFromV8(isolate, val, &keycode))
+    return false;
+  return accelerator_util::StringToAccelerator(keycode, out);
+}
+
+}  // namespace gin
diff --git a/libcef/renderer/embed/shell/common/gin_converters/accelerator_converter.h b/libcef/renderer/embed/shell/common/gin_converters/accelerator_converter.h
new file mode 100644
index 000000000..86a4a6416
--- /dev/null
+++ b/libcef/renderer/embed/shell/common/gin_converters/accelerator_converter.h
@@ -0,0 +1,25 @@
+// Copyright (c) 2014 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#ifndef ELECTRON_SHELL_COMMON_GIN_CONVERTERS_ACCELERATOR_CONVERTER_H_
+#define ELECTRON_SHELL_COMMON_GIN_CONVERTERS_ACCELERATOR_CONVERTER_H_
+
+#include "gin/converter.h"
+
+namespace ui {
+class Accelerator;
+}
+
+namespace gin {
+
+template <>
+struct Converter<ui::Accelerator> {
+  static bool FromV8(v8::Isolate* isolate,
+                     v8::Local<v8::Value> val,
+                     ui::Accelerator* out);
+};
+
+}  // namespace gin
+
+#endif  // ELECTRON_SHELL_COMMON_GIN_CONVERTERS_ACCELERATOR_CONVERTER_H_
diff --git a/libcef/renderer/embed/shell/common/gin_converters/base_converter.h b/libcef/renderer/embed/shell/common/gin_converters/base_converter.h
new file mode 100644
index 000000000..f44c64941
--- /dev/null
+++ b/libcef/renderer/embed/shell/common/gin_converters/base_converter.h
@@ -0,0 +1,47 @@
+// Copyright (c) 2020 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#ifndef ELECTRON_SHELL_COMMON_GIN_CONVERTERS_BASE_CONVERTER_H_
+#define ELECTRON_SHELL_COMMON_GIN_CONVERTERS_BASE_CONVERTER_H_
+
+#include "base/process/kill.h"
+#include "gin/converter.h"
+
+namespace gin {
+
+template <>
+struct Converter<base::TerminationStatus> {
+  static v8::Local<v8::Value> ToV8(v8::Isolate* isolate,
+                                   const base::TerminationStatus& status) {
+    switch (status) {
+      case base::TERMINATION_STATUS_NORMAL_TERMINATION:
+        return gin::ConvertToV8(isolate, "clean-exit");
+      case base::TERMINATION_STATUS_ABNORMAL_TERMINATION:
+        return gin::ConvertToV8(isolate, "abnormal-exit");
+      case base::TERMINATION_STATUS_PROCESS_WAS_KILLED:
+        return gin::ConvertToV8(isolate, "killed");
+      case base::TERMINATION_STATUS_PROCESS_CRASHED:
+        return gin::ConvertToV8(isolate, "crashed");
+      case base::TERMINATION_STATUS_STILL_RUNNING:
+        return gin::ConvertToV8(isolate, "still-running");
+      case base::TERMINATION_STATUS_LAUNCH_FAILED:
+        return gin::ConvertToV8(isolate, "launch-failed");
+      case base::TERMINATION_STATUS_OOM:
+        return gin::ConvertToV8(isolate, "oom");
+#if defined(OS_WIN)
+      case base::TERMINATION_STATUS_INTEGRITY_FAILURE:
+        return gin::ConvertToV8(isolate, "integrity-failure");
+#endif
+      case base::TERMINATION_STATUS_MAX_ENUM:
+        NOTREACHED();
+        return gin::ConvertToV8(isolate, "");
+    }
+    NOTREACHED();
+    return gin::ConvertToV8(isolate, "");
+  }
+};
+
+}  // namespace gin
+
+#endif  // ELECTRON_SHELL_COMMON_GIN_CONVERTERS_BASE_CONVERTER_H_
diff --git a/libcef/renderer/embed/shell/common/gin_converters/blink_converter.cc b/libcef/renderer/embed/shell/common/gin_converters/blink_converter.cc
new file mode 100644
index 000000000..68ba0307d
--- /dev/null
+++ b/libcef/renderer/embed/shell/common/gin_converters/blink_converter.cc
@@ -0,0 +1,603 @@
+// Copyright (c) 2015 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#include "shell/common/gin_converters/blink_converter.h"
+
+#include <algorithm>
+#include <string>
+#include <vector>
+
+#include "base/strings/string_util.h"
+#include "base/strings/utf_string_conversions.h"
+#include "gin/converter.h"
+#include "shell/common/gin_converters/gfx_converter.h"
+#include "shell/common/gin_converters/gurl_converter.h"
+#include "shell/common/gin_converters/value_converter.h"
+#include "shell/common/gin_helper/dictionary.h"
+#include "shell/common/keyboard_util.h"
+#include "shell/common/v8_value_serializer.h"
+#include "third_party/blink/public/common/context_menu_data/edit_flags.h"
+#include "third_party/blink/public/common/input/web_input_event.h"
+#include "third_party/blink/public/common/input/web_keyboard_event.h"
+#include "third_party/blink/public/common/input/web_mouse_event.h"
+#include "third_party/blink/public/common/input/web_mouse_wheel_event.h"
+#include "third_party/blink/public/common/widget/device_emulation_params.h"
+#include "third_party/blink/public/mojom/loader/referrer.mojom.h"
+#include "ui/base/clipboard/clipboard.h"
+#include "ui/events/blink/blink_event_util.h"
+#include "ui/events/keycodes/dom/keycode_converter.h"
+#include "ui/events/keycodes/keyboard_code_conversion.h"
+
+namespace {
+
+template <typename T>
+int VectorToBitArray(const std::vector<T>& vec) {
+  int bits = 0;
+  for (const T& item : vec)
+    bits |= item;
+  return bits;
+}
+
+}  // namespace
+
+namespace gin {
+
+template <>
+struct Converter<char16_t> {
+  static bool FromV8(v8::Isolate* isolate,
+                     v8::Handle<v8::Value> val,
+                     char16_t* out) {
+    std::u16string code = base::UTF8ToUTF16(gin::V8ToString(isolate, val));
+    if (code.length() != 1)
+      return false;
+    *out = code[0];
+    return true;
+  }
+};
+
+template <>
+struct Converter<blink::WebInputEvent::Type> {
+  static bool FromV8(v8::Isolate* isolate,
+                     v8::Handle<v8::Value> val,
+                     blink::WebInputEvent::Type* out) {
+    std::string type = base::ToLowerASCII(gin::V8ToString(isolate, val));
+    if (type == "mousedown")
+      *out = blink::WebInputEvent::Type::kMouseDown;
+    else if (type == "mouseup")
+      *out = blink::WebInputEvent::Type::kMouseUp;
+    else if (type == "mousemove")
+      *out = blink::WebInputEvent::Type::kMouseMove;
+    else if (type == "mouseenter")
+      *out = blink::WebInputEvent::Type::kMouseEnter;
+    else if (type == "mouseleave")
+      *out = blink::WebInputEvent::Type::kMouseLeave;
+    else if (type == "contextmenu")
+      *out = blink::WebInputEvent::Type::kContextMenu;
+    else if (type == "mousewheel")
+      *out = blink::WebInputEvent::Type::kMouseWheel;
+    else if (type == "keydown")
+      *out = blink::WebInputEvent::Type::kRawKeyDown;
+    else if (type == "keyup")
+      *out = blink::WebInputEvent::Type::kKeyUp;
+    else if (type == "char")
+      *out = blink::WebInputEvent::Type::kChar;
+    else if (type == "touchstart")
+      *out = blink::WebInputEvent::Type::kTouchStart;
+    else if (type == "touchmove")
+      *out = blink::WebInputEvent::Type::kTouchMove;
+    else if (type == "touchend")
+      *out = blink::WebInputEvent::Type::kTouchEnd;
+    else if (type == "touchcancel")
+      *out = blink::WebInputEvent::Type::kTouchCancel;
+    return true;
+  }
+};
+
+template <>
+struct Converter<blink::WebMouseEvent::Button> {
+  static bool FromV8(v8::Isolate* isolate,
+                     v8::Handle<v8::Value> val,
+                     blink::WebMouseEvent::Button* out) {
+    std::string button = base::ToLowerASCII(gin::V8ToString(isolate, val));
+    if (button == "left")
+      *out = blink::WebMouseEvent::Button::kLeft;
+    else if (button == "middle")
+      *out = blink::WebMouseEvent::Button::kMiddle;
+    else if (button == "right")
+      *out = blink::WebMouseEvent::Button::kRight;
+    else
+      return false;
+    return true;
+  }
+};
+
+template <>
+struct Converter<blink::WebInputEvent::Modifiers> {
+  static bool FromV8(v8::Isolate* isolate,
+                     v8::Handle<v8::Value> val,
+                     blink::WebInputEvent::Modifiers* out) {
+    std::string modifier = base::ToLowerASCII(gin::V8ToString(isolate, val));
+    if (modifier == "shift")
+      *out = blink::WebInputEvent::Modifiers::kShiftKey;
+    else if (modifier == "control" || modifier == "ctrl")
+      *out = blink::WebInputEvent::Modifiers::kControlKey;
+    else if (modifier == "alt")
+      *out = blink::WebInputEvent::Modifiers::kAltKey;
+    else if (modifier == "meta" || modifier == "command" || modifier == "cmd")
+      *out = blink::WebInputEvent::Modifiers::kMetaKey;
+    else if (modifier == "iskeypad")
+      *out = blink::WebInputEvent::Modifiers::kIsKeyPad;
+    else if (modifier == "isautorepeat")
+      *out = blink::WebInputEvent::Modifiers::kIsAutoRepeat;
+    else if (modifier == "leftbuttondown")
+      *out = blink::WebInputEvent::Modifiers::kLeftButtonDown;
+    else if (modifier == "middlebuttondown")
+      *out = blink::WebInputEvent::Modifiers::kMiddleButtonDown;
+    else if (modifier == "rightbuttondown")
+      *out = blink::WebInputEvent::Modifiers::kRightButtonDown;
+    else if (modifier == "capslock")
+      *out = blink::WebInputEvent::Modifiers::kCapsLockOn;
+    else if (modifier == "numlock")
+      *out = blink::WebInputEvent::Modifiers::kNumLockOn;
+    else if (modifier == "left")
+      *out = blink::WebInputEvent::Modifiers::kIsLeft;
+    else if (modifier == "right")
+      *out = blink::WebInputEvent::Modifiers::kIsRight;
+    // TODO(nornagon): the rest of the modifiers
+    return true;
+  }
+};
+
+std::vector<std::string> ModifiersToArray(int modifiers) {
+  using Modifiers = blink::WebInputEvent::Modifiers;
+  std::vector<std::string> modifier_strings;
+  if (modifiers & Modifiers::kShiftKey)
+    modifier_strings.push_back("shift");
+  if (modifiers & Modifiers::kControlKey)
+    modifier_strings.push_back("control");
+  if (modifiers & Modifiers::kAltKey)
+    modifier_strings.push_back("alt");
+  if (modifiers & Modifiers::kMetaKey)
+    modifier_strings.push_back("meta");
+  if (modifiers & Modifiers::kIsKeyPad)
+    modifier_strings.push_back("iskeypad");
+  if (modifiers & Modifiers::kIsAutoRepeat)
+    modifier_strings.push_back("isautorepeat");
+  if (modifiers & Modifiers::kLeftButtonDown)
+    modifier_strings.push_back("leftbuttondown");
+  if (modifiers & Modifiers::kMiddleButtonDown)
+    modifier_strings.push_back("middlebuttondown");
+  if (modifiers & Modifiers::kRightButtonDown)
+    modifier_strings.push_back("rightbuttondown");
+  if (modifiers & Modifiers::kCapsLockOn)
+    modifier_strings.push_back("capslock");
+  if (modifiers & Modifiers::kNumLockOn)
+    modifier_strings.push_back("numlock");
+  if (modifiers & Modifiers::kIsLeft)
+    modifier_strings.push_back("left");
+  if (modifiers & Modifiers::kIsRight)
+    modifier_strings.push_back("right");
+  // TODO(nornagon): the rest of the modifiers
+  return modifier_strings;
+}
+
+blink::WebInputEvent::Type GetWebInputEventType(v8::Isolate* isolate,
+                                                v8::Local<v8::Value> val) {
+  blink::WebInputEvent::Type type = blink::WebInputEvent::Type::kUndefined;
+  gin_helper::Dictionary dict;
+  ConvertFromV8(isolate, val, &dict) && dict.Get("type", &type);
+  return type;
+}
+
+bool Converter<blink::WebInputEvent>::FromV8(v8::Isolate* isolate,
+                                             v8::Local<v8::Value> val,
+                                             blink::WebInputEvent* out) {
+  gin_helper::Dictionary dict;
+  if (!ConvertFromV8(isolate, val, &dict))
+    return false;
+  blink::WebInputEvent::Type type;
+  if (!dict.Get("type", &type))
+    return false;
+  out->SetType(type);
+  std::vector<blink::WebInputEvent::Modifiers> modifiers;
+  if (dict.Get("modifiers", &modifiers))
+    out->SetModifiers(VectorToBitArray(modifiers));
+  out->SetTimeStamp(base::TimeTicks::Now());
+  return true;
+}
+
+bool Converter<blink::WebKeyboardEvent>::FromV8(v8::Isolate* isolate,
+                                                v8::Local<v8::Value> val,
+                                                blink::WebKeyboardEvent* out) {
+  gin_helper::Dictionary dict;
+  if (!ConvertFromV8(isolate, val, &dict))
+    return false;
+  if (!ConvertFromV8(isolate, val, static_cast<blink::WebInputEvent*>(out)))
+    return false;
+
+  std::string str;
+  if (!dict.Get("keyCode", &str))
+    return false;
+
+  absl::optional<char16_t> shifted_char;
+  ui::KeyboardCode keyCode = electron::KeyboardCodeFromStr(str, &shifted_char);
+  out->windows_key_code = keyCode;
+  if (shifted_char)
+    out->SetModifiers(out->GetModifiers() |
+                      blink::WebInputEvent::Modifiers::kShiftKey);
+
+  ui::DomCode domCode = ui::UsLayoutKeyboardCodeToDomCode(keyCode);
+  out->dom_code = static_cast<int>(domCode);
+
+  ui::DomKey domKey;
+  ui::KeyboardCode dummy_code;
+  int flags = ui::WebEventModifiersToEventFlags(out->GetModifiers());
+  if (ui::DomCodeToUsLayoutDomKey(domCode, flags, &domKey, &dummy_code))
+    out->dom_key = static_cast<int>(domKey);
+
+  if ((out->GetType() == blink::WebInputEvent::Type::kChar ||
+       out->GetType() == blink::WebInputEvent::Type::kRawKeyDown)) {
+    // Make sure to not read beyond the buffer in case some bad code doesn't
+    // NULL-terminate it (this is called from plugins).
+    size_t text_length_cap = blink::WebKeyboardEvent::kTextLengthCap;
+    std::u16string text16 = base::UTF8ToUTF16(str);
+
+    std::fill_n(out->text, text_length_cap, 0);
+    std::fill_n(out->unmodified_text, text_length_cap, 0);
+    for (size_t i = 0; i < std::min(text_length_cap - 1, text16.size()); ++i) {
+      out->text[i] = text16[i];
+      out->unmodified_text[i] = text16[i];
+    }
+  }
+  return true;
+}
+
+int GetKeyLocationCode(const blink::WebInputEvent& key) {
+  // https://source.chromium.org/chromium/chromium/src/+/main:third_party/blink/renderer/core/events/keyboard_event.h;l=46;drc=1ff6437e65b183e673b7b4f25060b74dc2ba5c37
+  enum KeyLocationCode {
+    kDomKeyLocationStandard = 0x00,
+    kDomKeyLocationLeft = 0x01,
+    kDomKeyLocationRight = 0x02,
+    kDomKeyLocationNumpad = 0x03
+  };
+  using Modifiers = blink::WebInputEvent::Modifiers;
+  if (key.GetModifiers() & Modifiers::kIsKeyPad)
+    return kDomKeyLocationNumpad;
+  if (key.GetModifiers() & Modifiers::kIsLeft)
+    return kDomKeyLocationLeft;
+  if (key.GetModifiers() & Modifiers::kIsRight)
+    return kDomKeyLocationRight;
+  return kDomKeyLocationStandard;
+}
+
+v8::Local<v8::Value> Converter<blink::WebKeyboardEvent>::ToV8(
+    v8::Isolate* isolate,
+    const blink::WebKeyboardEvent& in) {
+  gin_helper::Dictionary dict = gin::Dictionary::CreateEmpty(isolate);
+
+  if (in.GetType() == blink::WebInputEvent::Type::kRawKeyDown)
+    dict.Set("type", "keyDown");
+  else if (in.GetType() == blink::WebInputEvent::Type::kKeyUp)
+    dict.Set("type", "keyUp");
+  dict.Set("key", ui::KeycodeConverter::DomKeyToKeyString(in.dom_key));
+  dict.Set("code", ui::KeycodeConverter::DomCodeToCodeString(
+                       static_cast<ui::DomCode>(in.dom_code)));
+
+  using Modifiers = blink::WebInputEvent::Modifiers;
+  dict.Set("isAutoRepeat", (in.GetModifiers() & Modifiers::kIsAutoRepeat) != 0);
+  dict.Set("isComposing", (in.GetModifiers() & Modifiers::kIsComposing) != 0);
+  dict.Set("shift", (in.GetModifiers() & Modifiers::kShiftKey) != 0);
+  dict.Set("control", (in.GetModifiers() & Modifiers::kControlKey) != 0);
+  dict.Set("alt", (in.GetModifiers() & Modifiers::kAltKey) != 0);
+  dict.Set("meta", (in.GetModifiers() & Modifiers::kMetaKey) != 0);
+  dict.Set("location", GetKeyLocationCode(in));
+  dict.Set("_modifiers", in.GetModifiers());
+  dict.Set("modifiers", ModifiersToArray(in.GetModifiers()));
+
+  return dict.GetHandle();
+}
+
+bool Converter<blink::WebMouseEvent>::FromV8(v8::Isolate* isolate,
+                                             v8::Local<v8::Value> val,
+                                             blink::WebMouseEvent* out) {
+  gin_helper::Dictionary dict;
+  if (!ConvertFromV8(isolate, val, &dict))
+    return false;
+  if (!ConvertFromV8(isolate, val, static_cast<blink::WebInputEvent*>(out)))
+    return false;
+
+  float x = 0.f;
+  float y = 0.f;
+  if (!dict.Get("x", &x) || !dict.Get("y", &y))
+    return false;
+  out->SetPositionInWidget(x, y);
+
+  if (!dict.Get("button", &out->button))
+    out->button = blink::WebMouseEvent::Button::kLeft;
+
+  float global_x = 0.f;
+  float global_y = 0.f;
+  dict.Get("globalX", &global_x);
+  dict.Get("globalY", &global_y);
+  out->SetPositionInScreen(global_x, global_y);
+
+  dict.Get("movementX", &out->movement_x);
+  dict.Get("movementY", &out->movement_y);
+  dict.Get("clickCount", &out->click_count);
+  return true;
+}
+
+bool Converter<blink::WebMouseWheelEvent>::FromV8(
+    v8::Isolate* isolate,
+    v8::Local<v8::Value> val,
+    blink::WebMouseWheelEvent* out) {
+  gin_helper::Dictionary dict;
+  if (!ConvertFromV8(isolate, val, &dict))
+    return false;
+  if (!ConvertFromV8(isolate, val, static_cast<blink::WebMouseEvent*>(out)))
+    return false;
+  dict.Get("deltaX", &out->delta_x);
+  dict.Get("deltaY", &out->delta_y);
+  dict.Get("wheelTicksX", &out->wheel_ticks_x);
+  dict.Get("wheelTicksY", &out->wheel_ticks_y);
+  dict.Get("accelerationRatioX", &out->acceleration_ratio_x);
+  dict.Get("accelerationRatioY", &out->acceleration_ratio_y);
+
+  bool has_precise_scrolling_deltas = false;
+  dict.Get("hasPreciseScrollingDeltas", &has_precise_scrolling_deltas);
+  if (has_precise_scrolling_deltas) {
+    out->delta_units = ui::ScrollGranularity::kScrollByPrecisePixel;
+  } else {
+    out->delta_units = ui::ScrollGranularity::kScrollByPixel;
+  }
+
+#if defined(USE_AURA)
+  // Matches the behavior of ui/events/blink/web_input_event_traits.cc:
+  bool can_scroll = true;
+  if (dict.Get("canScroll", &can_scroll) && !can_scroll) {
+    out->delta_units = ui::ScrollGranularity::kScrollByPage;
+    out->SetModifiers(out->GetModifiers() &
+                      ~blink::WebInputEvent::Modifiers::kControlKey);
+  }
+#endif
+  return true;
+}
+
+bool Converter<blink::DeviceEmulationParams>::FromV8(
+    v8::Isolate* isolate,
+    v8::Local<v8::Value> val,
+    blink::DeviceEmulationParams* out) {
+  gin_helper::Dictionary dict;
+  if (!ConvertFromV8(isolate, val, &dict))
+    return false;
+
+  std::string screen_type;
+  if (dict.Get("screenPosition", &screen_type)) {
+    screen_type = base::ToLowerASCII(screen_type);
+    if (screen_type == "mobile")
+      out->screen_type = blink::mojom::EmulatedScreenType::kMobile;
+    else if (screen_type == "desktop")
+      out->screen_type = blink::mojom::EmulatedScreenType::kDesktop;
+    else
+      return false;
+  }
+
+  dict.Get("screenSize", &out->screen_size);
+  gfx::Point view_position;
+  if (dict.Get("viewPosition", &view_position)) {
+    out->view_position = view_position;
+  }
+  dict.Get("deviceScaleFactor", &out->device_scale_factor);
+  dict.Get("viewSize", &out->view_size);
+  dict.Get("scale", &out->scale);
+  return true;
+}
+
+// static
+v8::Local<v8::Value> Converter<blink::mojom::ContextMenuDataMediaType>::ToV8(
+    v8::Isolate* isolate,
+    const blink::mojom::ContextMenuDataMediaType& in) {
+  switch (in) {
+    case blink::mojom::ContextMenuDataMediaType::kImage:
+      return StringToV8(isolate, "image");
+    case blink::mojom::ContextMenuDataMediaType::kVideo:
+      return StringToV8(isolate, "video");
+    case blink::mojom::ContextMenuDataMediaType::kAudio:
+      return StringToV8(isolate, "audio");
+    case blink::mojom::ContextMenuDataMediaType::kCanvas:
+      return StringToV8(isolate, "canvas");
+    case blink::mojom::ContextMenuDataMediaType::kFile:
+      return StringToV8(isolate, "file");
+    case blink::mojom::ContextMenuDataMediaType::kPlugin:
+      return StringToV8(isolate, "plugin");
+    default:
+      return StringToV8(isolate, "none");
+  }
+}
+
+// static
+v8::Local<v8::Value>
+Converter<blink::mojom::ContextMenuDataInputFieldType>::ToV8(
+    v8::Isolate* isolate,
+    const blink::mojom::ContextMenuDataInputFieldType& in) {
+  switch (in) {
+    case blink::mojom::ContextMenuDataInputFieldType::kPlainText:
+      return StringToV8(isolate, "plainText");
+    case blink::mojom::ContextMenuDataInputFieldType::kPassword:
+      return StringToV8(isolate, "password");
+    case blink::mojom::ContextMenuDataInputFieldType::kOther:
+      return StringToV8(isolate, "other");
+    default:
+      return StringToV8(isolate, "none");
+  }
+}
+
+v8::Local<v8::Value> EditFlagsToV8(v8::Isolate* isolate, int editFlags) {
+  gin_helper::Dictionary dict = gin::Dictionary::CreateEmpty(isolate);
+  dict.Set("canUndo",
+           !!(editFlags & blink::ContextMenuDataEditFlags::kCanUndo));
+  dict.Set("canRedo",
+           !!(editFlags & blink::ContextMenuDataEditFlags::kCanRedo));
+  dict.Set("canCut", !!(editFlags & blink::ContextMenuDataEditFlags::kCanCut));
+  dict.Set("canCopy",
+           !!(editFlags & blink::ContextMenuDataEditFlags::kCanCopy));
+
+  bool pasteFlag = false;
+  if (editFlags & blink::ContextMenuDataEditFlags::kCanPaste) {
+    std::vector<std::u16string> types;
+    ui::Clipboard::GetForCurrentThread()->ReadAvailableTypes(
+        ui::ClipboardBuffer::kCopyPaste, /* data_dst = */ nullptr, &types);
+    pasteFlag = !types.empty();
+  }
+  dict.Set("canPaste", pasteFlag);
+
+  dict.Set("canDelete",
+           !!(editFlags & blink::ContextMenuDataEditFlags::kCanDelete));
+  dict.Set("canSelectAll",
+           !!(editFlags & blink::ContextMenuDataEditFlags::kCanSelectAll));
+  dict.Set("canEditRichly",
+           !!(editFlags & blink::ContextMenuDataEditFlags::kCanEditRichly));
+
+  return ConvertToV8(isolate, dict);
+}
+
+v8::Local<v8::Value> MediaFlagsToV8(v8::Isolate* isolate, int mediaFlags) {
+  gin_helper::Dictionary dict = gin::Dictionary::CreateEmpty(isolate);
+  dict.Set("inError", !!(mediaFlags & blink::ContextMenuData::kMediaInError));
+  dict.Set("isPaused", !!(mediaFlags & blink::ContextMenuData::kMediaPaused));
+  dict.Set("isMuted", !!(mediaFlags & blink::ContextMenuData::kMediaMuted));
+  dict.Set("canSave", !!(mediaFlags & blink::ContextMenuData::kMediaCanSave));
+  dict.Set("hasAudio", !!(mediaFlags & blink::ContextMenuData::kMediaHasAudio));
+  dict.Set("isLooping", !!(mediaFlags & blink::ContextMenuData::kMediaLoop));
+  dict.Set("isControlsVisible",
+           !!(mediaFlags & blink::ContextMenuData::kMediaControls));
+  dict.Set("canToggleControls",
+           !!(mediaFlags & blink::ContextMenuData::kMediaCanToggleControls));
+  dict.Set("canPrint", !!(mediaFlags & blink::ContextMenuData::kMediaCanPrint));
+  dict.Set("canRotate",
+           !!(mediaFlags & blink::ContextMenuData::kMediaCanRotate));
+  dict.Set("canShowPictureInPicture",
+           !!(mediaFlags & blink::ContextMenuData::kMediaCanPictureInPicture));
+  dict.Set("isShowingPictureInPicture",
+           !!(mediaFlags & blink::ContextMenuData::kMediaPictureInPicture));
+  dict.Set("canLoop", !!(mediaFlags & blink::ContextMenuData::kMediaCanLoop));
+  return ConvertToV8(isolate, dict);
+}
+
+v8::Local<v8::Value> Converter<blink::WebCacheResourceTypeStat>::ToV8(
+    v8::Isolate* isolate,
+    const blink::WebCacheResourceTypeStat& stat) {
+  gin_helper::Dictionary dict = gin::Dictionary::CreateEmpty(isolate);
+  dict.Set("count", static_cast<uint32_t>(stat.count));
+  dict.Set("size", static_cast<double>(stat.size));
+  dict.Set("liveSize", static_cast<double>(stat.decoded_size));
+  return dict.GetHandle();
+}
+
+v8::Local<v8::Value> Converter<blink::WebCacheResourceTypeStats>::ToV8(
+    v8::Isolate* isolate,
+    const blink::WebCacheResourceTypeStats& stats) {
+  gin_helper::Dictionary dict = gin::Dictionary::CreateEmpty(isolate);
+  dict.Set("images", stats.images);
+  dict.Set("scripts", stats.scripts);
+  dict.Set("cssStyleSheets", stats.css_style_sheets);
+  dict.Set("xslStyleSheets", stats.xsl_style_sheets);
+  dict.Set("fonts", stats.fonts);
+  dict.Set("other", stats.other);
+  return dict.GetHandle();
+}
+
+// static
+v8::Local<v8::Value> Converter<network::mojom::ReferrerPolicy>::ToV8(
+    v8::Isolate* isolate,
+    const network::mojom::ReferrerPolicy& in) {
+  switch (in) {
+    case network::mojom::ReferrerPolicy::kDefault:
+      return StringToV8(isolate, "default");
+    case network::mojom::ReferrerPolicy::kAlways:
+      return StringToV8(isolate, "unsafe-url");
+    case network::mojom::ReferrerPolicy::kNoReferrerWhenDowngrade:
+      return StringToV8(isolate, "no-referrer-when-downgrade");
+    case network::mojom::ReferrerPolicy::kNever:
+      return StringToV8(isolate, "no-referrer");
+    case network::mojom::ReferrerPolicy::kOrigin:
+      return StringToV8(isolate, "origin");
+    case network::mojom::ReferrerPolicy::kStrictOriginWhenCrossOrigin:
+      return StringToV8(isolate, "strict-origin-when-cross-origin");
+    case network::mojom::ReferrerPolicy::kSameOrigin:
+      return StringToV8(isolate, "same-origin");
+    case network::mojom::ReferrerPolicy::kStrictOrigin:
+      return StringToV8(isolate, "strict-origin");
+    default:
+      return StringToV8(isolate, "no-referrer");
+  }
+}
+
+// static
+bool Converter<network::mojom::ReferrerPolicy>::FromV8(
+    v8::Isolate* isolate,
+    v8::Handle<v8::Value> val,
+    network::mojom::ReferrerPolicy* out) {
+  std::string policy = base::ToLowerASCII(gin::V8ToString(isolate, val));
+  if (policy == "default")
+    *out = network::mojom::ReferrerPolicy::kDefault;
+  else if (policy == "unsafe-url")
+    *out = network::mojom::ReferrerPolicy::kAlways;
+  else if (policy == "no-referrer-when-downgrade")
+    *out = network::mojom::ReferrerPolicy::kNoReferrerWhenDowngrade;
+  else if (policy == "no-referrer")
+    *out = network::mojom::ReferrerPolicy::kNever;
+  else if (policy == "origin")
+    *out = network::mojom::ReferrerPolicy::kOrigin;
+  else if (policy == "strict-origin-when-cross-origin")
+    *out = network::mojom::ReferrerPolicy::kStrictOriginWhenCrossOrigin;
+  else if (policy == "same-origin")
+    *out = network::mojom::ReferrerPolicy::kSameOrigin;
+  else if (policy == "strict-origin")
+    *out = network::mojom::ReferrerPolicy::kStrictOrigin;
+  else
+    return false;
+  return true;
+}
+
+// static
+v8::Local<v8::Value> Converter<blink::mojom::Referrer>::ToV8(
+    v8::Isolate* isolate,
+    const blink::mojom::Referrer& val) {
+  gin_helper::Dictionary dict = gin::Dictionary::CreateEmpty(isolate);
+  dict.Set("url", ConvertToV8(isolate, val.url));
+  dict.Set("policy", ConvertToV8(isolate, val.policy));
+  return gin::ConvertToV8(isolate, dict);
+}
+//
+// static
+bool Converter<blink::mojom::Referrer>::FromV8(v8::Isolate* isolate,
+                                               v8::Local<v8::Value> val,
+                                               blink::mojom::Referrer* out) {
+  gin_helper::Dictionary dict;
+  if (!ConvertFromV8(isolate, val, &dict))
+    return false;
+
+  if (!dict.Get("url", &out->url))
+    return false;
+
+  if (!dict.Get("policy", &out->policy))
+    return false;
+
+  return true;
+}
+
+v8::Local<v8::Value> Converter<blink::CloneableMessage>::ToV8(
+    v8::Isolate* isolate,
+    const blink::CloneableMessage& in) {
+  return electron::DeserializeV8Value(isolate, in);
+}
+
+bool Converter<blink::CloneableMessage>::FromV8(v8::Isolate* isolate,
+                                                v8::Handle<v8::Value> val,
+                                                blink::CloneableMessage* out) {
+  return electron::SerializeV8Value(isolate, val, out);
+}
+
+}  // namespace gin
diff --git a/libcef/renderer/embed/shell/common/gin_converters/blink_converter.h b/libcef/renderer/embed/shell/common/gin_converters/blink_converter.h
new file mode 100644
index 000000000..8ae85d750
--- /dev/null
+++ b/libcef/renderer/embed/shell/common/gin_converters/blink_converter.h
@@ -0,0 +1,123 @@
+// Copyright (c) 2015 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#ifndef ELECTRON_SHELL_COMMON_GIN_CONVERTERS_BLINK_CONVERTER_H_
+#define ELECTRON_SHELL_COMMON_GIN_CONVERTERS_BLINK_CONVERTER_H_
+
+#include "gin/converter.h"
+#include "third_party/blink/public/common/context_menu_data/context_menu_data.h"
+#include "third_party/blink/public/common/input/web_input_event.h"
+#include "third_party/blink/public/common/messaging/cloneable_message.h"
+#include "third_party/blink/public/common/web_cache/web_cache_resource_type_stats.h"
+#include "third_party/blink/public/mojom/loader/referrer.mojom-forward.h"
+
+namespace blink {
+class WebMouseEvent;
+class WebMouseWheelEvent;
+class WebKeyboardEvent;
+struct DeviceEmulationParams;
+}  // namespace blink
+
+namespace gin {
+
+blink::WebInputEvent::Type GetWebInputEventType(v8::Isolate* isolate,
+                                                v8::Local<v8::Value> val);
+
+template <>
+struct Converter<blink::WebInputEvent> {
+  static bool FromV8(v8::Isolate* isolate,
+                     v8::Local<v8::Value> val,
+                     blink::WebInputEvent* out);
+};
+
+template <>
+struct Converter<blink::WebKeyboardEvent> {
+  static bool FromV8(v8::Isolate* isolate,
+                     v8::Local<v8::Value> val,
+                     blink::WebKeyboardEvent* out);
+  static v8::Local<v8::Value> ToV8(v8::Isolate* isolate,
+                                   const blink::WebKeyboardEvent& in);
+};
+
+template <>
+struct Converter<blink::WebMouseEvent> {
+  static bool FromV8(v8::Isolate* isolate,
+                     v8::Local<v8::Value> val,
+                     blink::WebMouseEvent* out);
+};
+
+template <>
+struct Converter<blink::WebMouseWheelEvent> {
+  static bool FromV8(v8::Isolate* isolate,
+                     v8::Local<v8::Value> val,
+                     blink::WebMouseWheelEvent* out);
+};
+
+template <>
+struct Converter<blink::DeviceEmulationParams> {
+  static bool FromV8(v8::Isolate* isolate,
+                     v8::Local<v8::Value> val,
+                     blink::DeviceEmulationParams* out);
+};
+
+template <>
+struct Converter<blink::mojom::ContextMenuDataMediaType> {
+  static v8::Local<v8::Value> ToV8(
+      v8::Isolate* isolate,
+      const blink::mojom::ContextMenuDataMediaType& in);
+};
+
+template <>
+struct Converter<blink::mojom::ContextMenuDataInputFieldType> {
+  static v8::Local<v8::Value> ToV8(
+      v8::Isolate* isolate,
+      const blink::mojom::ContextMenuDataInputFieldType& in);
+};
+
+template <>
+struct Converter<blink::WebCacheResourceTypeStat> {
+  static v8::Local<v8::Value> ToV8(v8::Isolate* isolate,
+                                   const blink::WebCacheResourceTypeStat& stat);
+};
+
+template <>
+struct Converter<blink::WebCacheResourceTypeStats> {
+  static v8::Local<v8::Value> ToV8(
+      v8::Isolate* isolate,
+      const blink::WebCacheResourceTypeStats& stats);
+};
+
+template <>
+struct Converter<network::mojom::ReferrerPolicy> {
+  static v8::Local<v8::Value> ToV8(v8::Isolate* isolate,
+                                   const network::mojom::ReferrerPolicy& in);
+  static bool FromV8(v8::Isolate* isolate,
+                     v8::Local<v8::Value> val,
+                     network::mojom::ReferrerPolicy* out);
+};
+
+template <>
+struct Converter<blink::mojom::Referrer> {
+  static v8::Local<v8::Value> ToV8(v8::Isolate* isolate,
+                                   const blink::mojom::Referrer& val);
+  static bool FromV8(v8::Isolate* isolate,
+                     v8::Local<v8::Value> val,
+                     blink::mojom::Referrer* out);
+};
+
+template <>
+struct Converter<blink::CloneableMessage> {
+  static v8::Local<v8::Value> ToV8(v8::Isolate* isolate,
+                                   const blink::CloneableMessage& in);
+  static bool FromV8(v8::Isolate* isolate,
+                     v8::Local<v8::Value> val,
+                     blink::CloneableMessage* out);
+};
+
+v8::Local<v8::Value> EditFlagsToV8(v8::Isolate* isolate, int editFlags);
+v8::Local<v8::Value> MediaFlagsToV8(v8::Isolate* isolate, int mediaFlags);
+
+}  // namespace gin
+
+#endif  // ELECTRON_SHELL_COMMON_GIN_CONVERTERS_BLINK_CONVERTER_H_
diff --git a/libcef/renderer/embed/shell/common/gin_converters/callback_converter.h b/libcef/renderer/embed/shell/common/gin_converters/callback_converter.h
new file mode 100644
index 000000000..8682ca947
--- /dev/null
+++ b/libcef/renderer/embed/shell/common/gin_converters/callback_converter.h
@@ -0,0 +1,59 @@
+// Copyright (c) 2019 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#ifndef ELECTRON_SHELL_COMMON_GIN_CONVERTERS_CALLBACK_CONVERTER_H_
+#define ELECTRON_SHELL_COMMON_GIN_CONVERTERS_CALLBACK_CONVERTER_H_
+
+#include <utility>
+
+#include "base/callback_helpers.h"
+#include "shell/common/gin_helper/callback.h"
+
+namespace gin {
+
+template <typename Sig>
+struct Converter<base::RepeatingCallback<Sig>> {
+  static v8::Local<v8::Value> ToV8(v8::Isolate* isolate,
+                                   const base::RepeatingCallback<Sig>& val) {
+    // We don't use CreateFunctionTemplate here because it creates a new
+    // FunctionTemplate everytime, which is cached by V8 and causes leaks.
+    auto translater =
+        base::BindRepeating(&gin_helper::NativeFunctionInvoker<Sig>::Go, val);
+    // To avoid memory leak, we ensure that the callback can only be called
+    // for once.
+    return gin_helper::CreateFunctionFromTranslater(isolate, translater, true);
+  }
+  static bool FromV8(v8::Isolate* isolate,
+                     v8::Local<v8::Value> val,
+                     base::RepeatingCallback<Sig>* out) {
+    if (!val->IsFunction())
+      return false;
+
+    *out = base::BindRepeating(&gin_helper::V8FunctionInvoker<Sig>::Go, isolate,
+                               gin_helper::SafeV8Function(isolate, val));
+    return true;
+  }
+};
+
+template <typename Sig>
+struct Converter<base::OnceCallback<Sig>> {
+  static v8::Local<v8::Value> ToV8(v8::Isolate* isolate,
+                                   base::OnceCallback<Sig> in) {
+    return gin::ConvertToV8(isolate,
+                            base::AdaptCallbackForRepeating(std::move(in)));
+  }
+  static bool FromV8(v8::Isolate* isolate,
+                     v8::Local<v8::Value> val,
+                     base::OnceCallback<Sig>* out) {
+    if (!val->IsFunction())
+      return false;
+    *out = base::BindOnce(&gin_helper::V8FunctionInvoker<Sig>::Go, isolate,
+                          gin_helper::SafeV8Function(isolate, val));
+    return true;
+  }
+};
+
+}  // namespace gin
+
+#endif  // ELECTRON_SHELL_COMMON_GIN_CONVERTERS_CALLBACK_CONVERTER_H_
diff --git a/libcef/renderer/embed/shell/common/gin_converters/content_converter.cc b/libcef/renderer/embed/shell/common/gin_converters/content_converter.cc
new file mode 100644
index 000000000..600b525df
--- /dev/null
+++ b/libcef/renderer/embed/shell/common/gin_converters/content_converter.cc
@@ -0,0 +1,312 @@
+// Copyright (c) 2015 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#include "shell/common/gin_converters/content_converter.h"
+
+#include <string>
+
+#include "content/public/browser/context_menu_params.h"
+#include "content/public/browser/native_web_keyboard_event.h"
+#include "content/public/browser/web_contents.h"
+#include "shell/browser/api/electron_api_web_contents.h"
+#include "shell/browser/web_contents_permission_helper.h"
+#include "shell/common/gin_converters/blink_converter.h"
+#include "shell/common/gin_converters/callback_converter.h"
+#include "shell/common/gin_converters/frame_converter.h"
+#include "shell/common/gin_converters/gfx_converter.h"
+#include "shell/common/gin_converters/gurl_converter.h"
+#include "shell/common/gin_helper/dictionary.h"
+#include "third_party/blink/public/common/context_menu_data/untrustworthy_context_menu_params.h"
+#include "ui/events/keycodes/dom/keycode_converter.h"
+#include "ui/events/keycodes/keyboard_code_conversion.h"
+
+namespace gin {
+
+template <>
+struct Converter<ui::MenuSourceType> {
+  static v8::Local<v8::Value> ToV8(v8::Isolate* isolate,
+                                   const ui::MenuSourceType& in) {
+    switch (in) {
+      case ui::MENU_SOURCE_MOUSE:
+        return StringToV8(isolate, "mouse");
+      case ui::MENU_SOURCE_KEYBOARD:
+        return StringToV8(isolate, "keyboard");
+      case ui::MENU_SOURCE_TOUCH:
+        return StringToV8(isolate, "touch");
+      case ui::MENU_SOURCE_TOUCH_EDIT_MENU:
+        return StringToV8(isolate, "touchMenu");
+      case ui::MENU_SOURCE_LONG_PRESS:
+        return StringToV8(isolate, "longPress");
+      case ui::MENU_SOURCE_LONG_TAP:
+        return StringToV8(isolate, "longTap");
+      case ui::MENU_SOURCE_TOUCH_HANDLE:
+        return StringToV8(isolate, "touchHandle");
+      case ui::MENU_SOURCE_STYLUS:
+        return StringToV8(isolate, "stylus");
+      case ui::MENU_SOURCE_ADJUST_SELECTION:
+        return StringToV8(isolate, "adjustSelection");
+      case ui::MENU_SOURCE_ADJUST_SELECTION_RESET:
+        return StringToV8(isolate, "adjustSelectionReset");
+      default:
+        return StringToV8(isolate, "none");
+    }
+  }
+};
+
+// static
+v8::Local<v8::Value> Converter<blink::mojom::MenuItem::Type>::ToV8(
+    v8::Isolate* isolate,
+    const blink::mojom::MenuItem::Type& val) {
+  switch (val) {
+    case blink::mojom::MenuItem::Type::kCheckableOption:
+      return StringToV8(isolate, "checkbox");
+    case blink::mojom::MenuItem::Type::kGroup:
+      return StringToV8(isolate, "radio");
+    case blink::mojom::MenuItem::Type::kSeparator:
+      return StringToV8(isolate, "separator");
+    case blink::mojom::MenuItem::Type::kSubMenu:
+      return StringToV8(isolate, "submenu");
+    case blink::mojom::MenuItem::Type::kOption:
+    default:
+      return StringToV8(isolate, "normal");
+  }
+}
+
+// static
+v8::Local<v8::Value> Converter<ContextMenuParamsWithRenderFrameHost>::ToV8(
+    v8::Isolate* isolate,
+    const ContextMenuParamsWithRenderFrameHost& val) {
+  const auto& params = val.first;
+  content::RenderFrameHost* render_frame_host = val.second;
+  gin_helper::Dictionary dict = gin::Dictionary::CreateEmpty(isolate);
+  dict.SetGetter("frame", render_frame_host, v8::DontEnum);
+  dict.Set("x", params.x);
+  dict.Set("y", params.y);
+  dict.Set("linkURL", params.link_url);
+  dict.Set("linkText", params.link_text);
+  dict.Set("pageURL", params.page_url);
+  dict.Set("frameURL", params.frame_url);
+  dict.Set("srcURL", params.src_url);
+  dict.Set("mediaType", params.media_type);
+  dict.Set("mediaFlags", MediaFlagsToV8(isolate, params.media_flags));
+  bool has_image_contents =
+      (params.media_type == blink::mojom::ContextMenuDataMediaType::kImage) &&
+      params.has_image_contents;
+  dict.Set("hasImageContents", has_image_contents);
+  dict.Set("isEditable", params.is_editable);
+  dict.Set("editFlags", EditFlagsToV8(isolate, params.edit_flags));
+  dict.Set("selectionText", params.selection_text);
+  dict.Set("titleText", params.title_text);
+  dict.Set("altText", params.alt_text);
+  dict.Set("suggestedFilename", params.suggested_filename);
+  dict.Set("misspelledWord", params.misspelled_word);
+  dict.Set("selectionRect", params.selection_rect);
+#if BUILDFLAG(ENABLE_BUILTIN_SPELLCHECKER)
+  dict.Set("dictionarySuggestions", params.dictionary_suggestions);
+  dict.Set("spellcheckEnabled", params.spellcheck_enabled);
+#else
+  dict.Set("spellcheckEnabled", false);
+#endif
+  dict.Set("frameCharset", params.frame_charset);
+  dict.Set("referrerPolicy", params.referrer_policy);
+  dict.Set("inputFieldType", params.input_field_type);
+  dict.Set("menuSourceType", params.source_type);
+
+  return gin::ConvertToV8(isolate, dict);
+}
+
+// static
+bool Converter<blink::mojom::PermissionStatus>::FromV8(
+    v8::Isolate* isolate,
+    v8::Local<v8::Value> val,
+    blink::mojom::PermissionStatus* out) {
+  bool result;
+  if (!ConvertFromV8(isolate, val, &result))
+    return false;
+
+  if (result)
+    *out = blink::mojom::PermissionStatus::GRANTED;
+  else
+    *out = blink::mojom::PermissionStatus::DENIED;
+
+  return true;
+}
+
+// static
+v8::Local<v8::Value> Converter<content::PermissionType>::ToV8(
+    v8::Isolate* isolate,
+    const content::PermissionType& val) {
+  using PermissionType = electron::WebContentsPermissionHelper::PermissionType;
+  // Based on mappings from content/browser/devtools/protocol/browser_handler.cc
+  // Not all permissions are currently used by Electron but this will future
+  // proof these conversions.
+  switch (val) {
+    case content::PermissionType::ACCESSIBILITY_EVENTS:
+      return StringToV8(isolate, "accessibility-events");
+    case content::PermissionType::AR:
+      return StringToV8(isolate, "ar");
+    case content::PermissionType::BACKGROUND_FETCH:
+      return StringToV8(isolate, "background-fetch");
+    case content::PermissionType::BACKGROUND_SYNC:
+      return StringToV8(isolate, "background-sync");
+    case content::PermissionType::CLIPBOARD_READ_WRITE:
+      return StringToV8(isolate, "clipboard-read");
+    case content::PermissionType::CLIPBOARD_SANITIZED_WRITE:
+      return StringToV8(isolate, "clipboard-sanitized-write");
+    case content::PermissionType::FONT_ACCESS:
+      return StringToV8(isolate, "font-access");
+    case content::PermissionType::IDLE_DETECTION:
+      return StringToV8(isolate, "idle-detection");
+    case content::PermissionType::MIDI_SYSEX:
+      return StringToV8(isolate, "midiSysex");
+    case content::PermissionType::NFC:
+      return StringToV8(isolate, "nfc");
+    case content::PermissionType::NOTIFICATIONS:
+      return StringToV8(isolate, "notifications");
+    case content::PermissionType::PAYMENT_HANDLER:
+      return StringToV8(isolate, "payment-handler");
+    case content::PermissionType::PERIODIC_BACKGROUND_SYNC:
+      return StringToV8(isolate, "periodic-background-sync");
+    case content::PermissionType::DURABLE_STORAGE:
+      return StringToV8(isolate, "persistent-storage");
+    case content::PermissionType::GEOLOCATION:
+      return StringToV8(isolate, "geolocation");
+    case content::PermissionType::CAMERA_PAN_TILT_ZOOM:
+    case content::PermissionType::AUDIO_CAPTURE:
+    case content::PermissionType::VIDEO_CAPTURE:
+      return StringToV8(isolate, "media");
+    case content::PermissionType::PROTECTED_MEDIA_IDENTIFIER:
+      return StringToV8(isolate, "mediaKeySystem");
+    case content::PermissionType::MIDI:
+      return StringToV8(isolate, "midi");
+    case content::PermissionType::WAKE_LOCK_SCREEN:
+      return StringToV8(isolate, "screen-wake-lock");
+    case content::PermissionType::SENSORS:
+      return StringToV8(isolate, "sensors");
+    case content::PermissionType::STORAGE_ACCESS_GRANT:
+      return StringToV8(isolate, "storage-access");
+    case content::PermissionType::VR:
+      return StringToV8(isolate, "vr");
+    case content::PermissionType::WAKE_LOCK_SYSTEM:
+      return StringToV8(isolate, "system-wake-lock");
+    case content::PermissionType::WINDOW_PLACEMENT:
+      return StringToV8(isolate, "window-placement");
+    case content::PermissionType::DISPLAY_CAPTURE:
+      return StringToV8(isolate, "display-capture");
+    case content::PermissionType::NUM:
+      break;
+  }
+
+  switch (static_cast<PermissionType>(val)) {
+    case PermissionType::POINTER_LOCK:
+      return StringToV8(isolate, "pointerLock");
+    case PermissionType::FULLSCREEN:
+      return StringToV8(isolate, "fullscreen");
+    case PermissionType::OPEN_EXTERNAL:
+      return StringToV8(isolate, "openExternal");
+    case PermissionType::SERIAL:
+      return StringToV8(isolate, "serial");
+    case PermissionType::HID:
+      return StringToV8(isolate, "hid");
+    default:
+      return StringToV8(isolate, "unknown");
+  }
+}
+
+// static
+bool Converter<content::StopFindAction>::FromV8(v8::Isolate* isolate,
+                                                v8::Local<v8::Value> val,
+                                                content::StopFindAction* out) {
+  std::string action;
+  if (!ConvertFromV8(isolate, val, &action))
+    return false;
+
+  if (action == "clearSelection")
+    *out = content::STOP_FIND_ACTION_CLEAR_SELECTION;
+  else if (action == "keepSelection")
+    *out = content::STOP_FIND_ACTION_KEEP_SELECTION;
+  else if (action == "activateSelection")
+    *out = content::STOP_FIND_ACTION_ACTIVATE_SELECTION;
+  else
+    return false;
+
+  return true;
+}
+
+// static
+v8::Local<v8::Value> Converter<content::WebContents*>::ToV8(
+    v8::Isolate* isolate,
+    content::WebContents* val) {
+  if (!val)
+    return v8::Null(isolate);
+  return electron::api::WebContents::FromOrCreate(isolate, val).ToV8();
+}
+
+// static
+bool Converter<content::WebContents*>::FromV8(v8::Isolate* isolate,
+                                              v8::Local<v8::Value> val,
+                                              content::WebContents** out) {
+  if (!val->IsObject())
+    return false;
+  // gin's unwrapping converter doesn't expect the pointer inside to ever be
+  // nullptr, so we check here first before attempting to unwrap.
+  if (gin_helper::Destroyable::IsDestroyed(val.As<v8::Object>()))
+    return false;
+  electron::api::WebContents* web_contents = nullptr;
+  if (!gin::ConvertFromV8(isolate, val, &web_contents) || !web_contents)
+    return false;
+
+  *out = web_contents->web_contents();
+  return true;
+}
+
+// static
+v8::Local<v8::Value> Converter<content::Referrer>::ToV8(
+    v8::Isolate* isolate,
+    const content::Referrer& val) {
+  gin_helper::Dictionary dict = gin::Dictionary::CreateEmpty(isolate);
+  dict.Set("url", ConvertToV8(isolate, val.url));
+  dict.Set("policy", ConvertToV8(isolate, val.policy));
+  return gin::ConvertToV8(isolate, dict);
+}
+
+// static
+bool Converter<content::Referrer>::FromV8(v8::Isolate* isolate,
+                                          v8::Local<v8::Value> val,
+                                          content::Referrer* out) {
+  gin_helper::Dictionary dict;
+  if (!ConvertFromV8(isolate, val, &dict))
+    return false;
+
+  if (!dict.Get("url", &out->url))
+    return false;
+
+  if (!dict.Get("policy", &out->policy))
+    return false;
+
+  return true;
+}
+
+// static
+bool Converter<content::NativeWebKeyboardEvent>::FromV8(
+    v8::Isolate* isolate,
+    v8::Local<v8::Value> val,
+    content::NativeWebKeyboardEvent* out) {
+  gin_helper::Dictionary dict;
+  if (!ConvertFromV8(isolate, val, &dict))
+    return false;
+  if (!ConvertFromV8(isolate, val, static_cast<blink::WebKeyboardEvent*>(out)))
+    return false;
+  dict.Get("skipInBrowser", &out->skip_in_browser);
+  return true;
+}
+
+// static
+v8::Local<v8::Value> Converter<content::NativeWebKeyboardEvent>::ToV8(
+    v8::Isolate* isolate,
+    const content::NativeWebKeyboardEvent& in) {
+  return ConvertToV8(isolate, static_cast<blink::WebKeyboardEvent>(in));
+}
+
+}  // namespace gin
diff --git a/libcef/renderer/embed/shell/common/gin_converters/content_converter.h b/libcef/renderer/embed/shell/common/gin_converters/content_converter.h
new file mode 100644
index 000000000..e157b9f4a
--- /dev/null
+++ b/libcef/renderer/embed/shell/common/gin_converters/content_converter.h
@@ -0,0 +1,91 @@
+// Copyright (c) 2015 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#ifndef ELECTRON_SHELL_COMMON_GIN_CONVERTERS_CONTENT_CONVERTER_H_
+#define ELECTRON_SHELL_COMMON_GIN_CONVERTERS_CONTENT_CONVERTER_H_
+
+#include <utility>
+
+#include "content/public/browser/permission_type.h"
+#include "content/public/common/referrer.h"
+#include "content/public/common/stop_find_action.h"
+#include "gin/converter.h"
+#include "third_party/blink/public/mojom/choosers/popup_menu.mojom.h"
+#include "third_party/blink/public/mojom/permissions/permission_status.mojom.h"
+
+namespace content {
+struct ContextMenuParams;
+struct NativeWebKeyboardEvent;
+class RenderFrameHost;
+class WebContents;
+}  // namespace content
+
+using ContextMenuParamsWithRenderFrameHost =
+    std::pair<content::ContextMenuParams, content::RenderFrameHost*>;
+
+namespace gin {
+
+template <>
+struct Converter<blink::mojom::MenuItem::Type> {
+  static v8::Local<v8::Value> ToV8(v8::Isolate* isolate,
+                                   const blink::mojom::MenuItem::Type& val);
+};
+
+template <>
+struct Converter<ContextMenuParamsWithRenderFrameHost> {
+  static v8::Local<v8::Value> ToV8(
+      v8::Isolate* isolate,
+      const ContextMenuParamsWithRenderFrameHost& val);
+};
+
+template <>
+struct Converter<blink::mojom::PermissionStatus> {
+  static bool FromV8(v8::Isolate* isolate,
+                     v8::Local<v8::Value> val,
+                     blink::mojom::PermissionStatus* out);
+};
+
+template <>
+struct Converter<content::PermissionType> {
+  static v8::Local<v8::Value> ToV8(v8::Isolate* isolate,
+                                   const content::PermissionType& val);
+};
+
+template <>
+struct Converter<content::StopFindAction> {
+  static bool FromV8(v8::Isolate* isolate,
+                     v8::Local<v8::Value> val,
+                     content::StopFindAction* out);
+};
+
+template <>
+struct Converter<content::WebContents*> {
+  static v8::Local<v8::Value> ToV8(v8::Isolate* isolate,
+                                   content::WebContents* val);
+  static bool FromV8(v8::Isolate* isolate,
+                     v8::Local<v8::Value> val,
+                     content::WebContents** out);
+};
+
+template <>
+struct Converter<content::Referrer> {
+  static v8::Local<v8::Value> ToV8(v8::Isolate* isolate,
+                                   const content::Referrer& val);
+  static bool FromV8(v8::Isolate* isolate,
+                     v8::Local<v8::Value> val,
+                     content::Referrer* out);
+};
+
+template <>
+struct Converter<content::NativeWebKeyboardEvent> {
+  static bool FromV8(v8::Isolate* isolate,
+                     v8::Local<v8::Value> val,
+                     content::NativeWebKeyboardEvent* out);
+  static v8::Local<v8::Value> ToV8(v8::Isolate* isolate,
+                                   const content::NativeWebKeyboardEvent& in);
+};
+
+}  // namespace gin
+
+#endif  // ELECTRON_SHELL_COMMON_GIN_CONVERTERS_CONTENT_CONVERTER_H_
diff --git a/libcef/renderer/embed/shell/common/gin_converters/extension_converter.cc b/libcef/renderer/embed/shell/common/gin_converters/extension_converter.cc
new file mode 100644
index 000000000..a81d6a81d
--- /dev/null
+++ b/libcef/renderer/embed/shell/common/gin_converters/extension_converter.cc
@@ -0,0 +1,30 @@
+// Copyright (c) 2019 Slack Technologies, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#include "shell/common/gin_converters/extension_converter.h"
+
+#include "extensions/common/extension.h"
+#include "gin/dictionary.h"
+#include "shell/common/gin_converters/file_path_converter.h"
+#include "shell/common/gin_converters/gurl_converter.h"
+#include "shell/common/gin_converters/value_converter.h"
+
+namespace gin {
+
+// static
+v8::Local<v8::Value> Converter<const extensions::Extension*>::ToV8(
+    v8::Isolate* isolate,
+    const extensions::Extension* extension) {
+  auto dict = gin::Dictionary::CreateEmpty(isolate);
+  dict.Set("id", extension->id());
+  dict.Set("name", extension->name());
+  dict.Set("path", extension->path());
+  dict.Set("url", extension->url());
+  dict.Set("version", extension->VersionString());
+  dict.Set("manifest", *(extension->manifest()->value()));
+
+  return gin::ConvertToV8(isolate, dict);
+}
+
+}  // namespace gin
diff --git a/libcef/renderer/embed/shell/common/gin_converters/extension_converter.h b/libcef/renderer/embed/shell/common/gin_converters/extension_converter.h
new file mode 100644
index 000000000..83c30ffe6
--- /dev/null
+++ b/libcef/renderer/embed/shell/common/gin_converters/extension_converter.h
@@ -0,0 +1,26 @@
+// Copyright (c) 2019 Slack Technologies, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#ifndef ELECTRON_SHELL_COMMON_GIN_CONVERTERS_EXTENSION_CONVERTER_H_
+#define ELECTRON_SHELL_COMMON_GIN_CONVERTERS_EXTENSION_CONVERTER_H_
+
+#include <string>
+
+#include "gin/converter.h"
+
+namespace extensions {
+class Extension;
+}
+
+namespace gin {
+
+template <>
+struct Converter<const extensions::Extension*> {
+  static v8::Local<v8::Value> ToV8(v8::Isolate* isolate,
+                                   const extensions::Extension* val);
+};
+
+}  // namespace gin
+
+#endif  // ELECTRON_SHELL_COMMON_GIN_CONVERTERS_EXTENSION_CONVERTER_H_
diff --git a/libcef/renderer/embed/shell/common/gin_converters/file_dialog_converter.cc b/libcef/renderer/embed/shell/common/gin_converters/file_dialog_converter.cc
new file mode 100644
index 000000000..2f12c71a1
--- /dev/null
+++ b/libcef/renderer/embed/shell/common/gin_converters/file_dialog_converter.cc
@@ -0,0 +1,77 @@
+// Copyright (c) 2019 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#include "shell/common/gin_converters/file_dialog_converter.h"
+
+#include "gin/dictionary.h"
+#include "shell/browser/api/electron_api_browser_window.h"
+#include "shell/common/gin_converters/file_path_converter.h"
+#include "shell/common/gin_converters/native_window_converter.h"
+
+namespace gin {
+
+bool Converter<file_dialog::Filter>::FromV8(v8::Isolate* isolate,
+                                            v8::Local<v8::Value> val,
+                                            file_dialog::Filter* out) {
+  gin::Dictionary dict(nullptr);
+  if (!ConvertFromV8(isolate, val, &dict))
+    return false;
+  if (!dict.Get("name", &(out->first)))
+    return false;
+  if (!dict.Get("extensions", &(out->second)))
+    return false;
+  return true;
+}
+
+v8::Local<v8::Value> Converter<file_dialog::Filter>::ToV8(
+    v8::Isolate* isolate,
+    const file_dialog::Filter& in) {
+  gin::Dictionary dict = gin::Dictionary::CreateEmpty(isolate);
+
+  dict.Set("name", in.first);
+  dict.Set("extensions", in.second);
+
+  return gin::ConvertToV8(isolate, dict);
+}
+
+bool Converter<file_dialog::DialogSettings>::FromV8(
+    v8::Isolate* isolate,
+    v8::Local<v8::Value> val,
+    file_dialog::DialogSettings* out) {
+  gin::Dictionary dict(nullptr);
+  if (!ConvertFromV8(isolate, val, &dict))
+    return false;
+  dict.Get("window", &(out->parent_window));
+  dict.Get("title", &(out->title));
+  dict.Get("message", &(out->message));
+  dict.Get("buttonLabel", &(out->button_label));
+  dict.Get("nameFieldLabel", &(out->name_field_label));
+  dict.Get("defaultPath", &(out->default_path));
+  dict.Get("filters", &(out->filters));
+  dict.Get("properties", &(out->properties));
+  dict.Get("showsTagField", &(out->shows_tag_field));
+  dict.Get("securityScopedBookmarks", &(out->security_scoped_bookmarks));
+  return true;
+}
+
+v8::Local<v8::Value> Converter<file_dialog::DialogSettings>::ToV8(
+    v8::Isolate* isolate,
+    const file_dialog::DialogSettings& in) {
+  gin::Dictionary dict = gin::Dictionary::CreateEmpty(isolate);
+
+  dict.Set("window",
+           electron::api::BrowserWindow::From(isolate, in.parent_window));
+  dict.Set("title", in.title);
+  dict.Set("message", in.message);
+  dict.Set("buttonLabel", in.button_label);
+  dict.Set("nameFieldLabel", in.name_field_label);
+  dict.Set("defaultPath", in.default_path);
+  dict.Set("filters", in.filters);
+  dict.Set("showsTagField", in.shows_tag_field);
+  dict.Set("securityScopedBookmarks", in.security_scoped_bookmarks);
+
+  return gin::ConvertToV8(isolate, dict);
+}
+
+}  // namespace gin
diff --git a/libcef/renderer/embed/shell/common/gin_converters/file_dialog_converter.h b/libcef/renderer/embed/shell/common/gin_converters/file_dialog_converter.h
new file mode 100644
index 000000000..c3e608425
--- /dev/null
+++ b/libcef/renderer/embed/shell/common/gin_converters/file_dialog_converter.h
@@ -0,0 +1,33 @@
+// Copyright (c) 2019 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#ifndef ELECTRON_SHELL_COMMON_GIN_CONVERTERS_FILE_DIALOG_CONVERTER_H_
+#define ELECTRON_SHELL_COMMON_GIN_CONVERTERS_FILE_DIALOG_CONVERTER_H_
+
+#include "gin/converter.h"
+#include "shell/browser/ui/file_dialog.h"
+
+namespace gin {
+
+template <>
+struct Converter<file_dialog::Filter> {
+  static v8::Local<v8::Value> ToV8(v8::Isolate* isolate,
+                                   const file_dialog::Filter& in);
+  static bool FromV8(v8::Isolate* isolate,
+                     v8::Local<v8::Value> val,
+                     file_dialog::Filter* out);
+};
+
+template <>
+struct Converter<file_dialog::DialogSettings> {
+  static v8::Local<v8::Value> ToV8(v8::Isolate* isolate,
+                                   const file_dialog::DialogSettings& in);
+  static bool FromV8(v8::Isolate* isolate,
+                     v8::Local<v8::Value> val,
+                     file_dialog::DialogSettings* out);
+};
+
+}  // namespace gin
+
+#endif  // ELECTRON_SHELL_COMMON_GIN_CONVERTERS_FILE_DIALOG_CONVERTER_H_
diff --git a/libcef/renderer/embed/shell/common/gin_converters/file_path_converter.h b/libcef/renderer/embed/shell/common/gin_converters/file_path_converter.h
new file mode 100644
index 000000000..2341ff599
--- /dev/null
+++ b/libcef/renderer/embed/shell/common/gin_converters/file_path_converter.h
@@ -0,0 +1,44 @@
+// Copyright (c) 2019 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#ifndef ELECTRON_SHELL_COMMON_GIN_CONVERTERS_FILE_PATH_CONVERTER_H_
+#define ELECTRON_SHELL_COMMON_GIN_CONVERTERS_FILE_PATH_CONVERTER_H_
+
+#include "base/files/file_path.h"
+#include "gin/converter.h"
+#include "shell/common/gin_converters/std_converter.h"
+
+namespace gin {
+
+template <>
+struct Converter<base::FilePath> {
+  static v8::Local<v8::Value> ToV8(v8::Isolate* isolate,
+                                   const base::FilePath& val) {
+    return Converter<base::FilePath::StringType>::ToV8(isolate, val.value());
+  }
+  static bool FromV8(v8::Isolate* isolate,
+                     v8::Local<v8::Value> val,
+                     base::FilePath* out) {
+    if (val->IsNull())
+      return true;
+
+    v8::String::Value str(isolate, val);
+    if (str.length() == 0) {
+      *out = base::FilePath();
+      return true;
+    }
+
+    base::FilePath::StringType path;
+    if (Converter<base::FilePath::StringType>::FromV8(isolate, val, &path)) {
+      *out = base::FilePath(path);
+      return true;
+    } else {
+      return false;
+    }
+  }
+};
+
+}  // namespace gin
+
+#endif  // ELECTRON_SHELL_COMMON_GIN_CONVERTERS_FILE_PATH_CONVERTER_H_
diff --git a/libcef/renderer/embed/shell/common/gin_converters/frame_converter.cc b/libcef/renderer/embed/shell/common/gin_converters/frame_converter.cc
new file mode 100644
index 000000000..6be7d3b68
--- /dev/null
+++ b/libcef/renderer/embed/shell/common/gin_converters/frame_converter.cc
@@ -0,0 +1,89 @@
+// Copyright (c) 2020 Samuel Maddock <sam@samuelmaddock.com>.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#include "shell/common/gin_converters/frame_converter.h"
+
+#include "content/public/browser/render_frame_host.h"
+#include "content/public/browser/render_process_host.h"
+#include "shell/browser/api/electron_api_web_frame_main.h"
+#include "shell/common/gin_helper/accessor.h"
+
+namespace gin {
+
+namespace {
+
+v8::Persistent<v8::ObjectTemplate> rfh_templ;
+
+}  // namespace
+
+// static
+v8::Local<v8::Value> Converter<content::RenderFrameHost*>::ToV8(
+    v8::Isolate* isolate,
+    content::RenderFrameHost* val) {
+  if (!val)
+    return v8::Null(isolate);
+  return electron::api::WebFrameMain::From(isolate, val).ToV8();
+}
+
+// static
+v8::Local<v8::Value>
+Converter<gin_helper::AccessorValue<content::RenderFrameHost*>>::ToV8(
+    v8::Isolate* isolate,
+    gin_helper::AccessorValue<content::RenderFrameHost*> val) {
+  content::RenderFrameHost* rfh = val.Value;
+  if (!rfh)
+    return v8::Null(isolate);
+
+  const int process_id = rfh->GetProcess()->GetID();
+  const int routing_id = rfh->GetRoutingID();
+
+  if (rfh_templ.IsEmpty()) {
+    v8::EscapableHandleScope inner(isolate);
+    v8::Local<v8::ObjectTemplate> local = v8::ObjectTemplate::New(isolate);
+    local->SetInternalFieldCount(2);
+    rfh_templ.Reset(isolate, inner.Escape(local));
+  }
+
+  v8::Local<v8::Object> rfh_obj =
+      v8::Local<v8::ObjectTemplate>::New(isolate, rfh_templ)
+          ->NewInstance(isolate->GetCurrentContext())
+          .ToLocalChecked();
+
+  rfh_obj->SetInternalField(0, v8::Number::New(isolate, process_id));
+  rfh_obj->SetInternalField(1, v8::Number::New(isolate, routing_id));
+
+  return rfh_obj;
+}
+
+// static
+bool Converter<gin_helper::AccessorValue<content::RenderFrameHost*>>::FromV8(
+    v8::Isolate* isolate,
+    v8::Local<v8::Value> val,
+    gin_helper::AccessorValue<content::RenderFrameHost*>* out) {
+  v8::Local<v8::Object> rfh_obj;
+  if (!ConvertFromV8(isolate, val, &rfh_obj))
+    return false;
+
+  if (rfh_obj->InternalFieldCount() != 2)
+    return false;
+
+  v8::Local<v8::Value> process_id_wrapper = rfh_obj->GetInternalField(0);
+  v8::Local<v8::Value> routing_id_wrapper = rfh_obj->GetInternalField(1);
+
+  if (process_id_wrapper.IsEmpty() || !process_id_wrapper->IsNumber() ||
+      routing_id_wrapper.IsEmpty() || !routing_id_wrapper->IsNumber())
+    return false;
+
+  const int process_id = process_id_wrapper.As<v8::Number>()->Value();
+  const int routing_id = routing_id_wrapper.As<v8::Number>()->Value();
+
+  auto* rfh = content::RenderFrameHost::FromID(process_id, routing_id);
+  if (!rfh)
+    return false;
+
+  out->Value = rfh;
+  return true;
+}
+
+}  // namespace gin
diff --git a/libcef/renderer/embed/shell/common/gin_converters/frame_converter.h b/libcef/renderer/embed/shell/common/gin_converters/frame_converter.h
new file mode 100644
index 000000000..56f87f598
--- /dev/null
+++ b/libcef/renderer/embed/shell/common/gin_converters/frame_converter.h
@@ -0,0 +1,35 @@
+// Copyright (c) 2020 Samuel Maddock <sam@samuelmaddock.com>.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#ifndef ELECTRON_SHELL_COMMON_GIN_CONVERTERS_FRAME_CONVERTER_H_
+#define ELECTRON_SHELL_COMMON_GIN_CONVERTERS_FRAME_CONVERTER_H_
+
+#include "gin/converter.h"
+#include "shell/common/gin_helper/accessor.h"
+
+namespace content {
+class RenderFrameHost;
+}
+
+namespace gin {
+
+template <>
+struct Converter<content::RenderFrameHost*> {
+  static v8::Local<v8::Value> ToV8(v8::Isolate* isolate,
+                                   content::RenderFrameHost* val);
+};
+
+template <>
+struct Converter<gin_helper::AccessorValue<content::RenderFrameHost*>> {
+  static v8::Local<v8::Value> ToV8(
+      v8::Isolate* isolate,
+      gin_helper::AccessorValue<content::RenderFrameHost*> val);
+  static bool FromV8(v8::Isolate* isolate,
+                     v8::Local<v8::Value> val,
+                     gin_helper::AccessorValue<content::RenderFrameHost*>* out);
+};
+
+}  // namespace gin
+
+#endif  // ELECTRON_SHELL_COMMON_GIN_CONVERTERS_FRAME_CONVERTER_H_
diff --git a/libcef/renderer/embed/shell/common/gin_converters/gfx_converter.cc b/libcef/renderer/embed/shell/common/gin_converters/gfx_converter.cc
new file mode 100644
index 000000000..23c7d8738
--- /dev/null
+++ b/libcef/renderer/embed/shell/common/gin_converters/gfx_converter.cc
@@ -0,0 +1,189 @@
+// Copyright (c) 2019 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#include "shell/common/gin_converters/gfx_converter.h"
+
+#include "shell/common/gin_helper/dictionary.h"
+#include "ui/display/display.h"
+#include "ui/display/screen.h"
+#include "ui/gfx/geometry/point.h"
+#include "ui/gfx/geometry/point_f.h"
+#include "ui/gfx/geometry/rect.h"
+#include "ui/gfx/geometry/resize_utils.h"
+#include "ui/gfx/geometry/size.h"
+
+namespace gin {
+
+v8::Local<v8::Value> Converter<gfx::Point>::ToV8(v8::Isolate* isolate,
+                                                 const gfx::Point& val) {
+  gin_helper::Dictionary dict = gin::Dictionary::CreateEmpty(isolate);
+  dict.SetHidden("simple", true);
+  dict.Set("x", val.x());
+  dict.Set("y", val.y());
+  return dict.GetHandle();
+}
+
+bool Converter<gfx::Point>::FromV8(v8::Isolate* isolate,
+                                   v8::Local<v8::Value> val,
+                                   gfx::Point* out) {
+  gin::Dictionary dict(isolate);
+  if (!gin::ConvertFromV8(isolate, val, &dict))
+    return false;
+  double x, y;
+  if (!dict.Get("x", &x) || !dict.Get("y", &y))
+    return false;
+  *out = gfx::Point(static_cast<int>(std::round(x)),
+                    static_cast<int>(std::round(y)));
+  return true;
+}
+
+v8::Local<v8::Value> Converter<gfx::PointF>::ToV8(v8::Isolate* isolate,
+                                                  const gfx::PointF& val) {
+  gin_helper::Dictionary dict = gin::Dictionary::CreateEmpty(isolate);
+  dict.SetHidden("simple", true);
+  dict.Set("x", val.x());
+  dict.Set("y", val.y());
+  return dict.GetHandle();
+}
+
+bool Converter<gfx::PointF>::FromV8(v8::Isolate* isolate,
+                                    v8::Local<v8::Value> val,
+                                    gfx::PointF* out) {
+  gin::Dictionary dict(isolate);
+  if (!gin::ConvertFromV8(isolate, val, &dict))
+    return false;
+  float x, y;
+  if (!dict.Get("x", &x) || !dict.Get("y", &y))
+    return false;
+  *out = gfx::PointF(x, y);
+  return true;
+}
+
+v8::Local<v8::Value> Converter<gfx::Size>::ToV8(v8::Isolate* isolate,
+                                                const gfx::Size& val) {
+  gin_helper::Dictionary dict = gin::Dictionary::CreateEmpty(isolate);
+  dict.SetHidden("simple", true);
+  dict.Set("width", val.width());
+  dict.Set("height", val.height());
+  return dict.GetHandle();
+}
+
+bool Converter<gfx::Size>::FromV8(v8::Isolate* isolate,
+                                  v8::Local<v8::Value> val,
+                                  gfx::Size* out) {
+  gin::Dictionary dict(isolate);
+  if (!gin::ConvertFromV8(isolate, val, &dict))
+    return false;
+  int width, height;
+  if (!dict.Get("width", &width) || !dict.Get("height", &height))
+    return false;
+  *out = gfx::Size(width, height);
+  return true;
+}
+
+v8::Local<v8::Value> Converter<gfx::Rect>::ToV8(v8::Isolate* isolate,
+                                                const gfx::Rect& val) {
+  gin_helper::Dictionary dict = gin::Dictionary::CreateEmpty(isolate);
+  dict.SetHidden("simple", true);
+  dict.Set("x", val.x());
+  dict.Set("y", val.y());
+  dict.Set("width", val.width());
+  dict.Set("height", val.height());
+  return dict.GetHandle();
+}
+
+bool Converter<gfx::Rect>::FromV8(v8::Isolate* isolate,
+                                  v8::Local<v8::Value> val,
+                                  gfx::Rect* out) {
+  gin::Dictionary dict(isolate);
+  if (!gin::ConvertFromV8(isolate, val, &dict))
+    return false;
+  int x, y, width, height;
+  if (!dict.Get("x", &x) || !dict.Get("y", &y) || !dict.Get("width", &width) ||
+      !dict.Get("height", &height))
+    return false;
+  *out = gfx::Rect(x, y, width, height);
+  return true;
+}
+
+template <>
+struct Converter<display::Display::AccelerometerSupport> {
+  static v8::Local<v8::Value> ToV8(
+      v8::Isolate* isolate,
+      const display::Display::AccelerometerSupport& val) {
+    switch (val) {
+      case display::Display::AccelerometerSupport::AVAILABLE:
+        return StringToV8(isolate, "available");
+      case display::Display::AccelerometerSupport::UNAVAILABLE:
+        return StringToV8(isolate, "unavailable");
+      default:
+        return StringToV8(isolate, "unknown");
+    }
+  }
+};
+
+template <>
+struct Converter<display::Display::TouchSupport> {
+  static v8::Local<v8::Value> ToV8(v8::Isolate* isolate,
+                                   const display::Display::TouchSupport& val) {
+    switch (val) {
+      case display::Display::TouchSupport::AVAILABLE:
+        return StringToV8(isolate, "available");
+      case display::Display::TouchSupport::UNAVAILABLE:
+        return StringToV8(isolate, "unavailable");
+      default:
+        return StringToV8(isolate, "unknown");
+    }
+  }
+};
+
+v8::Local<v8::Value> Converter<display::Display>::ToV8(
+    v8::Isolate* isolate,
+    const display::Display& val) {
+  gin_helper::Dictionary dict = gin::Dictionary::CreateEmpty(isolate);
+  dict.SetHidden("simple", true);
+  dict.Set("id", val.id());
+  dict.Set("bounds", val.bounds());
+  dict.Set("workArea", val.work_area());
+  dict.Set("accelerometerSupport", val.accelerometer_support());
+  dict.Set("monochrome", val.is_monochrome());
+  dict.Set("colorDepth", val.color_depth());
+  dict.Set("colorSpace", val.color_spaces().GetRasterColorSpace().ToString());
+  dict.Set("depthPerComponent", val.depth_per_component());
+  dict.Set("size", val.size());
+  dict.Set("displayFrequency", val.display_frequency());
+  dict.Set("workAreaSize", val.work_area_size());
+  dict.Set("scaleFactor", val.device_scale_factor());
+  dict.Set("rotation", val.RotationAsDegree());
+  dict.Set("internal", val.IsInternal());
+  dict.Set("touchSupport", val.touch_support());
+  return dict.GetHandle();
+}
+
+v8::Local<v8::Value> Converter<gfx::ResizeEdge>::ToV8(
+    v8::Isolate* isolate,
+    const gfx::ResizeEdge& val) {
+  switch (val) {
+    case gfx::ResizeEdge::kRight:
+      return StringToV8(isolate, "right");
+    case gfx::ResizeEdge::kBottom:
+      return StringToV8(isolate, "bottom");
+    case gfx::ResizeEdge::kTop:
+      return StringToV8(isolate, "top");
+    case gfx::ResizeEdge::kLeft:
+      return StringToV8(isolate, "left");
+    case gfx::ResizeEdge::kTopLeft:
+      return StringToV8(isolate, "top-left");
+    case gfx::ResizeEdge::kTopRight:
+      return StringToV8(isolate, "top-right");
+    case gfx::ResizeEdge::kBottomLeft:
+      return StringToV8(isolate, "bottom-left");
+    case gfx::ResizeEdge::kBottomRight:
+      return StringToV8(isolate, "bottom-right");
+    default:
+      return StringToV8(isolate, "unknown");
+  }
+}
+
+}  // namespace gin
diff --git a/libcef/renderer/embed/shell/common/gin_converters/gfx_converter.h b/libcef/renderer/embed/shell/common/gin_converters/gfx_converter.h
new file mode 100644
index 000000000..0bf444864
--- /dev/null
+++ b/libcef/renderer/embed/shell/common/gin_converters/gfx_converter.h
@@ -0,0 +1,74 @@
+// Copyright (c) 2019 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#ifndef ELECTRON_SHELL_COMMON_GIN_CONVERTERS_GFX_CONVERTER_H_
+#define ELECTRON_SHELL_COMMON_GIN_CONVERTERS_GFX_CONVERTER_H_
+
+#include "gin/converter.h"
+
+namespace display {
+class Display;
+}
+
+namespace gfx {
+class Point;
+class PointF;
+class Size;
+class Rect;
+enum class ResizeEdge;
+}  // namespace gfx
+
+namespace gin {
+
+template <>
+struct Converter<gfx::Point> {
+  static v8::Local<v8::Value> ToV8(v8::Isolate* isolate, const gfx::Point& val);
+  static bool FromV8(v8::Isolate* isolate,
+                     v8::Local<v8::Value> val,
+                     gfx::Point* out);
+};
+
+template <>
+struct Converter<gfx::PointF> {
+  static v8::Local<v8::Value> ToV8(v8::Isolate* isolate,
+                                   const gfx::PointF& val);
+  static bool FromV8(v8::Isolate* isolate,
+                     v8::Local<v8::Value> val,
+                     gfx::PointF* out);
+};
+
+template <>
+struct Converter<gfx::Size> {
+  static v8::Local<v8::Value> ToV8(v8::Isolate* isolate, const gfx::Size& val);
+  static bool FromV8(v8::Isolate* isolate,
+                     v8::Local<v8::Value> val,
+                     gfx::Size* out);
+};
+
+template <>
+struct Converter<gfx::Rect> {
+  static v8::Local<v8::Value> ToV8(v8::Isolate* isolate, const gfx::Rect& val);
+  static bool FromV8(v8::Isolate* isolate,
+                     v8::Local<v8::Value> val,
+                     gfx::Rect* out);
+};
+
+template <>
+struct Converter<display::Display> {
+  static v8::Local<v8::Value> ToV8(v8::Isolate* isolate,
+                                   const display::Display& val);
+  static bool FromV8(v8::Isolate* isolate,
+                     v8::Local<v8::Value> val,
+                     display::Display* out);
+};
+
+template <>
+struct Converter<gfx::ResizeEdge> {
+  static v8::Local<v8::Value> ToV8(v8::Isolate* isolate,
+                                   const gfx::ResizeEdge& val);
+};
+
+}  // namespace gin
+
+#endif  // ELECTRON_SHELL_COMMON_GIN_CONVERTERS_GFX_CONVERTER_H_
diff --git a/libcef/renderer/embed/shell/common/gin_converters/guid_converter.h b/libcef/renderer/embed/shell/common/gin_converters/guid_converter.h
new file mode 100644
index 000000000..592dab149
--- /dev/null
+++ b/libcef/renderer/embed/shell/common/gin_converters/guid_converter.h
@@ -0,0 +1,86 @@
+// Copyright (c) 2020 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#ifndef ELECTRON_SHELL_COMMON_GIN_CONVERTERS_GUID_CONVERTER_H_
+#define ELECTRON_SHELL_COMMON_GIN_CONVERTERS_GUID_CONVERTER_H_
+
+#include <string>
+
+#include "gin/converter.h"
+
+#if defined(OS_WIN)
+// c.f.:
+// https://chromium-review.googlesource.com/c/chromium/src/+/3076480
+// REFGUID is currently incorrectly inheriting its type
+// from base::GUID, when it should be inheriting from ::GUID.
+// This workaround prevents build errors until the CL is merged
+#ifdef _REFGUID_DEFINED
+#undef REFGUID
+#endif
+#define REFGUID const ::GUID&
+#define _REFGUID_DEFINED
+
+#include <rpc.h>
+
+#include "base/strings/sys_string_conversions.h"
+#include "base/win/win_util.h"
+#endif
+
+#if defined(OS_WIN)
+typedef GUID UUID;
+#else
+typedef struct {
+} UUID;
+#endif
+
+namespace gin {
+
+template <>
+struct Converter<UUID> {
+  static bool FromV8(v8::Isolate* isolate,
+                     v8::Local<v8::Value> val,
+                     UUID* out) {
+#if defined(OS_WIN)
+    std::string guid;
+    if (!gin::ConvertFromV8(isolate, val, &guid))
+      return false;
+
+    UUID uid;
+
+    if (!guid.empty()) {
+      if (guid[0] == '{' && guid[guid.length() - 1] == '}') {
+        guid = guid.substr(1, guid.length() - 2);
+      }
+      unsigned char* uid_cstr = (unsigned char*)guid.c_str();
+      RPC_STATUS result = UuidFromStringA(uid_cstr, &uid);
+      if (result == RPC_S_INVALID_STRING_UUID) {
+        return false;
+      } else {
+        *out = uid;
+        return true;
+      }
+    }
+    return false;
+#else
+    return false;
+#endif
+  }
+  static v8::Local<v8::Value> ToV8(v8::Isolate* isolate, UUID val) {
+#if defined(OS_WIN)
+    const GUID GUID_NULL = {};
+    if (val == GUID_NULL) {
+      return StringToV8(isolate, "");
+    } else {
+      std::wstring uid = base::win::WStringFromGUID(val);
+      return StringToV8(isolate, base::SysWideToUTF8(uid));
+    }
+#else
+    return v8::Undefined(isolate);
+#endif
+  }
+};
+
+}  // namespace gin
+
+#endif  // ELECTRON_SHELL_COMMON_GIN_CONVERTERS_GUID_CONVERTER_H_
diff --git a/libcef/renderer/embed/shell/common/gin_converters/gurl_converter.h b/libcef/renderer/embed/shell/common/gin_converters/gurl_converter.h
new file mode 100644
index 000000000..c63aca14d
--- /dev/null
+++ b/libcef/renderer/embed/shell/common/gin_converters/gurl_converter.h
@@ -0,0 +1,35 @@
+// Copyright (c) 2019 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#ifndef ELECTRON_SHELL_COMMON_GIN_CONVERTERS_GURL_CONVERTER_H_
+#define ELECTRON_SHELL_COMMON_GIN_CONVERTERS_GURL_CONVERTER_H_
+
+#include <string>
+
+#include "gin/converter.h"
+#include "url/gurl.h"
+
+namespace gin {
+
+template <>
+struct Converter<GURL> {
+  static v8::Local<v8::Value> ToV8(v8::Isolate* isolate, const GURL& val) {
+    return ConvertToV8(isolate, val.spec());
+  }
+  static bool FromV8(v8::Isolate* isolate,
+                     v8::Local<v8::Value> val,
+                     GURL* out) {
+    std::string url;
+    if (Converter<std::string>::FromV8(isolate, val, &url)) {
+      *out = GURL(url);
+      return true;
+    } else {
+      return false;
+    }
+  }
+};
+
+}  // namespace gin
+
+#endif  // ELECTRON_SHELL_COMMON_GIN_CONVERTERS_GURL_CONVERTER_H_
diff --git a/libcef/renderer/embed/shell/common/gin_converters/image_converter.cc b/libcef/renderer/embed/shell/common/gin_converters/image_converter.cc
new file mode 100644
index 000000000..0241d7bbf
--- /dev/null
+++ b/libcef/renderer/embed/shell/common/gin_converters/image_converter.cc
@@ -0,0 +1,54 @@
+// Copyright (c) 2019 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#include "shell/common/gin_converters/image_converter.h"
+
+#include "shell/common/api/electron_api_native_image.h"
+#include "shell/common/gin_converters/file_path_converter.h"
+#include "ui/gfx/image/image_skia.h"
+
+namespace gin {
+
+bool Converter<gfx::ImageSkia>::FromV8(v8::Isolate* isolate,
+                                       v8::Local<v8::Value> val,
+                                       gfx::ImageSkia* out) {
+  gfx::Image image;
+  if (!ConvertFromV8(isolate, val, &image))
+    return false;
+
+  *out = image.AsImageSkia();
+  return true;
+}
+
+bool Converter<gfx::Image>::FromV8(v8::Isolate* isolate,
+                                   v8::Local<v8::Value> val,
+                                   gfx::Image* out) {
+  if (val->IsNull())
+    return true;
+
+  // First see if the user has passed a path.
+  electron::api::NativeImage* native_image = nullptr;
+  base::FilePath icon_path;
+  if (gin::ConvertFromV8(isolate, val, &icon_path)) {
+    native_image =
+        electron::api::NativeImage::CreateFromPath(isolate, icon_path).get();
+    if (native_image->image().IsEmpty())
+      return false;
+  } else {
+    // Try a normal nativeImage if that fails.
+    if (!gin::ConvertFromV8(isolate, val, &native_image))
+      return false;
+  }
+
+  *out = native_image->image();
+  return true;
+}
+
+v8::Local<v8::Value> Converter<gfx::Image>::ToV8(v8::Isolate* isolate,
+                                                 const gfx::Image& val) {
+  return gin::ConvertToV8(isolate,
+                          electron::api::NativeImage::Create(isolate, val));
+}
+
+}  // namespace gin
diff --git a/libcef/renderer/embed/shell/common/gin_converters/image_converter.h b/libcef/renderer/embed/shell/common/gin_converters/image_converter.h
new file mode 100644
index 000000000..01975e812
--- /dev/null
+++ b/libcef/renderer/embed/shell/common/gin_converters/image_converter.h
@@ -0,0 +1,34 @@
+// Copyright (c) 2019 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#ifndef ELECTRON_SHELL_COMMON_GIN_CONVERTERS_IMAGE_CONVERTER_H_
+#define ELECTRON_SHELL_COMMON_GIN_CONVERTERS_IMAGE_CONVERTER_H_
+
+#include "gin/converter.h"
+
+namespace gfx {
+class Image;
+class ImageSkia;
+}  // namespace gfx
+
+namespace gin {
+
+template <>
+struct Converter<gfx::ImageSkia> {
+  static bool FromV8(v8::Isolate* isolate,
+                     v8::Local<v8::Value> val,
+                     gfx::ImageSkia* out);
+};
+
+template <>
+struct Converter<gfx::Image> {
+  static bool FromV8(v8::Isolate* isolate,
+                     v8::Local<v8::Value> val,
+                     gfx::Image* out);
+  static v8::Local<v8::Value> ToV8(v8::Isolate* isolate, const gfx::Image& val);
+};
+
+}  // namespace gin
+
+#endif  // ELECTRON_SHELL_COMMON_GIN_CONVERTERS_IMAGE_CONVERTER_H_
diff --git a/libcef/renderer/embed/shell/common/gin_converters/message_box_converter.cc b/libcef/renderer/embed/shell/common/gin_converters/message_box_converter.cc
new file mode 100644
index 000000000..0cda21800
--- /dev/null
+++ b/libcef/renderer/embed/shell/common/gin_converters/message_box_converter.cc
@@ -0,0 +1,39 @@
+// Copyright (c) 2019 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#include "shell/common/gin_converters/message_box_converter.h"
+
+#include "shell/common/gin_converters/image_converter.h"
+#include "shell/common/gin_converters/native_window_converter.h"
+#include "shell/common/gin_helper/dictionary.h"
+
+namespace gin {
+
+bool Converter<electron::MessageBoxSettings>::FromV8(
+    v8::Isolate* isolate,
+    v8::Local<v8::Value> val,
+    electron::MessageBoxSettings* out) {
+  gin_helper::Dictionary dict;
+  int type = 0;
+  if (!ConvertFromV8(isolate, val, &dict))
+    return false;
+  dict.Get("window", &out->parent_window);
+  dict.Get("messageBoxType", &type);
+  out->type = static_cast<electron::MessageBoxType>(type);
+  dict.Get("buttons", &out->buttons);
+  dict.GetOptional("id", &out->id);
+  dict.Get("defaultId", &out->default_id);
+  dict.Get("cancelId", &out->cancel_id);
+  dict.Get("title", &out->title);
+  dict.Get("message", &out->message);
+  dict.Get("detail", &out->detail);
+  dict.Get("checkboxLabel", &out->checkbox_label);
+  dict.Get("noLink", &out->no_link);
+  dict.Get("checkboxChecked", &out->checkbox_checked);
+  dict.Get("icon", &out->icon);
+  dict.Get("textWidth", &out->text_width);
+  return true;
+}
+
+}  // namespace gin
diff --git a/libcef/renderer/embed/shell/common/gin_converters/message_box_converter.h b/libcef/renderer/embed/shell/common/gin_converters/message_box_converter.h
new file mode 100644
index 000000000..2949b1cfa
--- /dev/null
+++ b/libcef/renderer/embed/shell/common/gin_converters/message_box_converter.h
@@ -0,0 +1,22 @@
+// Copyright (c) 2019 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#ifndef ELECTRON_SHELL_COMMON_GIN_CONVERTERS_MESSAGE_BOX_CONVERTER_H_
+#define ELECTRON_SHELL_COMMON_GIN_CONVERTERS_MESSAGE_BOX_CONVERTER_H_
+
+#include "gin/converter.h"
+#include "shell/browser/ui/message_box.h"
+
+namespace gin {
+
+template <>
+struct Converter<electron::MessageBoxSettings> {
+  static bool FromV8(v8::Isolate* isolate,
+                     v8::Local<v8::Value> val,
+                     electron::MessageBoxSettings* out);
+};
+
+}  // namespace gin
+
+#endif  // ELECTRON_SHELL_COMMON_GIN_CONVERTERS_MESSAGE_BOX_CONVERTER_H_
diff --git a/libcef/renderer/embed/shell/common/gin_converters/native_window_converter.h b/libcef/renderer/embed/shell/common/gin_converters/native_window_converter.h
new file mode 100644
index 000000000..106ca836c
--- /dev/null
+++ b/libcef/renderer/embed/shell/common/gin_converters/native_window_converter.h
@@ -0,0 +1,35 @@
+// Copyright (c) 2019 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#ifndef ELECTRON_SHELL_COMMON_GIN_CONVERTERS_NATIVE_WINDOW_CONVERTER_H_
+#define ELECTRON_SHELL_COMMON_GIN_CONVERTERS_NATIVE_WINDOW_CONVERTER_H_
+
+#include "gin/converter.h"
+#include "shell/browser/api/electron_api_base_window.h"
+
+namespace gin {
+
+template <>
+struct Converter<electron::NativeWindow*> {
+  static bool FromV8(v8::Isolate* isolate,
+                     v8::Local<v8::Value> val,
+                     electron::NativeWindow** out) {
+    // null would be transferred to NULL.
+    if (val->IsNull()) {
+      *out = NULL;
+      return true;
+    }
+
+    electron::api::BaseWindow* window;
+    if (!gin::Converter<electron::api::BaseWindow*>::FromV8(isolate, val,
+                                                            &window))
+      return false;
+    *out = window->window();
+    return true;
+  }
+};
+
+}  // namespace gin
+
+#endif  // ELECTRON_SHELL_COMMON_GIN_CONVERTERS_NATIVE_WINDOW_CONVERTER_H_
diff --git a/libcef/renderer/embed/shell/common/gin_converters/net_converter.cc b/libcef/renderer/embed/shell/common/gin_converters/net_converter.cc
new file mode 100644
index 000000000..27cee52ef
--- /dev/null
+++ b/libcef/renderer/embed/shell/common/gin_converters/net_converter.cc
@@ -0,0 +1,408 @@
+// Copyright (c) 2019 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#include "shell/common/gin_converters/net_converter.h"
+
+#include <memory>
+#include <string>
+#include <utility>
+#include <vector>
+
+#include "base/containers/span.h"
+#include "base/strings/string_number_conversions.h"
+#include "base/strings/string_util.h"
+#include "base/values.h"
+#include "gin/converter.h"
+#include "gin/dictionary.h"
+#include "net/cert/x509_certificate.h"
+#include "net/cert/x509_util.h"
+#include "net/http/http_response_headers.h"
+#include "net/http/http_version.h"
+#include "net/url_request/redirect_info.h"
+#include "services/network/public/cpp/resource_request.h"
+#include "shell/browser/api/electron_api_data_pipe_holder.h"
+#include "shell/common/gin_converters/gurl_converter.h"
+#include "shell/common/gin_converters/std_converter.h"
+#include "shell/common/gin_converters/value_converter.h"
+#include "shell/common/node_includes.h"
+
+namespace gin {
+
+namespace {
+
+bool CertFromData(const std::string& data,
+                  scoped_refptr<net::X509Certificate>* out) {
+  auto cert_list = net::X509Certificate::CreateCertificateListFromBytes(
+      base::as_bytes(base::make_span(data)),
+      net::X509Certificate::FORMAT_SINGLE_CERTIFICATE);
+  if (cert_list.empty())
+    return false;
+
+  auto leaf_cert = cert_list.front();
+  if (!leaf_cert)
+    return false;
+
+  *out = leaf_cert;
+
+  return true;
+}
+
+}  // namespace
+
+// static
+v8::Local<v8::Value> Converter<net::AuthChallengeInfo>::ToV8(
+    v8::Isolate* isolate,
+    const net::AuthChallengeInfo& val) {
+  gin::Dictionary dict = gin::Dictionary::CreateEmpty(isolate);
+  dict.Set("isProxy", val.is_proxy);
+  dict.Set("scheme", val.scheme);
+  dict.Set("host", val.challenger.host());
+  dict.Set("port", static_cast<uint32_t>(val.challenger.port()));
+  dict.Set("realm", val.realm);
+  return gin::ConvertToV8(isolate, dict);
+}
+
+// static
+v8::Local<v8::Value> Converter<scoped_refptr<net::X509Certificate>>::ToV8(
+    v8::Isolate* isolate,
+    const scoped_refptr<net::X509Certificate>& val) {
+  gin::Dictionary dict(isolate, v8::Object::New(isolate));
+  std::string encoded_data;
+  net::X509Certificate::GetPEMEncoded(val->cert_buffer(), &encoded_data);
+
+  dict.Set("data", encoded_data);
+  dict.Set("issuer", val->issuer());
+  dict.Set("issuerName", val->issuer().GetDisplayName());
+  dict.Set("subject", val->subject());
+  dict.Set("subjectName", val->subject().GetDisplayName());
+  dict.Set("serialNumber", base::HexEncode(val->serial_number().data(),
+                                           val->serial_number().size()));
+  dict.Set("validStart", val->valid_start().ToDoubleT());
+  dict.Set("validExpiry", val->valid_expiry().ToDoubleT());
+  dict.Set("fingerprint",
+           net::HashValue(val->CalculateFingerprint256(val->cert_buffer()))
+               .ToString());
+
+  const auto& intermediate_buffers = val->intermediate_buffers();
+  if (!intermediate_buffers.empty()) {
+    std::vector<bssl::UniquePtr<CRYPTO_BUFFER>> issuer_intermediates;
+    issuer_intermediates.reserve(intermediate_buffers.size() - 1);
+    for (size_t i = 1; i < intermediate_buffers.size(); ++i) {
+      issuer_intermediates.push_back(
+          bssl::UpRef(intermediate_buffers[i].get()));
+    }
+    const scoped_refptr<net::X509Certificate>& issuer_cert =
+        net::X509Certificate::CreateFromBuffer(
+            bssl::UpRef(intermediate_buffers[0].get()),
+            std::move(issuer_intermediates));
+    dict.Set("issuerCert", issuer_cert);
+  }
+
+  return ConvertToV8(isolate, dict);
+}
+
+bool Converter<scoped_refptr<net::X509Certificate>>::FromV8(
+    v8::Isolate* isolate,
+    v8::Local<v8::Value> val,
+    scoped_refptr<net::X509Certificate>* out) {
+  gin::Dictionary dict(nullptr);
+  if (!ConvertFromV8(isolate, val, &dict))
+    return false;
+
+  std::string data;
+  dict.Get("data", &data);
+  scoped_refptr<net::X509Certificate> leaf_cert;
+  if (!CertFromData(data, &leaf_cert))
+    return false;
+
+  scoped_refptr<net::X509Certificate> issuer_cert;
+  if (dict.Get("issuerCert", &issuer_cert)) {
+    std::vector<bssl::UniquePtr<CRYPTO_BUFFER>> intermediates;
+    intermediates.push_back(bssl::UpRef(issuer_cert->cert_buffer()));
+    auto cert = net::X509Certificate::CreateFromBuffer(
+        bssl::UpRef(leaf_cert->cert_buffer()), std::move(intermediates));
+    if (!cert)
+      return false;
+
+    *out = cert;
+  } else {
+    *out = leaf_cert;
+  }
+
+  return true;
+}
+
+// static
+v8::Local<v8::Value> Converter<net::CertPrincipal>::ToV8(
+    v8::Isolate* isolate,
+    const net::CertPrincipal& val) {
+  gin::Dictionary dict(isolate, v8::Object::New(isolate));
+
+  dict.Set("commonName", val.common_name);
+  dict.Set("organizations", val.organization_names);
+  dict.Set("organizationUnits", val.organization_unit_names);
+  dict.Set("locality", val.locality_name);
+  dict.Set("state", val.state_or_province_name);
+  dict.Set("country", val.country_name);
+
+  return ConvertToV8(isolate, dict);
+}
+
+// static
+v8::Local<v8::Value> Converter<net::HttpResponseHeaders*>::ToV8(
+    v8::Isolate* isolate,
+    net::HttpResponseHeaders* headers) {
+  base::DictionaryValue response_headers;
+  if (headers) {
+    size_t iter = 0;
+    std::string key;
+    std::string value;
+    while (headers->EnumerateHeaderLines(&iter, &key, &value)) {
+      key = base::ToLowerASCII(key);
+      base::Value* values = response_headers.FindListKey(key);
+      if (!values)
+        values = response_headers.SetKey(key, base::ListValue());
+      values->Append(value);
+    }
+  }
+  return ConvertToV8(isolate, response_headers);
+}
+
+bool Converter<net::HttpResponseHeaders*>::FromV8(
+    v8::Isolate* isolate,
+    v8::Local<v8::Value> val,
+    net::HttpResponseHeaders* out) {
+  if (!val->IsObject()) {
+    return false;
+  }
+
+  auto addHeaderFromValue = [&isolate, &out](
+                                const std::string& key,
+                                const v8::Local<v8::Value>& localVal) {
+    auto context = isolate->GetCurrentContext();
+    v8::Local<v8::String> localStrVal;
+    if (!localVal->ToString(context).ToLocal(&localStrVal)) {
+      return false;
+    }
+    std::string value;
+    gin::ConvertFromV8(isolate, localStrVal, &value);
+    out->AddHeader(key, value);
+    return true;
+  };
+
+  auto context = isolate->GetCurrentContext();
+  auto headers = val.As<v8::Object>();
+  auto keys = headers->GetOwnPropertyNames(context).ToLocalChecked();
+  for (uint32_t i = 0; i < keys->Length(); i++) {
+    v8::Local<v8::Value> keyVal;
+    if (!keys->Get(context, i).ToLocal(&keyVal)) {
+      return false;
+    }
+    std::string key;
+    gin::ConvertFromV8(isolate, keyVal, &key);
+
+    auto localVal = headers->Get(context, keyVal).ToLocalChecked();
+    if (localVal->IsArray()) {
+      auto values = localVal.As<v8::Array>();
+      for (uint32_t j = 0; j < values->Length(); j++) {
+        if (!addHeaderFromValue(key,
+                                values->Get(context, j).ToLocalChecked())) {
+          return false;
+        }
+      }
+    } else {
+      if (!addHeaderFromValue(key, localVal)) {
+        return false;
+      }
+    }
+  }
+  return true;
+}
+
+// static
+v8::Local<v8::Value> Converter<net::HttpRequestHeaders>::ToV8(
+    v8::Isolate* isolate,
+    const net::HttpRequestHeaders& val) {
+  gin::Dictionary headers(isolate, v8::Object::New(isolate));
+  for (net::HttpRequestHeaders::Iterator it(val); it.GetNext();)
+    headers.Set(it.name(), it.value());
+  return ConvertToV8(isolate, headers);
+}
+
+// static
+bool Converter<net::HttpRequestHeaders>::FromV8(v8::Isolate* isolate,
+                                                v8::Local<v8::Value> val,
+                                                net::HttpRequestHeaders* out) {
+  base::DictionaryValue dict;
+  if (!ConvertFromV8(isolate, val, &dict))
+    return false;
+  for (base::DictionaryValue::Iterator it(dict); !it.IsAtEnd(); it.Advance()) {
+    if (it.value().is_string()) {
+      std::string value = it.value().GetString();
+      out->SetHeader(it.key(), value);
+    }
+  }
+  return true;
+}
+
+// static
+v8::Local<v8::Value> Converter<network::ResourceRequestBody>::ToV8(
+    v8::Isolate* isolate,
+    const network::ResourceRequestBody& val) {
+  const auto& elements = *val.elements();
+  v8::Local<v8::Array> arr = v8::Array::New(isolate, elements.size());
+  for (size_t i = 0; i < elements.size(); ++i) {
+    const auto& element = elements[i];
+    gin::Dictionary upload_data(isolate, v8::Object::New(isolate));
+    switch (element.type()) {
+      case network::mojom::DataElement::Tag::kFile: {
+        const auto& element_file = element.As<network::DataElementFile>();
+        upload_data.Set("type", "file");
+        upload_data.Set("file", element_file.path().value());
+        upload_data.Set("filePath",
+                        base::Value(element_file.path().AsUTF8Unsafe()));
+        upload_data.Set("offset", static_cast<int>(element_file.offset()));
+        upload_data.Set("length", static_cast<int>(element_file.length()));
+        upload_data.Set("modificationTime",
+                        element_file.expected_modification_time().ToDoubleT());
+        break;
+      }
+      case network::mojom::DataElement::Tag::kBytes: {
+        upload_data.Set("type", "rawData");
+        const auto& bytes = element.As<network::DataElementBytes>().bytes();
+        const char* data = reinterpret_cast<const char*>(bytes.data());
+        upload_data.Set(
+            "bytes",
+            node::Buffer::Copy(isolate, data, bytes.size()).ToLocalChecked());
+        break;
+      }
+      case network::mojom::DataElement::Tag::kDataPipe: {
+        upload_data.Set("type", "blob");
+        // TODO(zcbenz): After the NetworkService refactor, the old blobUUID API
+        // becomes unnecessarily complex, we should deprecate the getBlobData
+        // API and return the DataPipeHolder wrapper directly.
+        auto holder = electron::api::DataPipeHolder::Create(isolate, element);
+        upload_data.Set("blobUUID", holder->id());
+        // The lifetime of data pipe is bound to the uploadData object.
+        upload_data.Set("dataPipe", holder);
+        break;
+      }
+      default:
+        NOTREACHED() << "Found unsupported data element";
+    }
+    arr->Set(isolate->GetCurrentContext(), static_cast<uint32_t>(i),
+             ConvertToV8(isolate, upload_data))
+        .Check();
+  }
+  return arr;
+}
+
+// static
+v8::Local<v8::Value>
+Converter<scoped_refptr<network::ResourceRequestBody>>::ToV8(
+    v8::Isolate* isolate,
+    const scoped_refptr<network::ResourceRequestBody>& val) {
+  if (!val)
+    return v8::Null(isolate);
+  return ConvertToV8(isolate, *val);
+}
+
+// static
+bool Converter<scoped_refptr<network::ResourceRequestBody>>::FromV8(
+    v8::Isolate* isolate,
+    v8::Local<v8::Value> val,
+    scoped_refptr<network::ResourceRequestBody>* out) {
+  auto list = std::make_unique<base::ListValue>();
+  if (!ConvertFromV8(isolate, val, list.get()))
+    return false;
+  *out = base::MakeRefCounted<network::ResourceRequestBody>();
+  for (size_t i = 0; i < list->GetList().size(); ++i) {
+    base::DictionaryValue* dict = nullptr;
+    std::string type;
+    if (!list->GetDictionary(i, &dict))
+      return false;
+    dict->GetString("type", &type);
+    if (type == "rawData") {
+      const base::Value::BlobStorage* bytes = dict->FindBlobKey("bytes");
+      (*out)->AppendBytes(reinterpret_cast<const char*>(bytes->data()),
+                          base::checked_cast<int>(bytes->size()));
+    } else if (type == "file") {
+      const std::string* file = dict->FindStringKey("filePath");
+      if (file == nullptr) {
+        return false;
+      }
+      int offset = 0, length = -1;
+      double modification_time = 0.0;
+      absl::optional<double> maybe_modification_time =
+          dict->FindDoubleKey("modificationTime");
+      if (maybe_modification_time.has_value())
+        modification_time = maybe_modification_time.value();
+      dict->GetInteger("offset", &offset);
+      dict->GetInteger("file", &length);
+      (*out)->AppendFileRange(base::FilePath::FromUTF8Unsafe(*file),
+                              static_cast<uint64_t>(offset),
+                              static_cast<uint64_t>(length),
+                              base::Time::FromDoubleT(modification_time));
+    }
+  }
+  return true;
+}
+
+// static
+v8::Local<v8::Value> Converter<network::ResourceRequest>::ToV8(
+    v8::Isolate* isolate,
+    const network::ResourceRequest& val) {
+  gin::Dictionary dict = gin::Dictionary::CreateEmpty(isolate);
+  dict.Set("method", val.method);
+  dict.Set("url", val.url.spec());
+  dict.Set("referrer", val.referrer.spec());
+  dict.Set("headers", val.headers);
+  if (val.request_body)
+    dict.Set("uploadData", ConvertToV8(isolate, *val.request_body));
+  return ConvertToV8(isolate, dict);
+}
+
+// static
+v8::Local<v8::Value> Converter<electron::VerifyRequestParams>::ToV8(
+    v8::Isolate* isolate,
+    electron::VerifyRequestParams val) {
+  gin::Dictionary dict = gin::Dictionary::CreateEmpty(isolate);
+  dict.Set("hostname", val.hostname);
+  dict.Set("certificate", val.certificate);
+  dict.Set("validatedCertificate", val.validated_certificate);
+  dict.Set("isIssuedByKnownRoot", val.is_issued_by_known_root);
+  dict.Set("verificationResult", val.default_result);
+  dict.Set("errorCode", val.error_code);
+  return ConvertToV8(isolate, dict);
+}
+
+// static
+v8::Local<v8::Value> Converter<net::HttpVersion>::ToV8(
+    v8::Isolate* isolate,
+    const net::HttpVersion& val) {
+  gin::Dictionary dict = gin::Dictionary::CreateEmpty(isolate);
+  dict.Set("major", static_cast<uint32_t>(val.major_value()));
+  dict.Set("minor", static_cast<uint32_t>(val.minor_value()));
+  return ConvertToV8(isolate, dict);
+}
+
+// static
+v8::Local<v8::Value> Converter<net::RedirectInfo>::ToV8(
+    v8::Isolate* isolate,
+    const net::RedirectInfo& val) {
+  gin::Dictionary dict = gin::Dictionary::CreateEmpty(isolate);
+
+  dict.Set("statusCode", val.status_code);
+  dict.Set("newMethod", val.new_method);
+  dict.Set("newUrl", val.new_url);
+  dict.Set("newSiteForCookies", val.new_site_for_cookies.RepresentativeUrl());
+  dict.Set("newReferrer", val.new_referrer);
+  dict.Set("insecureSchemeWasUpgraded", val.insecure_scheme_was_upgraded);
+  dict.Set("isSignedExchangeFallbackRedirect",
+           val.is_signed_exchange_fallback_redirect);
+
+  return ConvertToV8(isolate, dict);
+}
+
+}  // namespace gin
diff --git a/libcef/renderer/embed/shell/common/gin_converters/net_converter.h b/libcef/renderer/embed/shell/common/gin_converters/net_converter.h
new file mode 100644
index 000000000..3a4fd1f3c
--- /dev/null
+++ b/libcef/renderer/embed/shell/common/gin_converters/net_converter.h
@@ -0,0 +1,143 @@
+// Copyright (c) 2019 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#ifndef ELECTRON_SHELL_COMMON_GIN_CONVERTERS_NET_CONVERTER_H_
+#define ELECTRON_SHELL_COMMON_GIN_CONVERTERS_NET_CONVERTER_H_
+
+#include <string>
+#include <utility>
+#include <vector>
+
+#include "gin/converter.h"
+#include "services/network/public/mojom/fetch_api.mojom.h"
+#include "services/network/public/mojom/url_request.mojom.h"
+#include "shell/browser/net/cert_verifier_client.h"
+
+namespace net {
+class AuthChallengeInfo;
+class X509Certificate;
+class HttpResponseHeaders;
+struct CertPrincipal;
+class HttpVersion;
+}  // namespace net
+
+namespace network {
+struct ResourceRequest;
+}
+
+namespace gin {
+
+template <>
+struct Converter<net::AuthChallengeInfo> {
+  static v8::Local<v8::Value> ToV8(v8::Isolate* isolate,
+                                   const net::AuthChallengeInfo& val);
+};
+
+template <>
+struct Converter<scoped_refptr<net::X509Certificate>> {
+  static v8::Local<v8::Value> ToV8(
+      v8::Isolate* isolate,
+      const scoped_refptr<net::X509Certificate>& val);
+
+  static bool FromV8(v8::Isolate* isolate,
+                     v8::Local<v8::Value> val,
+                     scoped_refptr<net::X509Certificate>* out);
+};
+
+template <>
+struct Converter<net::CertPrincipal> {
+  static v8::Local<v8::Value> ToV8(v8::Isolate* isolate,
+                                   const net::CertPrincipal& val);
+};
+
+template <>
+struct Converter<net::HttpResponseHeaders*> {
+  static v8::Local<v8::Value> ToV8(v8::Isolate* isolate,
+                                   net::HttpResponseHeaders* headers);
+  static bool FromV8(v8::Isolate* isolate,
+                     v8::Local<v8::Value> val,
+                     net::HttpResponseHeaders* out);
+};
+
+template <>
+struct Converter<net::HttpRequestHeaders> {
+  static v8::Local<v8::Value> ToV8(v8::Isolate* isolate,
+                                   const net::HttpRequestHeaders& headers);
+  static bool FromV8(v8::Isolate* isolate,
+                     v8::Local<v8::Value> val,
+                     net::HttpRequestHeaders* out);
+};
+
+template <>
+struct Converter<network::ResourceRequestBody> {
+  static v8::Local<v8::Value> ToV8(v8::Isolate* isolate,
+                                   const network::ResourceRequestBody& val);
+};
+
+template <>
+struct Converter<scoped_refptr<network::ResourceRequestBody>> {
+  static v8::Local<v8::Value> ToV8(
+      v8::Isolate* isolate,
+      const scoped_refptr<network::ResourceRequestBody>& val);
+  static bool FromV8(v8::Isolate* isolate,
+                     v8::Local<v8::Value> val,
+                     scoped_refptr<network::ResourceRequestBody>* out);
+};
+
+template <>
+struct Converter<network::ResourceRequest> {
+  static v8::Local<v8::Value> ToV8(v8::Isolate* isolate,
+                                   const network::ResourceRequest& val);
+};
+
+template <>
+struct Converter<electron::VerifyRequestParams> {
+  static v8::Local<v8::Value> ToV8(v8::Isolate* isolate,
+                                   electron::VerifyRequestParams val);
+};
+
+template <>
+struct Converter<net::HttpVersion> {
+  static v8::Local<v8::Value> ToV8(v8::Isolate* isolate,
+                                   const net::HttpVersion& val);
+};
+
+template <>
+struct Converter<net::RedirectInfo> {
+  static v8::Local<v8::Value> ToV8(v8::Isolate* isolate,
+                                   const net::RedirectInfo& val);
+};
+
+template <typename K, typename V>
+struct Converter<std::vector<std::pair<K, V>>> {
+  static bool FromV8(v8::Isolate* isolate,
+                     v8::Local<v8::Value> value,
+                     std::vector<std::pair<K, V>>* out) {
+    if (!value->IsObject())
+      return false;
+    out->clear();
+    v8::Local<v8::Context> context = isolate->GetCurrentContext();
+    v8::Local<v8::Object> obj = value.As<v8::Object>();
+    v8::Local<v8::Array> keys = obj->GetPropertyNames(context).ToLocalChecked();
+    for (uint32_t i = 0; i < keys->Length(); ++i) {
+      v8::Local<v8::Value> v8key;
+      if (!keys->Get(context, i).ToLocal(&v8key))
+        return false;
+      v8::Local<v8::Value> v8value;
+      if (!obj->Get(context, v8key).ToLocal(&v8value))
+        return false;
+      K key;
+      V value;
+      if (!ConvertFromV8(isolate, v8key, &key) ||
+          !ConvertFromV8(isolate, v8value, &value))
+        return false;
+      (*out).emplace_back(std::move(key), std::move(value));
+    }
+    return true;
+  }
+};
+
+}  // namespace gin
+
+#endif  // ELECTRON_SHELL_COMMON_GIN_CONVERTERS_NET_CONVERTER_H_
diff --git a/libcef/renderer/embed/shell/common/gin_converters/std_converter.h b/libcef/renderer/embed/shell/common/gin_converters/std_converter.h
new file mode 100644
index 000000000..23e44e856
--- /dev/null
+++ b/libcef/renderer/embed/shell/common/gin_converters/std_converter.h
@@ -0,0 +1,215 @@
+// Copyright (c) 2019 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#ifndef ELECTRON_SHELL_COMMON_GIN_CONVERTERS_STD_CONVERTER_H_
+#define ELECTRON_SHELL_COMMON_GIN_CONVERTERS_STD_CONVERTER_H_
+
+#include <map>
+#include <set>
+#include <utility>
+
+#include "gin/converter.h"
+
+#if defined(OS_WIN)
+#include "base/strings/string_util_win.h"
+#endif
+
+namespace gin {
+
+// Make it possible to convert move-only types.
+template <typename T>
+v8::Local<v8::Value> ConvertToV8(v8::Isolate* isolate, T&& input) {
+  return Converter<typename std::remove_reference<T>::type>::ToV8(
+      isolate, std::forward<T>(input));
+}
+
+#if !defined(OS_LINUX) && !defined(OS_FREEBSD)
+template <>
+struct Converter<unsigned long> {  // NOLINT(runtime/int)
+  static v8::Local<v8::Value> ToV8(v8::Isolate* isolate,
+                                   unsigned long val) {  // NOLINT(runtime/int)
+    return v8::Integer::New(isolate, val);
+  }
+  static bool FromV8(v8::Isolate* isolate,
+                     v8::Local<v8::Value> val,
+                     unsigned long* out) {  // NOLINT(runtime/int)
+    auto maybe = val->IntegerValue(isolate->GetCurrentContext());
+    if (maybe.IsNothing())
+      return false;
+    *out = maybe.FromJust();
+    return true;
+  }
+};
+#endif
+
+template <>
+struct Converter<std::nullptr_t> {
+  static v8::Local<v8::Value> ToV8(v8::Isolate* isolate, std::nullptr_t val) {
+    return v8::Null(isolate);
+  }
+};
+
+template <>
+struct Converter<const char*> {
+  static v8::Local<v8::Value> ToV8(v8::Isolate* isolate, const char* val) {
+    return v8::String::NewFromUtf8(isolate, val, v8::NewStringType::kNormal)
+        .ToLocalChecked();
+  }
+};
+
+template <>
+struct Converter<char[]> {
+  static v8::Local<v8::Value> ToV8(v8::Isolate* isolate, const char* val) {
+    return v8::String::NewFromUtf8(isolate, val, v8::NewStringType::kNormal)
+        .ToLocalChecked();
+  }
+};
+
+template <size_t n>
+struct Converter<char[n]> {
+  static v8::Local<v8::Value> ToV8(v8::Isolate* isolate, const char* val) {
+    return v8::String::NewFromUtf8(isolate, val, v8::NewStringType::kNormal,
+                                   n - 1)
+        .ToLocalChecked();
+  }
+};
+
+template <>
+struct Converter<v8::Local<v8::Array>> {
+  static v8::Local<v8::Value> ToV8(v8::Isolate* isolate,
+                                   v8::Local<v8::Array> val) {
+    return val;
+  }
+  static bool FromV8(v8::Isolate* isolate,
+                     v8::Local<v8::Value> val,
+                     v8::Local<v8::Array>* out) {
+    if (!val->IsArray())
+      return false;
+    *out = val.As<v8::Array>();
+    return true;
+  }
+};
+
+template <>
+struct Converter<v8::Local<v8::String>> {
+  static v8::Local<v8::Value> ToV8(v8::Isolate* isolate,
+                                   v8::Local<v8::String> val) {
+    return val;
+  }
+  static bool FromV8(v8::Isolate* isolate,
+                     v8::Local<v8::Value> val,
+                     v8::Local<v8::String>* out) {
+    if (!val->IsString())
+      return false;
+    *out = val.As<v8::String>();
+    return true;
+  }
+};
+
+template <typename T>
+struct Converter<std::set<T>> {
+  static v8::Local<v8::Value> ToV8(v8::Isolate* isolate,
+                                   const std::set<T>& val) {
+    v8::Local<v8::Array> result(
+        v8::Array::New(isolate, static_cast<int>(val.size())));
+    auto context = isolate->GetCurrentContext();
+    typename std::set<T>::const_iterator it;
+    int i;
+    for (i = 0, it = val.begin(); it != val.end(); ++it, ++i)
+      result->Set(context, i, Converter<T>::ToV8(isolate, *it)).Check();
+    return result;
+  }
+  static bool FromV8(v8::Isolate* isolate,
+                     v8::Local<v8::Value> val,
+                     std::set<T>* out) {
+    if (!val->IsArray())
+      return false;
+
+    auto context = isolate->GetCurrentContext();
+    std::set<T> result;
+    v8::Local<v8::Array> array = val.As<v8::Array>();
+    uint32_t length = array->Length();
+    for (uint32_t i = 0; i < length; ++i) {
+      T item;
+      if (!Converter<T>::FromV8(isolate,
+                                array->Get(context, i).ToLocalChecked(), &item))
+        return false;
+      result.insert(item);
+    }
+
+    out->swap(result);
+    return true;
+  }
+};
+
+template <typename K, typename V>
+struct Converter<std::map<K, V>> {
+  static bool FromV8(v8::Isolate* isolate,
+                     v8::Local<v8::Value> value,
+                     std::map<K, V>* out) {
+    if (!value->IsObject())
+      return false;
+    out->clear();
+    v8::Local<v8::Context> context = isolate->GetCurrentContext();
+    v8::Local<v8::Object> obj = value.As<v8::Object>();
+    v8::Local<v8::Array> keys = obj->GetPropertyNames(context).ToLocalChecked();
+    for (uint32_t i = 0; i < keys->Length(); ++i) {
+      v8::MaybeLocal<v8::Value> maybe_v8key = keys->Get(context, i);
+      if (maybe_v8key.IsEmpty())
+        return false;
+      v8::Local<v8::Value> v8key = maybe_v8key.ToLocalChecked();
+      v8::MaybeLocal<v8::Value> maybe_v8value = obj->Get(context, v8key);
+      if (maybe_v8value.IsEmpty())
+        return false;
+      K key;
+      V value;
+      if (!ConvertFromV8(isolate, v8key, &key) ||
+          !ConvertFromV8(isolate, maybe_v8value.ToLocalChecked(), &value))
+        return false;
+      (*out)[key] = std::move(value);
+    }
+    return true;
+  }
+
+  static v8::Local<v8::Value> ToV8(v8::Isolate* isolate,
+                                   const std::map<K, V>& dict) {
+    v8::Local<v8::Object> obj = v8::Object::New(isolate);
+    v8::Local<v8::Context> context = isolate->GetCurrentContext();
+    for (const auto& it : dict) {
+      if (obj->Set(context, ConvertToV8(isolate, it.first),
+                   ConvertToV8(isolate, it.second))
+              .IsNothing())
+        break;
+    }
+    return obj;
+  }
+};
+
+#if defined(OS_WIN)
+template <>
+struct Converter<std::wstring> {
+  static v8::Local<v8::Value> ToV8(v8::Isolate* isolate,
+                                   const std::wstring& val) {
+    return Converter<std::u16string>::ToV8(isolate, base::AsString16(val));
+  }
+  static bool FromV8(v8::Isolate* isolate,
+                     v8::Local<v8::Value> val,
+                     std::wstring* out) {
+    if (!val->IsString())
+      return false;
+
+    std::u16string str;
+    if (Converter<std::u16string>::FromV8(isolate, val, &str)) {
+      *out = base::AsWString(str);
+      return true;
+    } else {
+      return false;
+    }
+  }
+};
+#endif
+
+}  // namespace gin
+
+#endif  // ELECTRON_SHELL_COMMON_GIN_CONVERTERS_STD_CONVERTER_H_
diff --git a/libcef/renderer/embed/shell/common/gin_converters/time_converter.cc b/libcef/renderer/embed/shell/common/gin_converters/time_converter.cc
new file mode 100644
index 000000000..cc53c7f2a
--- /dev/null
+++ b/libcef/renderer/embed/shell/common/gin_converters/time_converter.cc
@@ -0,0 +1,22 @@
+// Copyright (c) 2020 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#include "shell/common/gin_converters/time_converter.h"
+
+#include "base/time/time.h"
+#include "v8/include/v8-date.h"
+
+namespace gin {
+
+v8::Local<v8::Value> Converter<base::Time>::ToV8(v8::Isolate* isolate,
+                                                 const base::Time& val) {
+  v8::Local<v8::Value> date;
+  if (v8::Date::New(isolate->GetCurrentContext(), val.ToJsTime())
+          .ToLocal(&date))
+    return date;
+  else
+    return v8::Null(isolate);
+}
+
+}  // namespace gin
diff --git a/libcef/renderer/embed/shell/common/gin_converters/time_converter.h b/libcef/renderer/embed/shell/common/gin_converters/time_converter.h
new file mode 100644
index 000000000..7149eaaef
--- /dev/null
+++ b/libcef/renderer/embed/shell/common/gin_converters/time_converter.h
@@ -0,0 +1,23 @@
+// Copyright (c) 2020 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#ifndef ELECTRON_SHELL_COMMON_GIN_CONVERTERS_TIME_CONVERTER_H_
+#define ELECTRON_SHELL_COMMON_GIN_CONVERTERS_TIME_CONVERTER_H_
+
+#include "gin/converter.h"
+
+namespace base {
+class Time;
+}
+
+namespace gin {
+
+template <>
+struct Converter<base::Time> {
+  static v8::Local<v8::Value> ToV8(v8::Isolate* isolate, const base::Time& val);
+};
+
+}  // namespace gin
+
+#endif  // ELECTRON_SHELL_COMMON_GIN_CONVERTERS_TIME_CONVERTER_H_
diff --git a/libcef/renderer/embed/shell/common/gin_converters/value_converter.cc b/libcef/renderer/embed/shell/common/gin_converters/value_converter.cc
new file mode 100644
index 000000000..db89b6a63
--- /dev/null
+++ b/libcef/renderer/embed/shell/common/gin_converters/value_converter.cc
@@ -0,0 +1,77 @@
+// Copyright (c) 2014 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#include "shell/common/gin_converters/value_converter.h"
+
+#include <memory>
+#include <utility>
+
+#include "base/values.h"
+#include "shell/common/v8_value_converter.h"
+
+namespace gin {
+
+bool Converter<base::DictionaryValue>::FromV8(v8::Isolate* isolate,
+                                              v8::Local<v8::Value> val,
+                                              base::DictionaryValue* out) {
+  electron::V8ValueConverter converter;
+  std::unique_ptr<base::Value> value(
+      converter.FromV8Value(val, isolate->GetCurrentContext()));
+  if (value && value->is_dict()) {
+    out->Swap(static_cast<base::DictionaryValue*>(value.get()));
+    return true;
+  } else {
+    return false;
+  }
+}
+
+v8::Local<v8::Value> Converter<base::DictionaryValue>::ToV8(
+    v8::Isolate* isolate,
+    const base::DictionaryValue& val) {
+  electron::V8ValueConverter converter;
+  return converter.ToV8Value(&val, isolate->GetCurrentContext());
+}
+
+bool Converter<base::Value>::FromV8(v8::Isolate* isolate,
+                                    v8::Local<v8::Value> val,
+                                    base::Value* out) {
+  electron::V8ValueConverter converter;
+  std::unique_ptr<base::Value> value(
+      converter.FromV8Value(val, isolate->GetCurrentContext()));
+  if (value) {
+    *out = std::move(*value);
+    return true;
+  } else {
+    return false;
+  }
+}
+
+v8::Local<v8::Value> Converter<base::Value>::ToV8(v8::Isolate* isolate,
+                                                  const base::Value& val) {
+  electron::V8ValueConverter converter;
+  return converter.ToV8Value(&val, isolate->GetCurrentContext());
+}
+
+bool Converter<base::ListValue>::FromV8(v8::Isolate* isolate,
+                                        v8::Local<v8::Value> val,
+                                        base::ListValue* out) {
+  electron::V8ValueConverter converter;
+  std::unique_ptr<base::Value> value(
+      converter.FromV8Value(val, isolate->GetCurrentContext()));
+  if (value && value->is_list()) {
+    out->Swap(static_cast<base::ListValue*>(value.get()));
+    return true;
+  } else {
+    return false;
+  }
+}
+
+v8::Local<v8::Value> Converter<base::ListValue>::ToV8(
+    v8::Isolate* isolate,
+    const base::ListValue& val) {
+  electron::V8ValueConverter converter;
+  return converter.ToV8Value(&val, isolate->GetCurrentContext());
+}
+
+}  // namespace gin
diff --git a/libcef/renderer/embed/shell/common/gin_converters/value_converter.h b/libcef/renderer/embed/shell/common/gin_converters/value_converter.h
new file mode 100644
index 000000000..16a79af43
--- /dev/null
+++ b/libcef/renderer/embed/shell/common/gin_converters/value_converter.h
@@ -0,0 +1,47 @@
+// Copyright (c) 2014 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#ifndef ELECTRON_SHELL_COMMON_GIN_CONVERTERS_VALUE_CONVERTER_H_
+#define ELECTRON_SHELL_COMMON_GIN_CONVERTERS_VALUE_CONVERTER_H_
+
+#include "gin/converter.h"
+
+namespace base {
+class DictionaryValue;
+class ListValue;
+class Value;
+}  // namespace base
+
+namespace gin {
+
+template <>
+struct Converter<base::DictionaryValue> {
+  static bool FromV8(v8::Isolate* isolate,
+                     v8::Local<v8::Value> val,
+                     base::DictionaryValue* out);
+  static v8::Local<v8::Value> ToV8(v8::Isolate* isolate,
+                                   const base::DictionaryValue& val);
+};
+
+template <>
+struct Converter<base::Value> {
+  static bool FromV8(v8::Isolate* isolate,
+                     v8::Local<v8::Value> val,
+                     base::Value* out);
+  static v8::Local<v8::Value> ToV8(v8::Isolate* isolate,
+                                   const base::Value& val);
+};
+
+template <>
+struct Converter<base::ListValue> {
+  static bool FromV8(v8::Isolate* isolate,
+                     v8::Local<v8::Value> val,
+                     base::ListValue* out);
+  static v8::Local<v8::Value> ToV8(v8::Isolate* isolate,
+                                   const base::ListValue& val);
+};
+
+}  // namespace gin
+
+#endif  // ELECTRON_SHELL_COMMON_GIN_CONVERTERS_VALUE_CONVERTER_H_
diff --git a/libcef/renderer/embed/shell/common/gin_helper/accessor.h b/libcef/renderer/embed/shell/common/gin_helper/accessor.h
new file mode 100644
index 000000000..5bd0bc9cb
--- /dev/null
+++ b/libcef/renderer/embed/shell/common/gin_helper/accessor.h
@@ -0,0 +1,27 @@
+// Copyright (c) 2021 Samuel Maddock <sam@samuelmaddock.com>.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#ifndef ELECTRON_SHELL_COMMON_GIN_HELPER_ACCESSOR_H_
+#define ELECTRON_SHELL_COMMON_GIN_HELPER_ACCESSOR_H_
+
+namespace gin_helper {
+
+// Wrapper for a generic value to be used as an accessor in a
+// gin_helper::Dictionary.
+template <typename T>
+struct AccessorValue {
+  T Value;
+};
+template <typename T>
+struct AccessorValue<const T&> {
+  T Value;
+};
+template <typename T>
+struct AccessorValue<const T*> {
+  T* Value;
+};
+
+}  // namespace gin_helper
+
+#endif  // ELECTRON_SHELL_COMMON_GIN_HELPER_ACCESSOR_H_
diff --git a/libcef/renderer/embed/shell/common/gin_helper/arguments.cc b/libcef/renderer/embed/shell/common/gin_helper/arguments.cc
new file mode 100644
index 000000000..4e82443ca
--- /dev/null
+++ b/libcef/renderer/embed/shell/common/gin_helper/arguments.cc
@@ -0,0 +1,23 @@
+// Copyright 2019 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE.chromium file.
+
+#include "shell/common/gin_helper/arguments.h"
+
+#include "v8/include/v8-exception.h"
+namespace gin_helper {
+
+void Arguments::ThrowError() const {
+  // Gin advances |next_| counter when conversion fails while we do not, so we
+  // have to manually advance the counter here to make gin report error with the
+  // correct index.
+  const_cast<Arguments*>(this)->Skip();
+  gin::Arguments::ThrowError();
+}
+
+void Arguments::ThrowError(base::StringPiece message) const {
+  isolate()->ThrowException(
+      v8::Exception::Error(gin::StringToV8(isolate(), message)));
+}
+
+}  // namespace gin_helper
diff --git a/libcef/renderer/embed/shell/common/gin_helper/arguments.h b/libcef/renderer/embed/shell/common/gin_helper/arguments.h
new file mode 100644
index 000000000..81a37f847
--- /dev/null
+++ b/libcef/renderer/embed/shell/common/gin_helper/arguments.h
@@ -0,0 +1,51 @@
+// Copyright 2019 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE.chromium file.
+
+#ifndef ELECTRON_SHELL_COMMON_GIN_HELPER_ARGUMENTS_H_
+#define ELECTRON_SHELL_COMMON_GIN_HELPER_ARGUMENTS_H_
+
+#include "gin/arguments.h"
+
+namespace gin_helper {
+
+// Provides additional APIs to the gin::Arguments class.
+class Arguments : public gin::Arguments {
+ public:
+  // Get the next argument, if conversion to T fails then state is unchanged.
+  //
+  // This is difference from gin::Arguments::GetNext which always advances the
+  // |next_| counter no matter whether the conversion succeeds.
+  template <typename T>
+  bool GetNext(T* out) {
+    v8::Local<v8::Value> val = PeekNext();
+    if (val.IsEmpty())
+      return false;
+    if (!gin::ConvertFromV8(isolate(), val, out))
+      return false;
+    Skip();
+    return true;
+  }
+
+  // Gin always returns true when converting V8 value to boolean, we do not want
+  // this behavior when parsing parameters.
+  bool GetNext(bool* out) {
+    v8::Local<v8::Value> val = PeekNext();
+    if (val.IsEmpty() || !val->IsBoolean())
+      return false;
+    *out = val->BooleanValue(isolate());
+    Skip();
+    return true;
+  }
+
+  // Throw error with custom error message.
+  void ThrowError() const;
+  void ThrowError(base::StringPiece message) const;
+
+ private:
+  // MUST NOT ADD ANY DATA MEMBER.
+};
+
+}  // namespace gin_helper
+
+#endif  // ELECTRON_SHELL_COMMON_GIN_HELPER_ARGUMENTS_H_
diff --git a/libcef/renderer/embed/shell/common/gin_helper/callback.cc b/libcef/renderer/embed/shell/common/gin_helper/callback.cc
new file mode 100644
index 000000000..a5abed2c7
--- /dev/null
+++ b/libcef/renderer/embed/shell/common/gin_helper/callback.cc
@@ -0,0 +1,154 @@
+// Copyright (c) 2019 GitHub, Inc. All rights reserved.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#include "shell/common/gin_helper/callback.h"
+
+#include "base/cxx17_backports.h"
+#include "content/public/browser/browser_thread.h"
+#include "gin/dictionary.h"
+
+namespace gin_helper {
+
+namespace {
+
+struct TranslaterHolder {
+  explicit TranslaterHolder(v8::Isolate* isolate)
+      : handle(isolate, v8::External::New(isolate, this)) {
+    handle.SetWeak(this, &GC, v8::WeakCallbackType::kFinalizer);
+  }
+  ~TranslaterHolder() {
+    if (!handle.IsEmpty()) {
+      handle.ClearWeak();
+      handle.Reset();
+    }
+  }
+
+  static void GC(const v8::WeakCallbackInfo<TranslaterHolder>& data) {
+    delete data.GetParameter();
+  }
+
+  v8::Global<v8::External> handle;
+  Translater translater;
+};
+
+// Cached JavaScript version of |CallTranslater|.
+v8::Persistent<v8::FunctionTemplate> g_call_translater;
+
+void CallTranslater(v8::Local<v8::External> external,
+                    v8::Local<v8::Object> state,
+                    gin::Arguments* args) {
+  // Whether the callback should only be called once.
+  v8::Isolate* isolate = args->isolate();
+  auto context = isolate->GetCurrentContext();
+  bool one_time =
+      state->Has(context, gin::StringToSymbol(isolate, "oneTime")).ToChecked();
+
+  // Check if the callback has already been called.
+  if (one_time) {
+    auto called_symbol = gin::StringToSymbol(isolate, "called");
+    if (state->Has(context, called_symbol).ToChecked()) {
+      args->ThrowTypeError("One-time callback was called more than once");
+      return;
+    } else {
+      state->Set(context, called_symbol, v8::Boolean::New(isolate, true))
+          .ToChecked();
+    }
+  }
+
+  auto* holder = static_cast<TranslaterHolder*>(external->Value());
+  holder->translater.Run(args);
+
+  // Free immediately for one-time callback.
+  if (one_time)
+    delete holder;
+}
+
+}  // namespace
+
+// Destroy the class on UI thread when possible.
+struct DeleteOnUIThread {
+  template <typename T>
+  static void Destruct(const T* x) {
+    if (gin_helper::Locker::IsBrowserProcess() &&
+        !content::BrowserThread::CurrentlyOn(content::BrowserThread::UI)) {
+      content::BrowserThread::DeleteSoon(content::BrowserThread::UI, FROM_HERE,
+                                         x);
+    } else {
+      delete x;
+    }
+  }
+};
+
+// Like v8::Global, but ref-counted.
+template <typename T>
+class RefCountedGlobal
+    : public base::RefCountedThreadSafe<RefCountedGlobal<T>, DeleteOnUIThread> {
+ public:
+  RefCountedGlobal(v8::Isolate* isolate, v8::Local<v8::Value> value)
+      : handle_(isolate, value.As<T>()) {}
+
+  bool IsAlive() const { return !handle_.IsEmpty(); }
+
+  v8::Local<T> NewHandle(v8::Isolate* isolate) const {
+    return v8::Local<T>::New(isolate, handle_);
+  }
+
+ private:
+  v8::Global<T> handle_;
+};
+
+SafeV8Function::SafeV8Function(v8::Isolate* isolate, v8::Local<v8::Value> value)
+    : v8_function_(new RefCountedGlobal<v8::Function>(isolate, value)) {}
+
+SafeV8Function::SafeV8Function(const SafeV8Function& other) = default;
+
+SafeV8Function::~SafeV8Function() = default;
+
+bool SafeV8Function::IsAlive() const {
+  return v8_function_.get() && v8_function_->IsAlive();
+}
+
+v8::Local<v8::Function> SafeV8Function::NewHandle(v8::Isolate* isolate) const {
+  return v8_function_->NewHandle(isolate);
+}
+
+v8::Local<v8::Value> CreateFunctionFromTranslater(v8::Isolate* isolate,
+                                                  const Translater& translater,
+                                                  bool one_time) {
+  // The FunctionTemplate is cached.
+  if (g_call_translater.IsEmpty())
+    g_call_translater.Reset(
+        isolate,
+        CreateFunctionTemplate(isolate, base::BindRepeating(&CallTranslater)));
+
+  v8::Local<v8::FunctionTemplate> call_translater =
+      v8::Local<v8::FunctionTemplate>::New(isolate, g_call_translater);
+  auto* holder = new TranslaterHolder(isolate);
+  holder->translater = translater;
+  gin::Dictionary state = gin::Dictionary::CreateEmpty(isolate);
+  if (one_time)
+    state.Set("oneTime", true);
+  auto context = isolate->GetCurrentContext();
+  return BindFunctionWith(
+      isolate, context, call_translater->GetFunction(context).ToLocalChecked(),
+      holder->handle.Get(isolate), gin::ConvertToV8(isolate, state));
+}
+
+// func.bind(func, arg1).
+// NB(zcbenz): Using C++11 version crashes VS.
+v8::Local<v8::Value> BindFunctionWith(v8::Isolate* isolate,
+                                      v8::Local<v8::Context> context,
+                                      v8::Local<v8::Function> func,
+                                      v8::Local<v8::Value> arg1,
+                                      v8::Local<v8::Value> arg2) {
+  v8::MaybeLocal<v8::Value> bind =
+      func->Get(context, gin::StringToV8(isolate, "bind"));
+  CHECK(!bind.IsEmpty());
+  v8::Local<v8::Function> bind_func = bind.ToLocalChecked().As<v8::Function>();
+  v8::Local<v8::Value> converted[] = {func, arg1, arg2};
+  return bind_func->Call(context, func, base::size(converted), converted)
+      .ToLocalChecked();
+}
+
+}  // namespace gin_helper
diff --git a/libcef/renderer/embed/shell/common/gin_helper/callback.h b/libcef/renderer/embed/shell/common/gin_helper/callback.h
new file mode 100644
index 000000000..a00fa5b54
--- /dev/null
+++ b/libcef/renderer/embed/shell/common/gin_helper/callback.h
@@ -0,0 +1,152 @@
+// Copyright (c) 2019 GitHub, Inc. All rights reserved.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#ifndef ELECTRON_SHELL_COMMON_GIN_HELPER_CALLBACK_H_
+#define ELECTRON_SHELL_COMMON_GIN_HELPER_CALLBACK_H_
+
+#include <utility>
+#include <vector>
+
+#include "base/bind.h"
+#include "gin/dictionary.h"
+#include "shell/common/gin_converters/std_converter.h"
+#include "shell/common/gin_helper/function_template.h"
+#include "shell/common/gin_helper/locker.h"
+#include "shell/common/gin_helper/microtasks_scope.h"
+// Implements safe conversions between JS functions and base::RepeatingCallback.
+
+namespace gin_helper {
+
+template <typename T>
+class RefCountedGlobal;
+
+// Manages the V8 function with RAII.
+class SafeV8Function {
+ public:
+  SafeV8Function(v8::Isolate* isolate, v8::Local<v8::Value> value);
+  SafeV8Function(const SafeV8Function& other);
+  ~SafeV8Function();
+
+  bool IsAlive() const;
+  v8::Local<v8::Function> NewHandle(v8::Isolate* isolate) const;
+
+ private:
+  scoped_refptr<RefCountedGlobal<v8::Function>> v8_function_;
+};
+
+// Helper to invoke a V8 function with C++ parameters.
+template <typename Sig>
+struct V8FunctionInvoker {};
+
+template <typename... ArgTypes>
+struct V8FunctionInvoker<v8::Local<v8::Value>(ArgTypes...)> {
+  static v8::Local<v8::Value> Go(v8::Isolate* isolate,
+                                 const SafeV8Function& function,
+                                 ArgTypes... raw) {
+    gin_helper::Locker locker(isolate);
+    v8::EscapableHandleScope handle_scope(isolate);
+    if (!function.IsAlive())
+      return v8::Null(isolate);
+    gin_helper::MicrotasksScope microtasks_scope(isolate, true);
+    v8::Local<v8::Function> holder = function.NewHandle(isolate);
+    v8::Local<v8::Context> context = holder->CreationContext();
+    v8::Context::Scope context_scope(context);
+    std::vector<v8::Local<v8::Value>> args{
+        gin::ConvertToV8(isolate, std::forward<ArgTypes>(raw))...};
+    v8::MaybeLocal<v8::Value> ret = holder->Call(
+        context, holder, args.size(), args.empty() ? nullptr : &args.front());
+    if (ret.IsEmpty())
+      return v8::Undefined(isolate);
+    else
+      return handle_scope.Escape(ret.ToLocalChecked());
+  }
+};
+
+template <typename... ArgTypes>
+struct V8FunctionInvoker<void(ArgTypes...)> {
+  static void Go(v8::Isolate* isolate,
+                 const SafeV8Function& function,
+                 ArgTypes... raw) {
+    gin_helper::Locker locker(isolate);
+    v8::HandleScope handle_scope(isolate);
+    if (!function.IsAlive())
+      return;
+    gin_helper::MicrotasksScope microtasks_scope(isolate, true);
+    v8::Local<v8::Function> holder = function.NewHandle(isolate);
+    v8::Local<v8::Context> context = holder->CreationContext();
+    v8::Context::Scope context_scope(context);
+    std::vector<v8::Local<v8::Value>> args{
+        gin::ConvertToV8(isolate, std::forward<ArgTypes>(raw))...};
+    holder
+        ->Call(context, holder, args.size(),
+               args.empty() ? nullptr : &args.front())
+        .IsEmpty();
+  }
+};
+
+template <typename ReturnType, typename... ArgTypes>
+struct V8FunctionInvoker<ReturnType(ArgTypes...)> {
+  static ReturnType Go(v8::Isolate* isolate,
+                       const SafeV8Function& function,
+                       ArgTypes... raw) {
+    gin_helper::Locker locker(isolate);
+    v8::HandleScope handle_scope(isolate);
+    ReturnType ret = ReturnType();
+    if (!function.IsAlive())
+      return ret;
+    gin_helper::MicrotasksScope microtasks_scope(isolate, true);
+    v8::Local<v8::Function> holder = function.NewHandle(isolate);
+    v8::Local<v8::Context> context = holder->CreationContext();
+    v8::Context::Scope context_scope(context);
+    std::vector<v8::Local<v8::Value>> args{
+        gin::ConvertToV8(isolate, std::forward<ArgTypes>(raw))...};
+    v8::Local<v8::Value> result;
+    auto maybe_result = holder->Call(context, holder, args.size(),
+                                     args.empty() ? nullptr : &args.front());
+    if (maybe_result.ToLocal(&result))
+      gin::Converter<ReturnType>::FromV8(isolate, result, &ret);
+    return ret;
+  }
+};
+
+// Helper to pass a C++ function to JavaScript.
+using Translater = base::RepeatingCallback<void(gin::Arguments* args)>;
+v8::Local<v8::Value> CreateFunctionFromTranslater(v8::Isolate* isolate,
+                                                  const Translater& translater,
+                                                  bool one_time);
+v8::Local<v8::Value> BindFunctionWith(v8::Isolate* isolate,
+                                      v8::Local<v8::Context> context,
+                                      v8::Local<v8::Function> func,
+                                      v8::Local<v8::Value> arg1,
+                                      v8::Local<v8::Value> arg2);
+
+// Calls callback with Arguments.
+template <typename Sig>
+struct NativeFunctionInvoker {};
+
+template <typename ReturnType, typename... ArgTypes>
+struct NativeFunctionInvoker<ReturnType(ArgTypes...)> {
+  static void Go(base::RepeatingCallback<ReturnType(ArgTypes...)> val,
+                 gin::Arguments* args) {
+    using Indices = typename IndicesGenerator<sizeof...(ArgTypes)>::type;
+    Invoker<Indices, ArgTypes...> invoker(args, 0);
+    if (invoker.IsOK())
+      invoker.DispatchToCallback(val);
+  }
+};
+
+// Convert a callback to V8 without the call number limitation, this can easily
+// cause memory leaks so use it with caution.
+template <typename Sig>
+v8::Local<v8::Value> CallbackToV8Leaked(
+    v8::Isolate* isolate,
+    const base::RepeatingCallback<Sig>& val) {
+  Translater translater =
+      base::BindRepeating(&NativeFunctionInvoker<Sig>::Go, val);
+  return CreateFunctionFromTranslater(isolate, translater, false);
+}
+
+}  // namespace gin_helper
+
+#endif  // ELECTRON_SHELL_COMMON_GIN_HELPER_CALLBACK_H_
diff --git a/libcef/renderer/embed/shell/common/gin_helper/cleaned_up_at_exit.cc b/libcef/renderer/embed/shell/common/gin_helper/cleaned_up_at_exit.cc
new file mode 100644
index 000000000..1ed74675e
--- /dev/null
+++ b/libcef/renderer/embed/shell/common/gin_helper/cleaned_up_at_exit.cc
@@ -0,0 +1,35 @@
+// Copyright (c) 2020 Slack Technologies, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#include "shell/common/gin_helper/cleaned_up_at_exit.h"
+
+#include <algorithm>
+#include <vector>
+
+#include "base/no_destructor.h"
+
+namespace gin_helper {
+
+std::vector<CleanedUpAtExit*>& GetDoomed() {
+  static base::NoDestructor<std::vector<CleanedUpAtExit*>> doomed;
+  return *doomed;
+}
+CleanedUpAtExit::CleanedUpAtExit() {
+  GetDoomed().emplace_back(this);
+}
+CleanedUpAtExit::~CleanedUpAtExit() {
+  auto& doomed = GetDoomed();
+  doomed.erase(std::remove(doomed.begin(), doomed.end(), this), doomed.end());
+}
+
+// static
+void CleanedUpAtExit::DoCleanup() {
+  auto& doomed = GetDoomed();
+  while (!doomed.empty()) {
+    CleanedUpAtExit* next = doomed.back();
+    delete next;
+  }
+}
+
+}  // namespace gin_helper
diff --git a/libcef/renderer/embed/shell/common/gin_helper/cleaned_up_at_exit.h b/libcef/renderer/embed/shell/common/gin_helper/cleaned_up_at_exit.h
new file mode 100644
index 000000000..35d9e1618
--- /dev/null
+++ b/libcef/renderer/embed/shell/common/gin_helper/cleaned_up_at_exit.h
@@ -0,0 +1,27 @@
+// Copyright (c) 2020 Slack Technologies, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#ifndef ELECTRON_SHELL_COMMON_GIN_HELPER_CLEANED_UP_AT_EXIT_H_
+#define ELECTRON_SHELL_COMMON_GIN_HELPER_CLEANED_UP_AT_EXIT_H_
+
+namespace gin_helper {
+
+// Objects of this type will be destroyed immediately prior to disposing the V8
+// Isolate. This should only be used for gin::Wrappable objects, whose lifetime
+// is otherwise managed by V8.
+//
+// NB. This is only needed because v8::Global objects that have SetWeak
+// finalization callbacks do not have their finalization callbacks invoked at
+// Isolate teardown.
+class CleanedUpAtExit {
+ public:
+  CleanedUpAtExit();
+  virtual ~CleanedUpAtExit();
+
+  static void DoCleanup();
+};
+
+}  // namespace gin_helper
+
+#endif  // ELECTRON_SHELL_COMMON_GIN_HELPER_CLEANED_UP_AT_EXIT_H_
diff --git a/libcef/renderer/embed/shell/common/gin_helper/constructible.h b/libcef/renderer/embed/shell/common/gin_helper/constructible.h
new file mode 100644
index 000000000..c6eaaef33
--- /dev/null
+++ b/libcef/renderer/embed/shell/common/gin_helper/constructible.h
@@ -0,0 +1,69 @@
+// Copyright (c) 2020 Slack Technologies, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#ifndef ELECTRON_SHELL_COMMON_GIN_HELPER_CONSTRUCTIBLE_H_
+#define ELECTRON_SHELL_COMMON_GIN_HELPER_CONSTRUCTIBLE_H_
+
+#include "gin/per_isolate_data.h"
+#include "gin/wrappable.h"
+#include "shell/browser/event_emitter_mixin.h"
+#include "shell/common/gin_helper/function_template_extensions.h"
+
+namespace gin_helper {
+template <typename T>
+class EventEmitterMixin;
+
+// Helper class for Wrappable objects which should be constructible with 'new'
+// in JavaScript.
+//
+// To use, inherit from gin::Wrappable and gin_helper::Constructible, and
+// define the static methods New and FillObjectTemplate:
+//
+//   class Example : public gin::Wrappable<Example>,
+//                   public gin_helper::Constructible<Example> {
+//    public:
+//     static gin::Handle<Tray> New(...usual gin method arguments...);
+//     static v8::Local<v8::ObjectTemplate> FillObjectTemplate(
+//         v8::Isolate*,
+//         v8::Local<v8::ObjectTemplate>);
+//   }
+//
+// Do NOT define the usual gin::Wrappable::GetObjectTemplateBuilder. It will
+// not be called for Constructible classes.
+//
+// To expose the constructor, call GetConstructor:
+//
+//   gin::Dictionary dict(isolate, exports);
+//   dict.Set("Example", Example::GetConstructor(context));
+template <typename T>
+class Constructible {
+ public:
+  static v8::Local<v8::Function> GetConstructor(
+      v8::Local<v8::Context> context) {
+    v8::Isolate* isolate = context->GetIsolate();
+    gin::PerIsolateData* data = gin::PerIsolateData::From(isolate);
+    auto* wrapper_info = &T::kWrapperInfo;
+    v8::Local<v8::FunctionTemplate> constructor =
+        data->GetFunctionTemplate(wrapper_info);
+    if (constructor.IsEmpty()) {
+      constructor = gin::CreateConstructorFunctionTemplate(
+          isolate, base::BindRepeating(&T::New));
+      if (std::is_base_of<EventEmitterMixin<T>, T>::value) {
+        constructor->Inherit(
+            gin_helper::internal::GetEventEmitterTemplate(isolate));
+      }
+      constructor->InstanceTemplate()->SetInternalFieldCount(
+          gin::kNumberOfInternalFields);
+      v8::Local<v8::ObjectTemplate> obj_templ =
+          T::FillObjectTemplate(isolate, constructor->InstanceTemplate());
+      data->SetObjectTemplate(wrapper_info, obj_templ);
+      data->SetFunctionTemplate(wrapper_info, constructor);
+    }
+    return constructor->GetFunction(context).ToLocalChecked();
+  }
+};
+
+}  // namespace gin_helper
+
+#endif  // ELECTRON_SHELL_COMMON_GIN_HELPER_CONSTRUCTIBLE_H_
diff --git a/libcef/renderer/embed/shell/common/gin_helper/constructor.h b/libcef/renderer/embed/shell/common/gin_helper/constructor.h
new file mode 100644
index 000000000..398e76a9a
--- /dev/null
+++ b/libcef/renderer/embed/shell/common/gin_helper/constructor.h
@@ -0,0 +1,171 @@
+// Copyright (c) 2018 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#ifndef ELECTRON_SHELL_COMMON_GIN_HELPER_CONSTRUCTOR_H_
+#define ELECTRON_SHELL_COMMON_GIN_HELPER_CONSTRUCTOR_H_
+
+#include "shell/common/gin_helper/function_template.h"
+#include "shell/common/gin_helper/wrappable_base.h"
+
+namespace gin_helper {
+
+namespace internal {
+
+// This set of templates invokes a base::RepeatingCallback by converting the
+// Arguments into native types. It relies on the function_template.h to provide
+// helper templates.
+inline WrappableBase* InvokeFactory(
+    gin::Arguments* args,
+    const base::RepeatingCallback<WrappableBase*()>& callback) {
+  return callback.Run();
+}
+
+template <typename P1>
+inline WrappableBase* InvokeFactory(
+    gin::Arguments* args,
+    const base::RepeatingCallback<WrappableBase*(P1)>& callback) {
+  typename CallbackParamTraits<P1>::LocalType a1;
+  if (!gin_helper::GetNextArgument(args, 0, true, &a1))
+    return nullptr;
+  return callback.Run(a1);
+}
+
+template <typename P1, typename P2>
+inline WrappableBase* InvokeFactory(
+    gin::Arguments* args,
+    const base::RepeatingCallback<WrappableBase*(P1, P2)>& callback) {
+  typename CallbackParamTraits<P1>::LocalType a1;
+  typename CallbackParamTraits<P2>::LocalType a2;
+  if (!gin_helper::GetNextArgument(args, 0, true, &a1) ||
+      !gin_helper::GetNextArgument(args, 0, false, &a2))
+    return nullptr;
+  return callback.Run(a1, a2);
+}
+
+template <typename P1, typename P2, typename P3>
+inline WrappableBase* InvokeFactory(
+    gin::Arguments* args,
+    const base::RepeatingCallback<WrappableBase*(P1, P2, P3)>& callback) {
+  typename CallbackParamTraits<P1>::LocalType a1;
+  typename CallbackParamTraits<P2>::LocalType a2;
+  typename CallbackParamTraits<P3>::LocalType a3;
+  if (!gin_helper::GetNextArgument(args, 0, true, &a1) ||
+      !gin_helper::GetNextArgument(args, 0, false, &a2) ||
+      !gin_helper::GetNextArgument(args, 0, false, &a3))
+    return nullptr;
+  return callback.Run(a1, a2, a3);
+}
+
+template <typename P1, typename P2, typename P3, typename P4>
+inline WrappableBase* InvokeFactory(
+    gin::Arguments* args,
+    const base::RepeatingCallback<WrappableBase*(P1, P2, P3, P4)>& callback) {
+  typename CallbackParamTraits<P1>::LocalType a1;
+  typename CallbackParamTraits<P2>::LocalType a2;
+  typename CallbackParamTraits<P3>::LocalType a3;
+  typename CallbackParamTraits<P4>::LocalType a4;
+  if (!gin_helper::GetNextArgument(args, 0, true, &a1) ||
+      !gin_helper::GetNextArgument(args, 0, false, &a2) ||
+      !gin_helper::GetNextArgument(args, 0, false, &a3) ||
+      !gin_helper::GetNextArgument(args, 0, false, &a4))
+    return nullptr;
+  return callback.Run(a1, a2, a3, a4);
+}
+
+template <typename P1, typename P2, typename P3, typename P4, typename P5>
+inline WrappableBase* InvokeFactory(
+    gin::Arguments* args,
+    const base::RepeatingCallback<WrappableBase*(P1, P2, P3, P4, P5)>&
+        callback) {
+  typename CallbackParamTraits<P1>::LocalType a1;
+  typename CallbackParamTraits<P2>::LocalType a2;
+  typename CallbackParamTraits<P3>::LocalType a3;
+  typename CallbackParamTraits<P4>::LocalType a4;
+  typename CallbackParamTraits<P5>::LocalType a5;
+  if (!gin_helper::GetNextArgument(args, 0, true, &a1) ||
+      !gin_helper::GetNextArgument(args, 0, false, &a2) ||
+      !gin_helper::GetNextArgument(args, 0, false, &a3) ||
+      !gin_helper::GetNextArgument(args, 0, false, &a4) ||
+      !gin_helper::GetNextArgument(args, 0, false, &a5))
+    return nullptr;
+  return callback.Run(a1, a2, a3, a4, a5);
+}
+
+template <typename P1,
+          typename P2,
+          typename P3,
+          typename P4,
+          typename P5,
+          typename P6>
+inline WrappableBase* InvokeFactory(
+    gin::Arguments* args,
+    const base::RepeatingCallback<WrappableBase*(P1, P2, P3, P4, P5, P6)>&
+        callback) {
+  typename CallbackParamTraits<P1>::LocalType a1;
+  typename CallbackParamTraits<P2>::LocalType a2;
+  typename CallbackParamTraits<P3>::LocalType a3;
+  typename CallbackParamTraits<P4>::LocalType a4;
+  typename CallbackParamTraits<P5>::LocalType a5;
+  typename CallbackParamTraits<P6>::LocalType a6;
+  if (!gin_helper::GetNextArgument(args, 0, true, &a1) ||
+      !gin_helper::GetNextArgument(args, 0, false, &a2) ||
+      !gin_helper::GetNextArgument(args, 0, false, &a3) ||
+      !gin_helper::GetNextArgument(args, 0, false, &a4) ||
+      !gin_helper::GetNextArgument(args, 0, false, &a5) ||
+      !gin_helper::GetNextArgument(args, 0, false, &a6))
+    return nullptr;
+  return callback.Run(a1, a2, a3, a4, a5, a6);
+}
+
+template <typename Sig>
+void InvokeNew(const base::RepeatingCallback<Sig>& factory,
+               v8::Isolate* isolate,
+               gin_helper::Arguments* args) {
+  if (!args->IsConstructCall()) {
+    args->ThrowError("Requires constructor call");
+    return;
+  }
+
+  WrappableBase* object;
+  {
+    // Don't continue if the constructor throws an exception.
+    v8::TryCatch try_catch(isolate);
+    object = internal::InvokeFactory(args, factory);
+    if (try_catch.HasCaught()) {
+      try_catch.ReThrow();
+      return;
+    }
+  }
+
+  if (!object)
+    args->ThrowError();
+
+  return;
+}
+
+}  // namespace internal
+
+// Create a FunctionTemplate that can be "new"ed in JavaScript.
+// It is user's responsibility to ensure this function is called for one type
+// only ONCE in the program's whole lifetime, otherwise we would have memory
+// leak.
+template <typename T, typename Sig>
+v8::Local<v8::Function> CreateConstructor(
+    v8::Isolate* isolate,
+    const base::RepeatingCallback<Sig>& func) {
+#ifndef NDEBUG
+  static bool called = false;
+  CHECK(!called) << "CreateConstructor can only be called for one type once";
+  called = true;
+#endif
+  v8::Local<v8::FunctionTemplate> templ = gin_helper::CreateFunctionTemplate(
+      isolate, base::BindRepeating(&internal::InvokeNew<Sig>, func));
+  templ->InstanceTemplate()->SetInternalFieldCount(1);
+  T::BuildPrototype(isolate, templ);
+  return templ->GetFunction(isolate->GetCurrentContext()).ToLocalChecked();
+}
+
+}  // namespace gin_helper
+
+#endif  // ELECTRON_SHELL_COMMON_GIN_HELPER_CONSTRUCTOR_H_
diff --git a/libcef/renderer/embed/shell/common/gin_helper/destroyable.cc b/libcef/renderer/embed/shell/common/gin_helper/destroyable.cc
new file mode 100644
index 000000000..4e77fa91f
--- /dev/null
+++ b/libcef/renderer/embed/shell/common/gin_helper/destroyable.cc
@@ -0,0 +1,73 @@
+// Copyright (c) 2019 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#include "shell/common/gin_helper/destroyable.h"
+
+#include "base/no_destructor.h"
+#include "gin/converter.h"
+#include "shell/common/gin_helper/wrappable_base.h"
+
+namespace gin_helper {
+
+namespace {
+
+v8::Global<v8::FunctionTemplate>* GetDestroyFunc() {
+  static base::NoDestructor<v8::Global<v8::FunctionTemplate>> destroy_func;
+  return destroy_func.get();
+}
+
+v8::Global<v8::FunctionTemplate>* GetIsDestroyedFunc() {
+  static base::NoDestructor<v8::Global<v8::FunctionTemplate>> is_destroyed_func;
+  return is_destroyed_func.get();
+}
+
+void DestroyFunc(const v8::FunctionCallbackInfo<v8::Value>& info) {
+  v8::Local<v8::Object> holder = info.Holder();
+  if (Destroyable::IsDestroyed(holder))
+    return;
+
+  // TODO(zcbenz): gin_helper::Wrappable will be removed.
+  delete static_cast<gin_helper::WrappableBase*>(
+      holder->GetAlignedPointerFromInternalField(0));
+  holder->SetAlignedPointerInInternalField(0, nullptr);
+}
+
+void IsDestroyedFunc(const v8::FunctionCallbackInfo<v8::Value>& info) {
+  info.GetReturnValue().Set(gin::ConvertToV8(
+      info.GetIsolate(), Destroyable::IsDestroyed(info.Holder())));
+}
+
+}  // namespace
+
+// static
+bool Destroyable::IsDestroyed(v8::Local<v8::Object> object) {
+  // An object is considered destroyed if it has no internal pointer or its
+  // internal has been destroyed.
+  return object->InternalFieldCount() == 0 ||
+         object->GetAlignedPointerFromInternalField(0) == nullptr;
+}
+
+// static
+void Destroyable::MakeDestroyable(v8::Isolate* isolate,
+                                  v8::Local<v8::FunctionTemplate> prototype) {
+  // Cache the FunctionTemplate of "destroy" and "isDestroyed".
+  if (GetDestroyFunc()->IsEmpty()) {
+    auto templ = v8::FunctionTemplate::New(isolate, DestroyFunc);
+    templ->RemovePrototype();
+    GetDestroyFunc()->Reset(isolate, templ);
+    templ = v8::FunctionTemplate::New(isolate, IsDestroyedFunc);
+    templ->RemovePrototype();
+    GetIsDestroyedFunc()->Reset(isolate, templ);
+  }
+
+  auto proto_templ = prototype->PrototypeTemplate();
+  proto_templ->Set(
+      gin::StringToSymbol(isolate, "destroy"),
+      v8::Local<v8::FunctionTemplate>::New(isolate, *GetDestroyFunc()));
+  proto_templ->Set(
+      gin::StringToSymbol(isolate, "isDestroyed"),
+      v8::Local<v8::FunctionTemplate>::New(isolate, *GetIsDestroyedFunc()));
+}
+
+}  // namespace gin_helper
diff --git a/libcef/renderer/embed/shell/common/gin_helper/destroyable.h b/libcef/renderer/embed/shell/common/gin_helper/destroyable.h
new file mode 100644
index 000000000..20419542d
--- /dev/null
+++ b/libcef/renderer/embed/shell/common/gin_helper/destroyable.h
@@ -0,0 +1,24 @@
+// Copyright (c) 2019 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#ifndef ELECTRON_SHELL_COMMON_GIN_HELPER_DESTROYABLE_H_
+#define ELECTRON_SHELL_COMMON_GIN_HELPER_DESTROYABLE_H_
+
+#include "v8/include/v8.h"
+
+namespace gin_helper {
+
+// Manage the native object wrapped in JS wrappers.
+struct Destroyable {
+  // Determine whether the native object has been destroyed.
+  static bool IsDestroyed(v8::Local<v8::Object> object);
+
+  // Add "destroy" and "isDestroyed" to prototype chain.
+  static void MakeDestroyable(v8::Isolate* isolate,
+                              v8::Local<v8::FunctionTemplate> prototype);
+};
+
+}  // namespace gin_helper
+
+#endif  // ELECTRON_SHELL_COMMON_GIN_HELPER_DESTROYABLE_H_
diff --git a/libcef/renderer/embed/shell/common/gin_helper/dictionary.h b/libcef/renderer/embed/shell/common/gin_helper/dictionary.h
new file mode 100644
index 000000000..9d3fd527c
--- /dev/null
+++ b/libcef/renderer/embed/shell/common/gin_helper/dictionary.h
@@ -0,0 +1,217 @@
+// Copyright (c) 2019 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#ifndef ELECTRON_SHELL_COMMON_GIN_HELPER_DICTIONARY_H_
+#define ELECTRON_SHELL_COMMON_GIN_HELPER_DICTIONARY_H_
+
+#include <type_traits>
+#include <utility>
+
+#include "gin/dictionary.h"
+#include "shell/common/gin_converters/std_converter.h"
+#include "shell/common/gin_helper/accessor.h"
+#include "shell/common/gin_helper/function_template.h"
+#include "third_party/abseil-cpp/absl/types/optional.h"
+
+namespace gin_helper {
+
+// Adds a few more extends methods to gin::Dictionary.
+//
+// Note that as the destructor of gin::Dictionary is not virtual, and we want to
+// convert between 2 types, we must not add any member.
+class Dictionary : public gin::Dictionary {
+ public:
+  Dictionary() : gin::Dictionary(nullptr) {}
+  Dictionary(v8::Isolate* isolate, v8::Local<v8::Object> object)
+      : gin::Dictionary(isolate, object) {}
+
+  // Allow implicitly converting from gin::Dictionary, as it is absolutely
+  // safe in this case.
+  Dictionary(const gin::Dictionary& dict)  // NOLINT(runtime/explicit)
+      : gin::Dictionary(dict) {}
+
+  // Differences from the Get method in gin::Dictionary:
+  // 1. This is a const method;
+  // 2. It checks whether the key exists before reading;
+  // 3. It accepts arbitrary type of key.
+  template <typename K, typename V>
+  bool Get(const K& key, V* out) const {
+    // Check for existence before getting, otherwise this method will always
+    // returns true when T == v8::Local<v8::Value>.
+    v8::Local<v8::Context> context = isolate()->GetCurrentContext();
+    v8::Local<v8::Value> v8_key = gin::ConvertToV8(isolate(), key);
+    v8::Local<v8::Value> value;
+    v8::Maybe<bool> result = GetHandle()->Has(context, v8_key);
+    if (result.IsJust() && result.FromJust() &&
+        GetHandle()->Get(context, v8_key).ToLocal(&value))
+      return gin::ConvertFromV8(isolate(), value, out);
+    return false;
+  }
+
+  // Differences from the Set method in gin::Dictionary:
+  // 1. It accepts arbitrary type of key.
+  template <typename K, typename V>
+  bool Set(const K& key, const V& val) {
+    v8::Local<v8::Value> v8_value;
+    if (!gin::TryConvertToV8(isolate(), val, &v8_value))
+      return false;
+    v8::Maybe<bool> result =
+        GetHandle()->Set(isolate()->GetCurrentContext(),
+                         gin::ConvertToV8(isolate(), key), v8_value);
+    return !result.IsNothing() && result.FromJust();
+  }
+
+  // Like normal Get but put result in an absl::optional.
+  template <typename T>
+  bool GetOptional(base::StringPiece key, absl::optional<T>* out) const {
+    T ret;
+    if (Get(key, &ret)) {
+      out->emplace(std::move(ret));
+      return true;
+    } else {
+      return false;
+    }
+  }
+
+  template <typename T>
+  bool GetHidden(base::StringPiece key, T* out) const {
+    v8::Local<v8::Context> context = isolate()->GetCurrentContext();
+    v8::Local<v8::Private> privateKey =
+        v8::Private::ForApi(isolate(), gin::StringToV8(isolate(), key));
+    v8::Local<v8::Value> value;
+    v8::Maybe<bool> result = GetHandle()->HasPrivate(context, privateKey);
+    if (result.IsJust() && result.FromJust() &&
+        GetHandle()->GetPrivate(context, privateKey).ToLocal(&value))
+      return gin::ConvertFromV8(isolate(), value, out);
+    return false;
+  }
+
+  template <typename T>
+  bool SetHidden(base::StringPiece key, T val) {
+    v8::Local<v8::Value> v8_value;
+    if (!gin::TryConvertToV8(isolate(), val, &v8_value))
+      return false;
+    v8::Local<v8::Context> context = isolate()->GetCurrentContext();
+    v8::Local<v8::Private> privateKey =
+        v8::Private::ForApi(isolate(), gin::StringToV8(isolate(), key));
+    v8::Maybe<bool> result =
+        GetHandle()->SetPrivate(context, privateKey, v8_value);
+    return !result.IsNothing() && result.FromJust();
+  }
+
+  template <typename T>
+  bool SetMethod(base::StringPiece key, const T& callback) {
+    auto context = isolate()->GetCurrentContext();
+    auto templ = CallbackTraits<T>::CreateTemplate(isolate(), callback);
+    return GetHandle()
+        ->Set(context, gin::StringToV8(isolate(), key),
+              templ->GetFunction(context).ToLocalChecked())
+        .ToChecked();
+  }
+
+  template <typename K, typename V>
+  bool SetGetter(const K& key,
+                 const V& val,
+                 v8::PropertyAttribute attribute = v8::None) {
+    AccessorValue<V> acc_value;
+    acc_value.Value = val;
+
+    v8::Local<v8::Value> v8_value_accessor;
+    if (!gin::TryConvertToV8(isolate(), acc_value, &v8_value_accessor))
+      return false;
+
+    auto context = isolate()->GetCurrentContext();
+
+    return GetHandle()
+        ->SetAccessor(
+            context, gin::StringToV8(isolate(), key),
+            [](v8::Local<v8::Name> property_name,
+               const v8::PropertyCallbackInfo<v8::Value>& info) {
+              AccessorValue<V> acc_value;
+              if (!gin::ConvertFromV8(info.GetIsolate(), info.Data(),
+                                      &acc_value))
+                return;
+
+              V val = acc_value.Value;
+              v8::Local<v8::Value> v8_value;
+              if (gin::TryConvertToV8(info.GetIsolate(), val, &v8_value))
+                info.GetReturnValue().Set(v8_value);
+            },
+            nullptr, v8_value_accessor, v8::DEFAULT, attribute)
+        .ToChecked();
+  }
+
+  template <typename T>
+  bool SetReadOnly(base::StringPiece key, const T& val) {
+    v8::Local<v8::Value> v8_value;
+    if (!gin::TryConvertToV8(isolate(), val, &v8_value))
+      return false;
+    v8::Maybe<bool> result = GetHandle()->DefineOwnProperty(
+        isolate()->GetCurrentContext(), gin::StringToV8(isolate(), key),
+        v8_value, v8::ReadOnly);
+    return !result.IsNothing() && result.FromJust();
+  }
+
+  // Note: If we plan to add more Set methods, consider adding an option instead
+  // of copying code.
+  template <typename T>
+  bool SetReadOnlyNonConfigurable(base::StringPiece key, T val) {
+    v8::Local<v8::Value> v8_value;
+    if (!gin::TryConvertToV8(isolate(), val, &v8_value))
+      return false;
+    v8::Maybe<bool> result = GetHandle()->DefineOwnProperty(
+        isolate()->GetCurrentContext(), gin::StringToV8(isolate(), key),
+        v8_value,
+        static_cast<v8::PropertyAttribute>(v8::ReadOnly | v8::DontDelete));
+    return !result.IsNothing() && result.FromJust();
+  }
+
+  bool Has(base::StringPiece key) const {
+    v8::Maybe<bool> result = GetHandle()->Has(isolate()->GetCurrentContext(),
+                                              gin::StringToV8(isolate(), key));
+    return !result.IsNothing() && result.FromJust();
+  }
+
+  bool Delete(base::StringPiece key) {
+    v8::Maybe<bool> result = GetHandle()->Delete(
+        isolate()->GetCurrentContext(), gin::StringToV8(isolate(), key));
+    return !result.IsNothing() && result.FromJust();
+  }
+
+  bool IsEmpty() const { return isolate() == nullptr || GetHandle().IsEmpty(); }
+
+  v8::Local<v8::Object> GetHandle() const {
+    return gin::ConvertToV8(isolate(),
+                            *static_cast<const gin::Dictionary*>(this))
+        .As<v8::Object>();
+  }
+
+ private:
+  // DO NOT ADD ANY DATA MEMBER.
+};
+
+}  // namespace gin_helper
+
+namespace gin {
+
+template <>
+struct Converter<gin_helper::Dictionary> {
+  static v8::Local<v8::Value> ToV8(v8::Isolate* isolate,
+                                   gin_helper::Dictionary val) {
+    return val.GetHandle();
+  }
+  static bool FromV8(v8::Isolate* isolate,
+                     v8::Local<v8::Value> val,
+                     gin_helper::Dictionary* out) {
+    gin::Dictionary gdict(isolate);
+    if (!ConvertFromV8(isolate, val, &gdict))
+      return false;
+    *out = gin_helper::Dictionary(gdict);
+    return true;
+  }
+};
+
+}  // namespace gin
+
+#endif  // ELECTRON_SHELL_COMMON_GIN_HELPER_DICTIONARY_H_
diff --git a/libcef/renderer/embed/shell/common/gin_helper/error_thrower.cc b/libcef/renderer/embed/shell/common/gin_helper/error_thrower.cc
new file mode 100644
index 000000000..d555b69a2
--- /dev/null
+++ b/libcef/renderer/embed/shell/common/gin_helper/error_thrower.cc
@@ -0,0 +1,44 @@
+// Copyright (c) 2019 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#include "shell/common/gin_helper/error_thrower.h"
+
+#include "gin/converter.h"
+
+namespace gin_helper {
+
+ErrorThrower::ErrorThrower(v8::Isolate* isolate) : isolate_(isolate) {}
+
+// This constructor should be rarely if ever used, since
+// v8::Isolate::GetCurrent() uses atomic loads and is thus a bit
+// costly to invoke
+ErrorThrower::ErrorThrower() : isolate_(v8::Isolate::GetCurrent()) {}
+
+void ErrorThrower::ThrowError(base::StringPiece err_msg) const {
+  Throw(v8::Exception::Error, err_msg);
+}
+
+void ErrorThrower::ThrowTypeError(base::StringPiece err_msg) const {
+  Throw(v8::Exception::TypeError, err_msg);
+}
+
+void ErrorThrower::ThrowRangeError(base::StringPiece err_msg) const {
+  Throw(v8::Exception::RangeError, err_msg);
+}
+
+void ErrorThrower::ThrowReferenceError(base::StringPiece err_msg) const {
+  Throw(v8::Exception::ReferenceError, err_msg);
+}
+
+void ErrorThrower::ThrowSyntaxError(base::StringPiece err_msg) const {
+  Throw(v8::Exception::SyntaxError, err_msg);
+}
+
+void ErrorThrower::Throw(ErrorGenerator gen, base::StringPiece err_msg) const {
+  v8::Local<v8::Value> exception = gen(gin::StringToV8(isolate_, err_msg));
+  if (!isolate_->IsExecutionTerminating())
+    isolate_->ThrowException(exception);
+}
+
+}  // namespace gin_helper
diff --git a/libcef/renderer/embed/shell/common/gin_helper/error_thrower.h b/libcef/renderer/embed/shell/common/gin_helper/error_thrower.h
new file mode 100644
index 000000000..6089363c4
--- /dev/null
+++ b/libcef/renderer/embed/shell/common/gin_helper/error_thrower.h
@@ -0,0 +1,37 @@
+// Copyright (c) 2019 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#ifndef ELECTRON_SHELL_COMMON_GIN_HELPER_ERROR_THROWER_H_
+#define ELECTRON_SHELL_COMMON_GIN_HELPER_ERROR_THROWER_H_
+
+#include "base/strings/string_piece.h"
+#include "v8/include/v8.h"
+
+namespace gin_helper {
+
+class ErrorThrower {
+ public:
+  explicit ErrorThrower(v8::Isolate* isolate);
+  ErrorThrower();
+  ~ErrorThrower() = default;
+
+  void ThrowError(base::StringPiece err_msg) const;
+  void ThrowTypeError(base::StringPiece err_msg) const;
+  void ThrowRangeError(base::StringPiece err_msg) const;
+  void ThrowReferenceError(base::StringPiece err_msg) const;
+  void ThrowSyntaxError(base::StringPiece err_msg) const;
+
+  v8::Isolate* isolate() const { return isolate_; }
+
+ private:
+  using ErrorGenerator =
+      v8::Local<v8::Value> (*)(v8::Local<v8::String> err_msg);
+  void Throw(ErrorGenerator gen, base::StringPiece err_msg) const;
+
+  v8::Isolate* isolate_;
+};
+
+}  // namespace gin_helper
+
+#endif  // ELECTRON_SHELL_COMMON_GIN_HELPER_ERROR_THROWER_H_
diff --git a/libcef/renderer/embed/shell/common/gin_helper/event_emitter.cc b/libcef/renderer/embed/shell/common/gin_helper/event_emitter.cc
new file mode 100644
index 000000000..8779c0550
--- /dev/null
+++ b/libcef/renderer/embed/shell/common/gin_helper/event_emitter.cc
@@ -0,0 +1,80 @@
+// Copyright (c) 2019 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#include "shell/common/gin_helper/event_emitter.h"
+
+#include "content/public/browser/render_frame_host.h"
+#include "content/public/browser/render_process_host.h"
+#include "shell/browser/api/event.h"
+#include "shell/common/gin_helper/dictionary.h"
+#include "shell/common/gin_helper/object_template_builder.h"
+
+namespace gin_helper {
+
+namespace internal {
+
+namespace {
+
+v8::Persistent<v8::ObjectTemplate> event_template;
+
+void PreventDefault(gin_helper::Arguments* args) {
+  Dictionary self;
+  if (args->GetHolder(&self))
+    self.Set("defaultPrevented", true);
+}
+
+}  // namespace
+
+v8::Local<v8::Object> CreateCustomEvent(v8::Isolate* isolate,
+                                        v8::Local<v8::Object> sender,
+                                        v8::Local<v8::Object> custom_event) {
+  if (event_template.IsEmpty()) {
+    event_template.Reset(
+        isolate,
+        ObjectTemplateBuilder(isolate, v8::ObjectTemplate::New(isolate))
+            .SetMethod("preventDefault", &PreventDefault)
+            .Build());
+  }
+
+  v8::Local<v8::Context> context = isolate->GetCurrentContext();
+  CHECK(!context.IsEmpty());
+  v8::Local<v8::Object> event =
+      v8::Local<v8::ObjectTemplate>::New(isolate, event_template)
+          ->NewInstance(context)
+          .ToLocalChecked();
+  if (!sender.IsEmpty())
+    Dictionary(isolate, event).Set("sender", sender);
+  if (!custom_event.IsEmpty())
+    event->SetPrototype(context, custom_event).IsJust();
+  return event;
+}
+
+v8::Local<v8::Object> CreateNativeEvent(
+    v8::Isolate* isolate,
+    v8::Local<v8::Object> sender,
+    content::RenderFrameHost* frame,
+    electron::mojom::ElectronBrowser::MessageSyncCallback callback) {
+  v8::Local<v8::Object> event;
+  if (frame && callback) {
+    gin::Handle<Event> native_event = Event::Create(isolate);
+    native_event->SetCallback(std::move(callback));
+    event = native_event.ToV8().As<v8::Object>();
+  } else {
+    // No need to create native event if we do not need to send reply.
+    event = CreateCustomEvent(isolate);
+  }
+
+  Dictionary dict(isolate, event);
+  dict.Set("sender", sender);
+  // Should always set frameId even when callback is null.
+  if (frame) {
+    dict.Set("frameId", frame->GetRoutingID());
+    dict.Set("processId", frame->GetProcess()->GetID());
+  }
+  return event;
+}
+
+}  // namespace internal
+
+}  // namespace gin_helper
diff --git a/libcef/renderer/embed/shell/common/gin_helper/event_emitter.h b/libcef/renderer/embed/shell/common/gin_helper/event_emitter.h
new file mode 100644
index 000000000..a69b59555
--- /dev/null
+++ b/libcef/renderer/embed/shell/common/gin_helper/event_emitter.h
@@ -0,0 +1,104 @@
+// Copyright (c) 2019 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#ifndef ELECTRON_SHELL_COMMON_GIN_HELPER_EVENT_EMITTER_H_
+#define ELECTRON_SHELL_COMMON_GIN_HELPER_EVENT_EMITTER_H_
+
+#include <utility>
+#include <vector>
+
+#include "content/public/browser/browser_thread.h"
+#include "electron/shell/common/api/api.mojom.h"
+#include "shell/common/gin_helper/event_emitter_caller.h"
+#include "shell/common/gin_helper/wrappable.h"
+
+namespace content {
+class RenderFrameHost;
+}
+
+namespace gin_helper {
+
+namespace internal {
+
+v8::Local<v8::Object> CreateCustomEvent(
+    v8::Isolate* isolate,
+    v8::Local<v8::Object> sender = v8::Local<v8::Object>(),
+    v8::Local<v8::Object> custom_event = v8::Local<v8::Object>());
+v8::Local<v8::Object> CreateNativeEvent(
+    v8::Isolate* isolate,
+    v8::Local<v8::Object> sender,
+    content::RenderFrameHost* frame,
+    electron::mojom::ElectronBrowser::MessageSyncCallback callback);
+
+}  // namespace internal
+
+// Provide helperers to emit event in JavaScript.
+template <typename T>
+class EventEmitter : public gin_helper::Wrappable<T> {
+ public:
+  using Base = gin_helper::Wrappable<T>;
+  using ValueArray = std::vector<v8::Local<v8::Value>>;
+
+  // Make the convinient methods visible:
+  // https://isocpp.org/wiki/faq/templates#nondependent-name-lookup-members
+  v8::Isolate* isolate() const { return Base::isolate(); }
+  v8::Local<v8::Object> GetWrapper() const { return Base::GetWrapper(); }
+  v8::MaybeLocal<v8::Object> GetWrapper(v8::Isolate* isolate) const {
+    return Base::GetWrapper(isolate);
+  }
+
+  // this.emit(name, event, args...);
+  template <typename... Args>
+  bool EmitCustomEvent(base::StringPiece name,
+                       v8::Local<v8::Object> event,
+                       Args&&... args) {
+    return EmitWithEvent(
+        name, internal::CreateCustomEvent(isolate(), GetWrapper(), event),
+        std::forward<Args>(args)...);
+  }
+
+  // this.emit(name, new Event(), args...);
+  template <typename... Args>
+  bool Emit(base::StringPiece name, Args&&... args) {
+    v8::Locker locker(isolate());
+    v8::HandleScope handle_scope(isolate());
+    v8::Local<v8::Object> wrapper = GetWrapper();
+    if (wrapper.IsEmpty())
+      return false;
+    v8::Local<v8::Object> event =
+        internal::CreateCustomEvent(isolate(), wrapper);
+    return EmitWithEvent(name, event, std::forward<Args>(args)...);
+  }
+
+  // disable copy
+  EventEmitter(const EventEmitter&) = delete;
+  EventEmitter& operator=(const EventEmitter&) = delete;
+
+ protected:
+  EventEmitter() {}
+
+ private:
+  // this.emit(name, event, args...);
+  template <typename... Args>
+  bool EmitWithEvent(base::StringPiece name,
+                     v8::Local<v8::Object> event,
+                     Args&&... args) {
+    // It's possible that |this| will be deleted by EmitEvent, so save anything
+    // we need from |this| before calling EmitEvent.
+    auto* isolate = this->isolate();
+    auto context = isolate->GetCurrentContext();
+    gin_helper::EmitEvent(isolate, GetWrapper(), name, event,
+                          std::forward<Args>(args)...);
+    v8::Local<v8::Value> defaultPrevented;
+    if (event->Get(context, gin::StringToV8(isolate, "defaultPrevented"))
+            .ToLocal(&defaultPrevented)) {
+      return defaultPrevented->BooleanValue(isolate);
+    }
+    return false;
+  }
+};
+
+}  // namespace gin_helper
+
+#endif  // ELECTRON_SHELL_COMMON_GIN_HELPER_EVENT_EMITTER_H_
diff --git a/libcef/renderer/embed/shell/common/gin_helper/event_emitter_caller.cc b/libcef/renderer/embed/shell/common/gin_helper/event_emitter_caller.cc
new file mode 100644
index 000000000..0fee5fd7e
--- /dev/null
+++ b/libcef/renderer/embed/shell/common/gin_helper/event_emitter_caller.cc
@@ -0,0 +1,38 @@
+// Copyright (c) 2019 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#include "./event_emitter_caller.h"
+
+#include "./locker.h"
+#include "./microtasks_scope.h"
+#include "./../../..//node_includes.h"
+
+namespace gin_helper {
+
+namespace internal {
+
+v8::Local<v8::Value> CallMethodWithArgs(v8::Isolate* isolate,
+                                        v8::Local<v8::Object> obj,
+                                        const char* method,
+                                        ValueVector* args) {
+  // Perform microtask checkpoint after running JavaScript.
+  gin_helper::MicrotasksScope microtasks_scope(isolate, true);
+  // Use node::MakeCallback to call the callback, and it will also run pending
+  // tasks in Node.js.
+  v8::MaybeLocal<v8::Value> ret = node::MakeCallback(
+      isolate, obj, method, args->size(), args->data(), {0, 0});
+  // If the JS function throws an exception (doesn't return a value) the result
+  // of MakeCallback will be empty and therefore ToLocal will be false, in this
+  // case we need to return "false" as that indicates that the event emitter did
+  // not handle the event
+  v8::Local<v8::Value> localRet;
+  if (ret.ToLocal(&localRet)) {
+    return localRet;
+  }
+  return v8::Boolean::New(isolate, false);
+}
+
+}  // namespace internal
+
+}  // namespace gin_helper
diff --git a/libcef/renderer/embed/shell/common/gin_helper/event_emitter_caller.h b/libcef/renderer/embed/shell/common/gin_helper/event_emitter_caller.h
new file mode 100644
index 000000000..b8a0511a0
--- /dev/null
+++ b/libcef/renderer/embed/shell/common/gin_helper/event_emitter_caller.h
@@ -0,0 +1,91 @@
+// Copyright (c) 2019 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#ifndef ELECTRON_SHELL_COMMON_GIN_HELPER_EVENT_EMITTER_CALLER_H_
+#define ELECTRON_SHELL_COMMON_GIN_HELPER_EVENT_EMITTER_CALLER_H_
+
+#include <utility>
+#include <vector>
+
+#include "gin/converter.h"
+#include "gin/wrappable.h"
+
+namespace gin_helper {
+
+namespace internal {
+
+using ValueVector = std::vector<v8::Local<v8::Value>>;
+
+v8::Local<v8::Value> CallMethodWithArgs(v8::Isolate* isolate,
+                                        v8::Local<v8::Object> obj,
+                                        const char* method,
+                                        ValueVector* args);
+
+}  // namespace internal
+
+// obj.emit.apply(obj, name, args...);
+// The caller is responsible of allocating a HandleScope.
+template <typename StringType>
+v8::Local<v8::Value> EmitEvent(v8::Isolate* isolate,
+                               v8::Local<v8::Object> obj,
+                               const StringType& name,
+                               const internal::ValueVector& args) {
+  internal::ValueVector concatenated_args = {gin::StringToV8(isolate, name)};
+  concatenated_args.reserve(1 + args.size());
+  concatenated_args.insert(concatenated_args.end(), args.begin(), args.end());
+  return internal::CallMethodWithArgs(isolate, obj, "emit", &concatenated_args);
+}
+
+// obj.emit(name, args...);
+// The caller is responsible of allocating a HandleScope.
+template <typename StringType, typename... Args>
+v8::Local<v8::Value> EmitEvent(v8::Isolate* isolate,
+                               v8::Local<v8::Object> obj,
+                               const StringType& name,
+                               Args&&... args) {
+  internal::ValueVector converted_args = {
+      gin::StringToV8(isolate, name),
+      gin::ConvertToV8(isolate, std::forward<Args>(args))...,
+  };
+  return internal::CallMethodWithArgs(isolate, obj, "emit", &converted_args);
+}
+
+// obj.custom_emit(args...)
+template <typename... Args>
+v8::Local<v8::Value> CustomEmit(v8::Isolate* isolate,
+                                v8::Local<v8::Object> object,
+                                const char* custom_emit,
+                                Args&&... args) {
+  internal::ValueVector converted_args = {
+      gin::ConvertToV8(isolate, std::forward<Args>(args))...,
+  };
+  return internal::CallMethodWithArgs(isolate, object, custom_emit,
+                                      &converted_args);
+}
+
+template <typename T, typename... Args>
+v8::Local<v8::Value> CallMethod(v8::Isolate* isolate,
+                                gin::Wrappable<T>* object,
+                                const char* method_name,
+                                Args&&... args) {
+  v8::EscapableHandleScope scope(isolate);
+  v8::Local<v8::Object> v8_object;
+  if (object->GetWrapper(isolate).ToLocal(&v8_object))
+    return scope.Escape(CustomEmit(isolate, v8_object, method_name,
+                                   std::forward<Args>(args)...));
+  else
+    return v8::Local<v8::Value>();
+}
+
+template <typename T, typename... Args>
+v8::Local<v8::Value> CallMethod(gin::Wrappable<T>* object,
+                                const char* method_name,
+                                Args&&... args) {
+  v8::Isolate* isolate = v8::Isolate::GetCurrent();
+  return CallMethod(isolate, object, method_name, std::forward<Args>(args)...);
+}
+
+}  // namespace gin_helper
+
+#endif  // ELECTRON_SHELL_COMMON_GIN_HELPER_EVENT_EMITTER_CALLER_H_
diff --git a/libcef/renderer/embed/shell/common/gin_helper/function_template.cc b/libcef/renderer/embed/shell/common/gin_helper/function_template.cc
new file mode 100644
index 000000000..9d844bff3
--- /dev/null
+++ b/libcef/renderer/embed/shell/common/gin_helper/function_template.cc
@@ -0,0 +1,36 @@
+// Copyright 2019 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE.chromium file.
+
+#include "shell/common/gin_helper/function_template.h"
+
+namespace gin_helper {
+
+CallbackHolderBase::CallbackHolderBase(v8::Isolate* isolate)
+    : v8_ref_(isolate, v8::External::New(isolate, this)) {
+  v8_ref_.SetWeak(this, &CallbackHolderBase::FirstWeakCallback,
+                  v8::WeakCallbackType::kParameter);
+}
+
+CallbackHolderBase::~CallbackHolderBase() {
+  DCHECK(v8_ref_.IsEmpty());
+}
+
+v8::Local<v8::External> CallbackHolderBase::GetHandle(v8::Isolate* isolate) {
+  return v8::Local<v8::External>::New(isolate, v8_ref_);
+}
+
+// static
+void CallbackHolderBase::FirstWeakCallback(
+    const v8::WeakCallbackInfo<CallbackHolderBase>& data) {
+  data.GetParameter()->v8_ref_.Reset();
+  data.SetSecondPassCallback(SecondWeakCallback);
+}
+
+// static
+void CallbackHolderBase::SecondWeakCallback(
+    const v8::WeakCallbackInfo<CallbackHolderBase>& data) {
+  delete data.GetParameter();
+}
+
+}  // namespace gin_helper
diff --git a/libcef/renderer/embed/shell/common/gin_helper/function_template.h b/libcef/renderer/embed/shell/common/gin_helper/function_template.h
new file mode 100644
index 000000000..025c917fb
--- /dev/null
+++ b/libcef/renderer/embed/shell/common/gin_helper/function_template.h
@@ -0,0 +1,332 @@
+// Copyright 2019 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE.chromium file.
+
+#ifndef ELECTRON_SHELL_COMMON_GIN_HELPER_FUNCTION_TEMPLATE_H_
+#define ELECTRON_SHELL_COMMON_GIN_HELPER_FUNCTION_TEMPLATE_H_
+
+#include <utility>
+
+#include "base/bind.h"
+#include "base/callback.h"
+#include "gin/arguments.h"
+#include "shell/common/gin_helper/arguments.h"
+#include "shell/common/gin_helper/destroyable.h"
+#include "shell/common/gin_helper/error_thrower.h"
+#include "shell/common/gin_helper/microtasks_scope.h"
+#include "third_party/abseil-cpp/absl/types/optional.h"
+
+// This file is forked from gin/function_template.h with 2 differences:
+// 1. Support for additional types of arguments.
+// 2. Support for warning using destroyed objects.
+//
+// TODO(zcbenz): We should seek to remove this file after removing native_mate.
+
+namespace gin_helper {
+
+enum CreateFunctionTemplateFlags {
+  HolderIsFirstArgument = 1 << 0,
+};
+
+template <typename T>
+struct CallbackParamTraits {
+  typedef T LocalType;
+};
+template <typename T>
+struct CallbackParamTraits<const T&> {
+  typedef T LocalType;
+};
+template <typename T>
+struct CallbackParamTraits<const T*> {
+  typedef T* LocalType;
+};
+
+// CallbackHolder and CallbackHolderBase are used to pass a
+// base::RepeatingCallback from
+// CreateFunctionTemplate through v8 (via v8::FunctionTemplate) to
+// DispatchToCallback, where it is invoked.
+
+// This simple base class is used so that we can share a single object template
+// among every CallbackHolder instance.
+class CallbackHolderBase {
+ public:
+  v8::Local<v8::External> GetHandle(v8::Isolate* isolate);
+
+  // disable copy
+  CallbackHolderBase(const CallbackHolderBase&) = delete;
+  CallbackHolderBase& operator=(const CallbackHolderBase&) = delete;
+
+ protected:
+  explicit CallbackHolderBase(v8::Isolate* isolate);
+  virtual ~CallbackHolderBase();
+
+ private:
+  static void FirstWeakCallback(
+      const v8::WeakCallbackInfo<CallbackHolderBase>& data);
+  static void SecondWeakCallback(
+      const v8::WeakCallbackInfo<CallbackHolderBase>& data);
+
+  v8::Global<v8::External> v8_ref_;
+};
+
+template <typename Sig>
+class CallbackHolder : public CallbackHolderBase {
+ public:
+  CallbackHolder(v8::Isolate* isolate,
+                 const base::RepeatingCallback<Sig>& callback,
+                 int flags)
+      : CallbackHolderBase(isolate), callback(callback), flags(flags) {}
+  base::RepeatingCallback<Sig> callback;
+  int flags = 0;
+
+ private:
+  virtual ~CallbackHolder() = default;
+};
+
+template <typename T>
+bool GetNextArgument(gin::Arguments* args,
+                     int create_flags,
+                     bool is_first,
+                     T* result) {
+  if (is_first && (create_flags & HolderIsFirstArgument) != 0) {
+    return args->GetHolder(result);
+  } else {
+    return args->GetNext(result);
+  }
+}
+
+// Support absl::optional as output, which would be empty and do not throw error
+// when conversion to T fails.
+template <typename T>
+bool GetNextArgument(gin::Arguments* args,
+                     int create_flags,
+                     bool is_first,
+                     absl::optional<T>* result) {
+  T converted;
+  // Use gin::Arguments::GetNext which always advances |next| counter.
+  if (args->GetNext(&converted))
+    result->emplace(std::move(converted));
+  return true;
+}
+
+// For advanced use cases, we allow callers to request the unparsed Arguments
+// object and poke around in it directly.
+inline bool GetNextArgument(gin::Arguments* args,
+                            int create_flags,
+                            bool is_first,
+                            gin::Arguments** result) {
+  *result = args;
+  return true;
+}
+
+// It's common for clients to just need the isolate, so we make that easy.
+inline bool GetNextArgument(gin::Arguments* args,
+                            int create_flags,
+                            bool is_first,
+                            v8::Isolate** result) {
+  *result = args->isolate();
+  return true;
+}
+
+// Allow clients to pass a util::Error to throw errors if they
+// don't need the full gin::Arguments
+inline bool GetNextArgument(gin::Arguments* args,
+                            int create_flags,
+                            bool is_first,
+                            ErrorThrower* result) {
+  *result = ErrorThrower(args->isolate());
+  return true;
+}
+
+// Supports the gin_helper::Arguments.
+inline bool GetNextArgument(gin::Arguments* args,
+                            int create_flags,
+                            bool is_first,
+                            gin_helper::Arguments** result) {
+  *result = static_cast<gin_helper::Arguments*>(args);
+  return true;
+}
+
+// Classes for generating and storing an argument pack of integer indices
+// (based on well-known "indices trick", see: http://goo.gl/bKKojn):
+template <size_t... indices>
+struct IndicesHolder {};
+
+template <size_t requested_index, size_t... indices>
+struct IndicesGenerator {
+  using type = typename IndicesGenerator<requested_index - 1,
+                                         requested_index - 1,
+                                         indices...>::type;
+};
+template <size_t... indices>
+struct IndicesGenerator<0, indices...> {
+  using type = IndicesHolder<indices...>;
+};
+
+// Class template for extracting and storing single argument for callback
+// at position |index|.
+template <size_t index, typename ArgType>
+struct ArgumentHolder {
+  using ArgLocalType = typename CallbackParamTraits<ArgType>::LocalType;
+
+  ArgLocalType value;
+  bool ok = false;
+
+  ArgumentHolder(gin::Arguments* args, int create_flags) {
+    v8::Local<v8::Object> holder;
+    if (index == 0 && (create_flags & HolderIsFirstArgument) &&
+        args->GetHolder(&holder) &&
+        gin_helper::Destroyable::IsDestroyed(holder)) {
+      args->ThrowTypeError("Object has been destroyed");
+      return;
+    }
+    ok = GetNextArgument(args, create_flags, index == 0, &value);
+    if (!ok) {
+      // Ideally we would include the expected c++ type in the error
+      // message which we can access via typeid(ArgType).name()
+      // however we compile with no-rtti, which disables typeid.
+      args->ThrowError();
+    }
+  }
+};
+
+// Class template for converting arguments from JavaScript to C++ and running
+// the callback with them.
+template <typename IndicesType, typename... ArgTypes>
+class Invoker {};
+
+template <size_t... indices, typename... ArgTypes>
+class Invoker<IndicesHolder<indices...>, ArgTypes...>
+    : public ArgumentHolder<indices, ArgTypes>... {
+ public:
+  // Invoker<> inherits from ArgumentHolder<> for each argument.
+  // C++ has always been strict about the class initialization order,
+  // so it is guaranteed ArgumentHolders will be initialized (and thus, will
+  // extract arguments from Arguments) in the right order.
+  Invoker(gin::Arguments* args, int create_flags)
+      : ArgumentHolder<indices, ArgTypes>(args, create_flags)..., args_(args) {
+    // GCC thinks that create_flags is going unused, even though the
+    // expansion above clearly makes use of it. Per jyasskin@, casting
+    // to void is the commonly accepted way to convince the compiler
+    // that you're actually using a parameter/varible.
+    (void)create_flags;
+  }
+
+  bool IsOK() { return And(ArgumentHolder<indices, ArgTypes>::ok...); }
+
+  template <typename ReturnType>
+  void DispatchToCallback(
+      base::RepeatingCallback<ReturnType(ArgTypes...)> callback) {
+    gin_helper::MicrotasksScope microtasks_scope(args_->isolate(), true);
+    args_->Return(
+        callback.Run(std::move(ArgumentHolder<indices, ArgTypes>::value)...));
+  }
+
+  // In C++, you can declare the function foo(void), but you can't pass a void
+  // expression to foo. As a result, we must specialize the case of Callbacks
+  // that have the void return type.
+  void DispatchToCallback(base::RepeatingCallback<void(ArgTypes...)> callback) {
+    gin_helper::MicrotasksScope microtasks_scope(args_->isolate(), true);
+    callback.Run(std::move(ArgumentHolder<indices, ArgTypes>::value)...);
+  }
+
+ private:
+  static bool And() { return true; }
+  template <typename... T>
+  static bool And(bool arg1, T... args) {
+    return arg1 && And(args...);
+  }
+
+  gin::Arguments* args_;
+};
+
+// DispatchToCallback converts all the JavaScript arguments to C++ types and
+// invokes the base::RepeatingCallback.
+template <typename Sig>
+struct Dispatcher {};
+
+template <typename ReturnType, typename... ArgTypes>
+struct Dispatcher<ReturnType(ArgTypes...)> {
+  static void DispatchToCallback(
+      const v8::FunctionCallbackInfo<v8::Value>& info) {
+    gin::Arguments args(info);
+    v8::Local<v8::External> v8_holder;
+    args.GetData(&v8_holder);
+    CallbackHolderBase* holder_base =
+        reinterpret_cast<CallbackHolderBase*>(v8_holder->Value());
+
+    typedef CallbackHolder<ReturnType(ArgTypes...)> HolderT;
+    HolderT* holder = static_cast<HolderT*>(holder_base);
+
+    using Indices = typename IndicesGenerator<sizeof...(ArgTypes)>::type;
+    Invoker<Indices, ArgTypes...> invoker(&args, holder->flags);
+    if (invoker.IsOK())
+      invoker.DispatchToCallback(holder->callback);
+  }
+};
+
+// CreateFunctionTemplate creates a v8::FunctionTemplate that will create
+// JavaScript functions that execute a provided C++ function or
+// base::RepeatingCallback.
+// JavaScript arguments are automatically converted via gin::Converter, as is
+// the return value of the C++ function, if any.
+//
+// NOTE: V8 caches FunctionTemplates for a lifetime of a web page for its own
+// internal reasons, thus it is generally a good idea to cache the template
+// returned by this function.  Otherwise, repeated method invocations from JS
+// will create substantial memory leaks. See http://crbug.com/463487.
+template <typename Sig>
+v8::Local<v8::FunctionTemplate> CreateFunctionTemplate(
+    v8::Isolate* isolate,
+    const base::RepeatingCallback<Sig> callback,
+    int callback_flags = 0) {
+  typedef CallbackHolder<Sig> HolderT;
+  HolderT* holder = new HolderT(isolate, callback, callback_flags);
+
+  return v8::FunctionTemplate::New(isolate,
+                                   &Dispatcher<Sig>::DispatchToCallback,
+                                   gin::ConvertToV8<v8::Local<v8::External>>(
+                                       isolate, holder->GetHandle(isolate)));
+}
+
+// Base template - used only for non-member function pointers. Other types
+// either go to one of the below specializations, or go here and fail to compile
+// because of base::Bind().
+template <typename T, typename Enable = void>
+struct CallbackTraits {
+  static v8::Local<v8::FunctionTemplate> CreateTemplate(v8::Isolate* isolate,
+                                                        T callback) {
+    return gin_helper::CreateFunctionTemplate(isolate,
+                                              base::BindRepeating(callback));
+  }
+};
+
+// Specialization for base::RepeatingCallback.
+template <typename T>
+struct CallbackTraits<base::RepeatingCallback<T>> {
+  static v8::Local<v8::FunctionTemplate> CreateTemplate(
+      v8::Isolate* isolate,
+      const base::RepeatingCallback<T>& callback) {
+    return gin_helper::CreateFunctionTemplate(isolate, callback);
+  }
+};
+
+// Specialization for member function pointers. We need to handle this case
+// specially because the first parameter for callbacks to MFP should typically
+// come from the the JavaScript "this" object the function was called on, not
+// from the first normal parameter.
+template <typename T>
+struct CallbackTraits<
+    T,
+    typename std::enable_if<std::is_member_function_pointer<T>::value>::type> {
+  static v8::Local<v8::FunctionTemplate> CreateTemplate(v8::Isolate* isolate,
+                                                        T callback) {
+    int flags = HolderIsFirstArgument;
+    return gin_helper::CreateFunctionTemplate(
+        isolate, base::BindRepeating(callback), flags);
+  }
+};
+
+}  // namespace gin_helper
+
+#endif  // ELECTRON_SHELL_COMMON_GIN_HELPER_FUNCTION_TEMPLATE_H_
diff --git a/libcef/renderer/embed/shell/common/gin_helper/function_template_extensions.h b/libcef/renderer/embed/shell/common/gin_helper/function_template_extensions.h
new file mode 100644
index 000000000..7420ffde7
--- /dev/null
+++ b/libcef/renderer/embed/shell/common/gin_helper/function_template_extensions.h
@@ -0,0 +1,60 @@
+// Copyright 2020 Slack Technologies, Inc.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE.chromium file.
+
+#ifndef ELECTRON_SHELL_COMMON_GIN_HELPER_FUNCTION_TEMPLATE_EXTENSIONS_H_
+#define ELECTRON_SHELL_COMMON_GIN_HELPER_FUNCTION_TEMPLATE_EXTENSIONS_H_
+
+#include <utility>
+
+#include "gin/function_template.h"
+#include "shell/common/gin_helper/error_thrower.h"
+
+// This extends the functionality in //gin/function_template.h for "special"
+// arguments to gin-bound methods.
+// It's the counterpart to function_template.h, which includes these methods
+// in the gin_helper namespace.
+namespace gin {
+
+// Support absl::optional as an argument.
+template <typename T>
+bool GetNextArgument(Arguments* args,
+                     const InvokerOptions& invoker_options,
+                     bool is_first,
+                     absl::optional<T>* result) {
+  T converted;
+  // Use gin::Arguments::GetNext which always advances |next| counter.
+  if (args->GetNext(&converted))
+    result->emplace(std::move(converted));
+  return true;
+}
+
+inline bool GetNextArgument(Arguments* args,
+                            const InvokerOptions& invoker_options,
+                            bool is_first,
+                            gin_helper::ErrorThrower* result) {
+  *result = gin_helper::ErrorThrower(args->isolate());
+  return true;
+}
+
+// Like gin::CreateFunctionTemplate, but doesn't remove the template's
+// prototype.
+template <typename Sig>
+v8::Local<v8::FunctionTemplate> CreateConstructorFunctionTemplate(
+    v8::Isolate* isolate,
+    base::RepeatingCallback<Sig> callback,
+    InvokerOptions invoker_options = {}) {
+  typedef internal::CallbackHolder<Sig> HolderT;
+  HolderT* holder =
+      new HolderT(isolate, std::move(callback), std::move(invoker_options));
+
+  v8::Local<v8::FunctionTemplate> tmpl = v8::FunctionTemplate::New(
+      isolate, &internal::Dispatcher<Sig>::DispatchToCallback,
+      ConvertToV8<v8::Local<v8::External>>(isolate,
+                                           holder->GetHandle(isolate)));
+  return tmpl;
+}
+
+}  // namespace gin
+
+#endif  // ELECTRON_SHELL_COMMON_GIN_HELPER_FUNCTION_TEMPLATE_EXTENSIONS_H_
diff --git a/libcef/renderer/embed/shell/common/gin_helper/locker.cc b/libcef/renderer/embed/shell/common/gin_helper/locker.cc
new file mode 100644
index 000000000..b0254b0d7
--- /dev/null
+++ b/libcef/renderer/embed/shell/common/gin_helper/locker.cc
@@ -0,0 +1,16 @@
+// Copyright 2014 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE.chromium file.
+
+#include "./locker.h"
+
+namespace gin_helper {
+
+Locker::Locker(v8::Isolate* isolate) {
+  if (IsBrowserProcess())
+    locker_ = std::make_unique<v8::Locker>(isolate);
+}
+
+Locker::~Locker() = default;
+
+}  // namespace gin_helper
diff --git a/libcef/renderer/embed/shell/common/gin_helper/locker.h b/libcef/renderer/embed/shell/common/gin_helper/locker.h
new file mode 100644
index 000000000..09eee5aa7
--- /dev/null
+++ b/libcef/renderer/embed/shell/common/gin_helper/locker.h
@@ -0,0 +1,37 @@
+// Copyright 2014 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE.chromium file.
+
+#ifndef ELECTRON_SHELL_COMMON_GIN_HELPER_LOCKER_H_
+#define ELECTRON_SHELL_COMMON_GIN_HELPER_LOCKER_H_
+
+#include <memory>
+
+#include "v8/include/v8.h"
+
+namespace gin_helper {
+
+// Only lock when lockers are used in current thread.
+class Locker {
+ public:
+  explicit Locker(v8::Isolate* isolate);
+  ~Locker();
+
+  // disable copy
+  Locker(const Locker&) = delete;
+  Locker& operator=(const Locker&) = delete;
+
+  // Returns whether current process is browser process, currently we detect it
+  // by checking whether current has used V8 Lock, but it might be a bad idea.
+  static inline bool IsBrowserProcess() { return v8::Locker::WasEverUsed(); }
+
+ private:
+  void* operator new(size_t size);
+  void operator delete(void*, size_t);
+
+  std::unique_ptr<v8::Locker> locker_;
+};
+
+}  // namespace gin_helper
+
+#endif  // ELECTRON_SHELL_COMMON_GIN_HELPER_LOCKER_H_
diff --git a/libcef/renderer/embed/shell/common/gin_helper/microtasks_scope.cc b/libcef/renderer/embed/shell/common/gin_helper/microtasks_scope.cc
new file mode 100644
index 000000000..6abede6d4
--- /dev/null
+++ b/libcef/renderer/embed/shell/common/gin_helper/microtasks_scope.cc
@@ -0,0 +1,25 @@
+// Copyright (c) 2020 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#include "./microtasks_scope.h"
+
+#include "./locker.h"
+
+namespace gin_helper {
+
+MicrotasksScope::MicrotasksScope(v8::Isolate* isolate,
+                                 bool ignore_browser_checkpoint,
+                                 v8::MicrotasksScope::Type scope_type) {
+  if (Locker::IsBrowserProcess()) {
+    if (!ignore_browser_checkpoint)
+      v8::MicrotasksScope::PerformCheckpoint(isolate);
+  } else {
+    v8_microtasks_scope_ =
+        std::make_unique<v8::MicrotasksScope>(isolate, scope_type);
+  }
+}
+
+MicrotasksScope::~MicrotasksScope() = default;
+
+}  // namespace gin_helper
diff --git a/libcef/renderer/embed/shell/common/gin_helper/microtasks_scope.h b/libcef/renderer/embed/shell/common/gin_helper/microtasks_scope.h
new file mode 100644
index 000000000..23815a090
--- /dev/null
+++ b/libcef/renderer/embed/shell/common/gin_helper/microtasks_scope.h
@@ -0,0 +1,34 @@
+// Copyright (c) 2020 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#ifndef ELECTRON_SHELL_COMMON_GIN_HELPER_MICROTASKS_SCOPE_H_
+#define ELECTRON_SHELL_COMMON_GIN_HELPER_MICROTASKS_SCOPE_H_
+
+#include <memory>
+
+#include "v8/include/v8.h"
+
+namespace gin_helper {
+
+// In the browser process runs v8::MicrotasksScope::PerformCheckpoint
+// In the render process creates a v8::MicrotasksScope.
+class MicrotasksScope {
+ public:
+  explicit MicrotasksScope(v8::Isolate* isolate,
+                           bool ignore_browser_checkpoint = false,
+                           v8::MicrotasksScope::Type scope_type =
+                               v8::MicrotasksScope::kRunMicrotasks);
+  ~MicrotasksScope();
+
+  // disable copy
+  MicrotasksScope(const MicrotasksScope&) = delete;
+  MicrotasksScope& operator=(const MicrotasksScope&) = delete;
+
+ private:
+  std::unique_ptr<v8::MicrotasksScope> v8_microtasks_scope_;
+};
+
+}  // namespace gin_helper
+
+#endif  // ELECTRON_SHELL_COMMON_GIN_HELPER_MICROTASKS_SCOPE_H_
diff --git a/libcef/renderer/embed/shell/common/gin_helper/object_template_builder.cc b/libcef/renderer/embed/shell/common/gin_helper/object_template_builder.cc
new file mode 100644
index 000000000..832f09057
--- /dev/null
+++ b/libcef/renderer/embed/shell/common/gin_helper/object_template_builder.cc
@@ -0,0 +1,36 @@
+// Copyright (c) 2019 GitHub, Inc. All rights reserved.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#include "shell/common/gin_helper/object_template_builder.h"
+
+namespace gin_helper {
+
+ObjectTemplateBuilder::ObjectTemplateBuilder(
+    v8::Isolate* isolate,
+    v8::Local<v8::ObjectTemplate> templ)
+    : isolate_(isolate), template_(templ) {}
+
+ObjectTemplateBuilder& ObjectTemplateBuilder::SetImpl(
+    const base::StringPiece& name,
+    v8::Local<v8::Data> val) {
+  template_->Set(gin::StringToSymbol(isolate_, name), val);
+  return *this;
+}
+
+ObjectTemplateBuilder& ObjectTemplateBuilder::SetPropertyImpl(
+    const base::StringPiece& name,
+    v8::Local<v8::FunctionTemplate> getter,
+    v8::Local<v8::FunctionTemplate> setter) {
+  template_->SetAccessorProperty(gin::StringToSymbol(isolate_, name), getter,
+                                 setter);
+  return *this;
+}
+
+v8::Local<v8::ObjectTemplate> ObjectTemplateBuilder::Build() {
+  v8::Local<v8::ObjectTemplate> result = template_;
+  template_.Clear();
+  return result;
+}
+
+}  // namespace gin_helper
diff --git a/libcef/renderer/embed/shell/common/gin_helper/object_template_builder.h b/libcef/renderer/embed/shell/common/gin_helper/object_template_builder.h
new file mode 100644
index 000000000..5ec9761be
--- /dev/null
+++ b/libcef/renderer/embed/shell/common/gin_helper/object_template_builder.h
@@ -0,0 +1,77 @@
+// Copyright (c) 2019 GitHub, Inc. All rights reserved.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#ifndef ELECTRON_SHELL_COMMON_GIN_HELPER_OBJECT_TEMPLATE_BUILDER_H_
+#define ELECTRON_SHELL_COMMON_GIN_HELPER_OBJECT_TEMPLATE_BUILDER_H_
+
+#include "shell/common/gin_helper/function_template.h"
+
+namespace gin_helper {
+
+// This class works like gin::ObjectTemplateBuilder, but operates on existing
+// prototype template instead of creating a new one.
+//
+// It also uses gin_helper::CreateFunctionTemplate for function templates to
+// support gin_helper types.
+//
+// TODO(zcbenz): We should patch gin::ObjectTemplateBuilder to provide the same
+// functionality after removing gin_helper/function_template.h.
+class ObjectTemplateBuilder {
+ public:
+  ObjectTemplateBuilder(v8::Isolate* isolate,
+                        v8::Local<v8::ObjectTemplate> templ);
+  ~ObjectTemplateBuilder() = default;
+
+  // It's against Google C++ style to return a non-const ref, but we take some
+  // poetic license here in order that all calls to Set() can be via the '.'
+  // operator and line up nicely.
+  template <typename T>
+  ObjectTemplateBuilder& SetValue(const base::StringPiece& name, T val) {
+    return SetImpl(name, ConvertToV8(isolate_, val));
+  }
+
+  // In the following methods, T and U can be function pointer, member function
+  // pointer, base::RepeatingCallback, or v8::FunctionTemplate. Most clients
+  // will want to use one of the first two options. Also see
+  // gin::CreateFunctionTemplate() for creating raw function templates.
+  template <typename T>
+  ObjectTemplateBuilder& SetMethod(const base::StringPiece& name,
+                                   const T& callback) {
+    return SetImpl(name, CallbackTraits<T>::CreateTemplate(isolate_, callback));
+  }
+  template <typename T>
+  ObjectTemplateBuilder& SetProperty(const base::StringPiece& name,
+                                     const T& getter) {
+    return SetPropertyImpl(name,
+                           CallbackTraits<T>::CreateTemplate(isolate_, getter),
+                           v8::Local<v8::FunctionTemplate>());
+  }
+  template <typename T, typename U>
+  ObjectTemplateBuilder& SetProperty(const base::StringPiece& name,
+                                     const T& getter,
+                                     const U& setter) {
+    return SetPropertyImpl(name,
+                           CallbackTraits<T>::CreateTemplate(isolate_, getter),
+                           CallbackTraits<U>::CreateTemplate(isolate_, setter));
+  }
+
+  v8::Local<v8::ObjectTemplate> Build();
+
+ private:
+  ObjectTemplateBuilder& SetImpl(const base::StringPiece& name,
+                                 v8::Local<v8::Data> val);
+  ObjectTemplateBuilder& SetPropertyImpl(
+      const base::StringPiece& name,
+      v8::Local<v8::FunctionTemplate> getter,
+      v8::Local<v8::FunctionTemplate> setter);
+
+  v8::Isolate* isolate_;
+
+  // ObjectTemplateBuilder should only be used on the stack.
+  v8::Local<v8::ObjectTemplate> template_;
+};
+
+}  // namespace gin_helper
+
+#endif  // ELECTRON_SHELL_COMMON_GIN_HELPER_OBJECT_TEMPLATE_BUILDER_H_
diff --git a/libcef/renderer/embed/shell/common/gin_helper/persistent_dictionary.cc b/libcef/renderer/embed/shell/common/gin_helper/persistent_dictionary.cc
new file mode 100644
index 000000000..c999f6fac
--- /dev/null
+++ b/libcef/renderer/embed/shell/common/gin_helper/persistent_dictionary.cc
@@ -0,0 +1,32 @@
+// Copyright 2014 Cheng Zhao. All rights reserved.
+// Use of this source code is governed by MIT license that can be found in the
+// LICENSE file.
+
+#include "shell/common/gin_helper/persistent_dictionary.h"
+
+namespace gin_helper {
+
+PersistentDictionary::PersistentDictionary() = default;
+
+PersistentDictionary::PersistentDictionary(v8::Isolate* isolate,
+                                           v8::Local<v8::Object> object)
+    : isolate_(isolate), handle_(isolate, object) {}
+
+PersistentDictionary::PersistentDictionary(const PersistentDictionary& other)
+    : isolate_(other.isolate_),
+      handle_(isolate_, v8::Local<v8::Object>::New(isolate_, other.handle_)) {}
+
+PersistentDictionary::~PersistentDictionary() = default;
+
+PersistentDictionary& PersistentDictionary::operator=(
+    const PersistentDictionary& other) {
+  isolate_ = other.isolate_;
+  handle_.Reset(isolate_, v8::Local<v8::Object>::New(isolate_, other.handle_));
+  return *this;
+}
+
+v8::Local<v8::Object> PersistentDictionary::GetHandle() const {
+  return v8::Local<v8::Object>::New(isolate_, handle_);
+}
+
+}  // namespace gin_helper
diff --git a/libcef/renderer/embed/shell/common/gin_helper/persistent_dictionary.h b/libcef/renderer/embed/shell/common/gin_helper/persistent_dictionary.h
new file mode 100644
index 000000000..8bc19d822
--- /dev/null
+++ b/libcef/renderer/embed/shell/common/gin_helper/persistent_dictionary.h
@@ -0,0 +1,63 @@
+// Copyright 2014 Cheng Zhao. All rights reserved.
+// Use of this source code is governed by MIT license that can be found in the
+// LICENSE file.
+
+#ifndef ELECTRON_SHELL_COMMON_GIN_HELPER_PERSISTENT_DICTIONARY_H_
+#define ELECTRON_SHELL_COMMON_GIN_HELPER_PERSISTENT_DICTIONARY_H_
+
+#include "shell/common/gin_helper/dictionary.h"
+
+namespace gin_helper {
+
+// Like Dictionary, but stores object in persistent handle so you can keep it
+// safely on heap.
+//
+// TODO(zcbenz): The only user of this class is ElectronTouchBar, we should
+// migrate away from this class.
+class PersistentDictionary {
+ public:
+  PersistentDictionary();
+  PersistentDictionary(v8::Isolate* isolate, v8::Local<v8::Object> object);
+  PersistentDictionary(const PersistentDictionary& other);
+  ~PersistentDictionary();
+
+  PersistentDictionary& operator=(const PersistentDictionary& other);
+
+  v8::Local<v8::Object> GetHandle() const;
+
+  template <typename K, typename V>
+  bool Get(const K& key, V* out) const {
+    v8::Local<v8::Context> context = isolate_->GetCurrentContext();
+    v8::Local<v8::Value> v8_key = gin::ConvertToV8(isolate_, key);
+    v8::Local<v8::Value> value;
+    v8::Maybe<bool> result = GetHandle()->Has(context, v8_key);
+    if (result.IsJust() && result.FromJust() &&
+        GetHandle()->Get(context, v8_key).ToLocal(&value))
+      return gin::ConvertFromV8(isolate_, value, out);
+    return false;
+  }
+
+ private:
+  v8::Isolate* isolate_ = nullptr;
+  v8::Global<v8::Object> handle_;
+};
+
+}  // namespace gin_helper
+
+namespace gin {
+
+template <>
+struct Converter<gin_helper::PersistentDictionary> {
+  static bool FromV8(v8::Isolate* isolate,
+                     v8::Local<v8::Value> val,
+                     gin_helper::PersistentDictionary* out) {
+    if (!val->IsObject())
+      return false;
+    *out = gin_helper::PersistentDictionary(isolate, val.As<v8::Object>());
+    return true;
+  }
+};
+
+}  // namespace gin
+
+#endif  // ELECTRON_SHELL_COMMON_GIN_HELPER_PERSISTENT_DICTIONARY_H_
diff --git a/libcef/renderer/embed/shell/common/gin_helper/pinnable.h b/libcef/renderer/embed/shell/common/gin_helper/pinnable.h
new file mode 100644
index 000000000..42b98f551
--- /dev/null
+++ b/libcef/renderer/embed/shell/common/gin_helper/pinnable.h
@@ -0,0 +1,34 @@
+// Copyright (c) 2020 Slack Technologies, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#ifndef ELECTRON_SHELL_COMMON_GIN_HELPER_PINNABLE_H_
+#define ELECTRON_SHELL_COMMON_GIN_HELPER_PINNABLE_H_
+
+#include "v8/include/v8.h"
+
+namespace gin_helper {
+
+template <typename T>
+class Pinnable {
+ protected:
+  // Prevent the object from being garbage collected until Unpin() is called.
+  void Pin(v8::Isolate* isolate) {
+    v8::Locker locker(isolate);
+    v8::HandleScope scope(isolate);
+    v8::Local<v8::Value> wrapper;
+    if (static_cast<T*>(this)->GetWrapper(isolate).ToLocal(&wrapper)) {
+      pinned_.Reset(isolate, wrapper);
+    }
+  }
+
+  // Allow the object to be garbage collected.
+  void Unpin() { pinned_.Reset(); }
+
+ private:
+  v8::Global<v8::Value> pinned_;
+};
+
+}  // namespace gin_helper
+
+#endif  // ELECTRON_SHELL_COMMON_GIN_HELPER_PINNABLE_H_
diff --git a/libcef/renderer/embed/shell/common/gin_helper/promise.cc b/libcef/renderer/embed/shell/common/gin_helper/promise.cc
new file mode 100644
index 000000000..e17881ef2
--- /dev/null
+++ b/libcef/renderer/embed/shell/common/gin_helper/promise.cc
@@ -0,0 +1,96 @@
+// Copyright (c) 2018 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#include "shell/common/gin_helper/promise.h"
+
+namespace gin_helper {
+
+PromiseBase::PromiseBase(v8::Isolate* isolate)
+    : PromiseBase(isolate,
+                  v8::Promise::Resolver::New(isolate->GetCurrentContext())
+                      .ToLocalChecked()) {}
+
+PromiseBase::PromiseBase(v8::Isolate* isolate,
+                         v8::Local<v8::Promise::Resolver> handle)
+    : isolate_(isolate),
+      context_(isolate, isolate->GetCurrentContext()),
+      resolver_(isolate, handle) {}
+
+PromiseBase::PromiseBase(PromiseBase&&) = default;
+
+PromiseBase::~PromiseBase() = default;
+
+PromiseBase& PromiseBase::operator=(PromiseBase&&) = default;
+
+v8::Maybe<bool> PromiseBase::Reject() {
+  gin_helper::Locker locker(isolate());
+  v8::HandleScope handle_scope(isolate());
+  gin_helper::MicrotasksScope microtasks_scope(isolate());
+  v8::Context::Scope context_scope(GetContext());
+
+  return GetInner()->Reject(GetContext(), v8::Undefined(isolate()));
+}
+
+v8::Maybe<bool> PromiseBase::Reject(v8::Local<v8::Value> except) {
+  gin_helper::Locker locker(isolate());
+  v8::HandleScope handle_scope(isolate());
+  gin_helper::MicrotasksScope microtasks_scope(isolate());
+  v8::Context::Scope context_scope(GetContext());
+
+  return GetInner()->Reject(GetContext(), except);
+}
+
+v8::Maybe<bool> PromiseBase::RejectWithErrorMessage(base::StringPiece message) {
+  gin_helper::Locker locker(isolate());
+  v8::HandleScope handle_scope(isolate());
+  gin_helper::MicrotasksScope microtasks_scope(isolate());
+  v8::Context::Scope context_scope(GetContext());
+
+  v8::Local<v8::Value> error =
+      v8::Exception::Error(gin::StringToV8(isolate(), message));
+  return GetInner()->Reject(GetContext(), (error));
+}
+
+v8::Local<v8::Context> PromiseBase::GetContext() const {
+  return v8::Local<v8::Context>::New(isolate_, context_);
+}
+
+v8::Local<v8::Promise> PromiseBase::GetHandle() const {
+  return GetInner()->GetPromise();
+}
+
+v8::Local<v8::Promise::Resolver> PromiseBase::GetInner() const {
+  return resolver_.Get(isolate());
+}
+
+// static
+void Promise<void>::ResolvePromise(Promise<void> promise) {
+  if (gin_helper::Locker::IsBrowserProcess() &&
+      !content::BrowserThread::CurrentlyOn(content::BrowserThread::UI)) {
+    base::PostTask(
+        FROM_HERE, {content::BrowserThread::UI},
+        base::BindOnce([](Promise<void> promise) { promise.Resolve(); },
+                       std::move(promise)));
+  } else {
+    promise.Resolve();
+  }
+}
+
+// static
+v8::Local<v8::Promise> Promise<void>::ResolvedPromise(v8::Isolate* isolate) {
+  Promise<void> resolved(isolate);
+  resolved.Resolve();
+  return resolved.GetHandle();
+}
+
+v8::Maybe<bool> Promise<void>::Resolve() {
+  gin_helper::Locker locker(isolate());
+  v8::HandleScope handle_scope(isolate());
+  gin_helper::MicrotasksScope microtasks_scope(isolate());
+  v8::Context::Scope context_scope(GetContext());
+
+  return GetInner()->Resolve(GetContext(), v8::Undefined(isolate()));
+}
+
+}  // namespace gin_helper
diff --git a/libcef/renderer/embed/shell/common/gin_helper/promise.h b/libcef/renderer/embed/shell/common/gin_helper/promise.h
new file mode 100644
index 000000000..961ce961a
--- /dev/null
+++ b/libcef/renderer/embed/shell/common/gin_helper/promise.h
@@ -0,0 +1,184 @@
+// Copyright (c) 2018 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#ifndef ELECTRON_SHELL_COMMON_GIN_HELPER_PROMISE_H_
+#define ELECTRON_SHELL_COMMON_GIN_HELPER_PROMISE_H_
+
+#include <string>
+#include <tuple>
+#include <type_traits>
+#include <utility>
+
+#include "base/strings/string_piece.h"
+#include "base/task/post_task.h"
+#include "content/public/browser/browser_task_traits.h"
+#include "content/public/browser/browser_thread.h"
+#include "shell/common/gin_converters/std_converter.h"
+#include "shell/common/gin_helper/locker.h"
+#include "shell/common/gin_helper/microtasks_scope.h"
+
+namespace gin_helper {
+
+// A wrapper around the v8::Promise.
+//
+// This is the non-template base class to share code between templates
+// instances.
+//
+// This is a move-only type that should always be `std::move`d when passed to
+// callbacks, and it should be destroyed on the same thread of creation.
+class PromiseBase {
+ public:
+  explicit PromiseBase(v8::Isolate* isolate);
+  PromiseBase(v8::Isolate* isolate, v8::Local<v8::Promise::Resolver> handle);
+  ~PromiseBase();
+
+  // disable copy
+  PromiseBase(const PromiseBase&) = delete;
+  PromiseBase& operator=(const PromiseBase&) = delete;
+
+  // Support moving.
+  PromiseBase(PromiseBase&&);
+  PromiseBase& operator=(PromiseBase&&);
+
+  // Helper for rejecting promise with error message.
+  //
+  // Note: The parameter type is PromiseBase&& so it can take the instances of
+  // Promise<T> type.
+  static void RejectPromise(PromiseBase&& promise, base::StringPiece errmsg) {
+    if (gin_helper::Locker::IsBrowserProcess() &&
+        !content::BrowserThread::CurrentlyOn(content::BrowserThread::UI)) {
+      base::PostTask(
+          FROM_HERE, {content::BrowserThread::UI},
+          base::BindOnce(
+              // Note that this callback can not take StringPiece,
+              // as StringPiece only references string internally and
+              // will blow when a temporary string is passed.
+              [](PromiseBase&& promise, std::string str) {
+                promise.RejectWithErrorMessage(str);
+              },
+              std::move(promise), std::string(errmsg.data(), errmsg.size())));
+    } else {
+      promise.RejectWithErrorMessage(errmsg);
+    }
+  }
+
+  v8::Maybe<bool> Reject();
+  v8::Maybe<bool> Reject(v8::Local<v8::Value> except);
+  v8::Maybe<bool> RejectWithErrorMessage(base::StringPiece message);
+
+  v8::Local<v8::Context> GetContext() const;
+  v8::Local<v8::Promise> GetHandle() const;
+
+  v8::Isolate* isolate() const { return isolate_; }
+
+ protected:
+  v8::Local<v8::Promise::Resolver> GetInner() const;
+
+ private:
+  v8::Isolate* isolate_;
+  v8::Global<v8::Context> context_;
+  v8::Global<v8::Promise::Resolver> resolver_;
+};
+
+// Template implementation that returns values.
+template <typename RT>
+class Promise : public PromiseBase {
+ public:
+  using PromiseBase::PromiseBase;
+
+  // Helper for resolving the promise with |result|.
+  static void ResolvePromise(Promise<RT> promise, RT result) {
+    if (gin_helper::Locker::IsBrowserProcess() &&
+        !content::BrowserThread::CurrentlyOn(content::BrowserThread::UI)) {
+      base::PostTask(FROM_HERE, {content::BrowserThread::UI},
+                     base::BindOnce([](Promise<RT> promise,
+                                       RT result) { promise.Resolve(result); },
+                                    std::move(promise), std::move(result)));
+    } else {
+      promise.Resolve(result);
+    }
+  }
+
+  // Returns an already-resolved promise.
+  static v8::Local<v8::Promise> ResolvedPromise(v8::Isolate* isolate,
+                                                RT result) {
+    Promise<RT> resolved(isolate);
+    resolved.Resolve(result);
+    return resolved.GetHandle();
+  }
+
+  // Convert to another type.
+  template <typename NT>
+  Promise<NT> As() {
+    return Promise<NT>(isolate(), GetInner());
+  }
+
+  // Promise resolution is a microtask
+  // We use the MicrotasksRunner to trigger the running of pending microtasks
+  v8::Maybe<bool> Resolve(const RT& value) {
+    gin_helper::Locker locker(isolate());
+    v8::HandleScope handle_scope(isolate());
+    gin_helper::MicrotasksScope microtasks_scope(isolate());
+    v8::Context::Scope context_scope(GetContext());
+
+    return GetInner()->Resolve(GetContext(),
+                               gin::ConvertToV8(isolate(), value));
+  }
+
+  template <typename... ResolveType>
+  v8::MaybeLocal<v8::Promise> Then(
+      base::OnceCallback<void(ResolveType...)> cb) {
+    static_assert(sizeof...(ResolveType) <= 1,
+                  "A promise's 'Then' callback should only receive at most one "
+                  "parameter");
+    static_assert(
+        std::is_same<RT, std::tuple_element_t<0, std::tuple<ResolveType...>>>(),
+        "A promises's 'Then' callback must handle the same type as the "
+        "promises resolve type");
+    gin_helper::Locker locker(isolate());
+    v8::HandleScope handle_scope(isolate());
+    v8::Context::Scope context_scope(GetContext());
+
+    v8::Local<v8::Value> value = gin::ConvertToV8(isolate(), std::move(cb));
+    v8::Local<v8::Function> handler = value.As<v8::Function>();
+
+    return GetHandle()->Then(GetContext(), handler);
+  }
+};
+
+// Template implementation that returns nothing.
+template <>
+class Promise<void> : public PromiseBase {
+ public:
+  using PromiseBase::PromiseBase;
+
+  // Helper for resolving the empty promise.
+  static void ResolvePromise(Promise<void> promise);
+
+  // Returns an already-resolved promise.
+  static v8::Local<v8::Promise> ResolvedPromise(v8::Isolate* isolate);
+
+  v8::Maybe<bool> Resolve();
+};
+
+}  // namespace gin_helper
+
+namespace gin {
+
+template <typename T>
+struct Converter<gin_helper::Promise<T>> {
+  static v8::Local<v8::Value> ToV8(v8::Isolate* isolate,
+                                   const gin_helper::Promise<T>& val) {
+    return val.GetHandle();
+  }
+  // TODO(MarshallOfSound): Implement FromV8 to allow promise chaining
+  //                        in native land
+  // static bool FromV8(v8::Isolate* isolate,
+  //                    v8::Local<v8::Value> val,
+  //                    Promise* out);
+};
+
+}  // namespace gin
+
+#endif  // ELECTRON_SHELL_COMMON_GIN_HELPER_PROMISE_H_
diff --git a/libcef/renderer/embed/shell/common/gin_helper/trackable_object.cc b/libcef/renderer/embed/shell/common/gin_helper/trackable_object.cc
new file mode 100644
index 000000000..ae0feafa4
--- /dev/null
+++ b/libcef/renderer/embed/shell/common/gin_helper/trackable_object.cc
@@ -0,0 +1,66 @@
+// Copyright (c) 2015 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#include "shell/common/gin_helper/trackable_object.h"
+
+#include <memory>
+
+#include "base/bind.h"
+#include "base/supports_user_data.h"
+#include "shell/browser/electron_browser_main_parts.h"
+#include "shell/common/gin_helper/locker.h"
+
+namespace gin_helper {
+
+namespace {
+
+const char kTrackedObjectKey[] = "TrackedObjectKey";
+
+class IDUserData : public base::SupportsUserData::Data {
+ public:
+  explicit IDUserData(int32_t id) : id_(id) {}
+
+  operator int32_t() const { return id_; }
+
+ private:
+  int32_t id_;
+};
+
+}  // namespace
+
+TrackableObjectBase::TrackableObjectBase() {
+  // TODO(zcbenz): Make TrackedObject work in renderer process.
+  DCHECK(gin_helper::Locker::IsBrowserProcess())
+      << "This class only works for browser process";
+}
+
+TrackableObjectBase::~TrackableObjectBase() = default;
+
+base::OnceClosure TrackableObjectBase::GetDestroyClosure() {
+  return base::BindOnce(&TrackableObjectBase::Destroy,
+                        weak_factory_.GetWeakPtr());
+}
+
+void TrackableObjectBase::Destroy() {
+  delete this;
+}
+
+void TrackableObjectBase::AttachAsUserData(base::SupportsUserData* wrapped) {
+  wrapped->SetUserData(kTrackedObjectKey,
+                       std::make_unique<IDUserData>(weak_map_id_));
+}
+
+// static
+int32_t TrackableObjectBase::GetIDFromWrappedClass(
+    base::SupportsUserData* wrapped) {
+  if (wrapped) {
+    auto* id =
+        static_cast<IDUserData*>(wrapped->GetUserData(kTrackedObjectKey));
+    if (id)
+      return *id;
+  }
+  return 0;
+}
+
+}  // namespace gin_helper
diff --git a/libcef/renderer/embed/shell/common/gin_helper/trackable_object.h b/libcef/renderer/embed/shell/common/gin_helper/trackable_object.h
new file mode 100644
index 000000000..309e412e8
--- /dev/null
+++ b/libcef/renderer/embed/shell/common/gin_helper/trackable_object.h
@@ -0,0 +1,140 @@
+// Copyright (c) 2015 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#ifndef ELECTRON_SHELL_COMMON_GIN_HELPER_TRACKABLE_OBJECT_H_
+#define ELECTRON_SHELL_COMMON_GIN_HELPER_TRACKABLE_OBJECT_H_
+
+#include <vector>
+
+#include "base/bind.h"
+#include "base/memory/weak_ptr.h"
+#include "shell/common/gin_helper/cleaned_up_at_exit.h"
+#include "shell/common/gin_helper/event_emitter.h"
+#include "shell/common/key_weak_map.h"
+
+namespace base {
+class SupportsUserData;
+}
+
+namespace gin_helper {
+
+// Users should use TrackableObject instead.
+class TrackableObjectBase : public CleanedUpAtExit {
+ public:
+  TrackableObjectBase();
+
+  // disable copy
+  TrackableObjectBase(const TrackableObjectBase&) = delete;
+  TrackableObjectBase& operator=(const TrackableObjectBase&) = delete;
+
+  // The ID in weak map.
+  int32_t weak_map_id() const { return weak_map_id_; }
+
+  // Wrap TrackableObject into a class that SupportsUserData.
+  void AttachAsUserData(base::SupportsUserData* wrapped);
+
+  // Get the weak_map_id from SupportsUserData.
+  static int32_t GetIDFromWrappedClass(base::SupportsUserData* wrapped);
+
+ protected:
+  ~TrackableObjectBase() override;
+
+  // Returns a closure that can destroy the native class.
+  base::OnceClosure GetDestroyClosure();
+
+  int32_t weak_map_id_ = 0;
+
+ private:
+  void Destroy();
+
+  base::WeakPtrFactory<TrackableObjectBase> weak_factory_{this};
+};
+
+// All instances of TrackableObject will be kept in a weak map and can be got
+// from its ID.
+template <typename T>
+class TrackableObject : public TrackableObjectBase, public EventEmitter<T> {
+ public:
+  // Mark the JS object as destroyed.
+  void MarkDestroyed() {
+    v8::HandleScope scope(gin_helper::Wrappable<T>::isolate());
+    v8::Local<v8::Object> wrapper = gin_helper::Wrappable<T>::GetWrapper();
+    if (!wrapper.IsEmpty()) {
+      wrapper->SetAlignedPointerInInternalField(0, nullptr);
+      gin_helper::WrappableBase::wrapper_.ClearWeak();
+    }
+  }
+
+  bool IsDestroyed() {
+    v8::HandleScope scope(gin_helper::Wrappable<T>::isolate());
+    v8::Local<v8::Object> wrapper = gin_helper::Wrappable<T>::GetWrapper();
+    return wrapper->InternalFieldCount() == 0 ||
+           wrapper->GetAlignedPointerFromInternalField(0) == nullptr;
+  }
+
+  // Finds out the TrackableObject from its ID in weak map.
+  static T* FromWeakMapID(v8::Isolate* isolate, int32_t id) {
+    if (!weak_map_)
+      return nullptr;
+
+    v8::HandleScope scope(isolate);
+    v8::MaybeLocal<v8::Object> object = weak_map_->Get(isolate, id);
+    if (object.IsEmpty())
+      return nullptr;
+
+    T* self = nullptr;
+    gin::ConvertFromV8(isolate, object.ToLocalChecked(), &self);
+    return self;
+  }
+
+  // Finds out the TrackableObject from the class it wraps.
+  static T* FromWrappedClass(v8::Isolate* isolate,
+                             base::SupportsUserData* wrapped) {
+    int32_t id = GetIDFromWrappedClass(wrapped);
+    if (!id)
+      return nullptr;
+    return FromWeakMapID(isolate, id);
+  }
+
+  // Returns all objects in this class's weak map.
+  static std::vector<v8::Local<v8::Object>> GetAll(v8::Isolate* isolate) {
+    if (weak_map_)
+      return weak_map_->Values(isolate);
+    else
+      return std::vector<v8::Local<v8::Object>>();
+  }
+
+  // Removes this instance from the weak map.
+  void RemoveFromWeakMap() {
+    if (weak_map_ && weak_map_->Has(weak_map_id()))
+      weak_map_->Remove(weak_map_id());
+  }
+
+ protected:
+  TrackableObject() { weak_map_id_ = ++next_id_; }
+
+  ~TrackableObject() override { RemoveFromWeakMap(); }
+
+  void InitWith(v8::Isolate* isolate, v8::Local<v8::Object> wrapper) override {
+    gin_helper::WrappableBase::InitWith(isolate, wrapper);
+    if (!weak_map_) {
+      weak_map_ = new electron::KeyWeakMap<int32_t>;
+    }
+    weak_map_->Set(isolate, weak_map_id_, wrapper);
+  }
+
+ private:
+  static int32_t next_id_;
+  static electron::KeyWeakMap<int32_t>* weak_map_;  // leaked on purpose
+};
+
+template <typename T>
+int32_t TrackableObject<T>::next_id_ = 0;
+
+template <typename T>
+electron::KeyWeakMap<int32_t>* TrackableObject<T>::weak_map_ = nullptr;
+
+}  // namespace gin_helper
+
+#endif  // ELECTRON_SHELL_COMMON_GIN_HELPER_TRACKABLE_OBJECT_H_
diff --git a/libcef/renderer/embed/shell/common/gin_helper/wrappable.cc b/libcef/renderer/embed/shell/common/gin_helper/wrappable.cc
new file mode 100644
index 000000000..635986934
--- /dev/null
+++ b/libcef/renderer/embed/shell/common/gin_helper/wrappable.cc
@@ -0,0 +1,93 @@
+// Copyright 2013 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE.chromium file.
+
+#include "shell/common/gin_helper/wrappable.h"
+
+#include "base/logging.h"
+#include "base/threading/thread_task_runner_handle.h"
+#include "shell/common/gin_helper/dictionary.h"
+
+namespace gin_helper {
+
+WrappableBase::WrappableBase() = default;
+
+WrappableBase::~WrappableBase() {
+  if (wrapper_.IsEmpty())
+    return;
+
+  v8::HandleScope scope(isolate());
+  GetWrapper()->SetAlignedPointerInInternalField(0, nullptr);
+  wrapper_.ClearWeak();
+  wrapper_.Reset();
+}
+
+v8::Local<v8::Object> WrappableBase::GetWrapper() const {
+  if (!wrapper_.IsEmpty())
+    return v8::Local<v8::Object>::New(isolate_, wrapper_);
+  else
+    return v8::Local<v8::Object>();
+}
+
+v8::MaybeLocal<v8::Object> WrappableBase::GetWrapper(
+    v8::Isolate* isolate) const {
+  if (!wrapper_.IsEmpty())
+    return v8::MaybeLocal<v8::Object>(
+        v8::Local<v8::Object>::New(isolate, wrapper_));
+  else
+    return v8::MaybeLocal<v8::Object>();
+}
+
+void WrappableBase::InitWithArgs(gin::Arguments* args) {
+  v8::Local<v8::Object> holder;
+  args->GetHolder(&holder);
+  InitWith(args->isolate(), holder);
+}
+
+void WrappableBase::InitWith(v8::Isolate* isolate,
+                             v8::Local<v8::Object> wrapper) {
+  CHECK(wrapper_.IsEmpty());
+  isolate_ = isolate;
+  wrapper->SetAlignedPointerInInternalField(0, this);
+  wrapper_.Reset(isolate, wrapper);
+  wrapper_.SetWeak(this, FirstWeakCallback,
+                   v8::WeakCallbackType::kInternalFields);
+
+  // Call object._init if we have one.
+  v8::Local<v8::Function> init;
+  if (Dictionary(isolate, wrapper).Get("_init", &init))
+    init->Call(isolate->GetCurrentContext(), wrapper, 0, nullptr).IsEmpty();
+
+  AfterInit(isolate);
+}
+
+// static
+void WrappableBase::FirstWeakCallback(
+    const v8::WeakCallbackInfo<WrappableBase>& data) {
+  auto* wrappable = static_cast<WrappableBase*>(data.GetInternalField(0));
+  if (wrappable) {
+    wrappable->wrapper_.Reset();
+    data.SetSecondPassCallback(SecondWeakCallback);
+  }
+}
+
+// static
+void WrappableBase::SecondWeakCallback(
+    const v8::WeakCallbackInfo<WrappableBase>& data) {
+  delete static_cast<WrappableBase*>(data.GetInternalField(0));
+}
+
+namespace internal {
+
+void* FromV8Impl(v8::Isolate* isolate, v8::Local<v8::Value> val) {
+  if (!val->IsObject())
+    return nullptr;
+  v8::Local<v8::Object> obj = val.As<v8::Object>();
+  if (obj->InternalFieldCount() != 1)
+    return nullptr;
+  return obj->GetAlignedPointerFromInternalField(0);
+}
+
+}  // namespace internal
+
+}  // namespace gin_helper
diff --git a/libcef/renderer/embed/shell/common/gin_helper/wrappable.h b/libcef/renderer/embed/shell/common/gin_helper/wrappable.h
new file mode 100644
index 000000000..4e1ece6c6
--- /dev/null
+++ b/libcef/renderer/embed/shell/common/gin_helper/wrappable.h
@@ -0,0 +1,101 @@
+// Copyright 2013 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE.chromium file.
+
+#ifndef ELECTRON_SHELL_COMMON_GIN_HELPER_WRAPPABLE_H_
+#define ELECTRON_SHELL_COMMON_GIN_HELPER_WRAPPABLE_H_
+
+#include "base/bind.h"
+#include "gin/per_isolate_data.h"
+#include "shell/common/gin_helper/constructor.h"
+
+namespace gin_helper {
+
+namespace internal {
+
+void* FromV8Impl(v8::Isolate* isolate, v8::Local<v8::Value> val);
+
+}  // namespace internal
+
+template <typename T>
+class Wrappable : public WrappableBase {
+ public:
+  Wrappable() = default;
+
+  template <typename Sig>
+  static void SetConstructor(v8::Isolate* isolate,
+                             const base::RepeatingCallback<Sig>& constructor) {
+    v8::Local<v8::FunctionTemplate> templ = gin_helper::CreateFunctionTemplate(
+        isolate, base::BindRepeating(&internal::InvokeNew<Sig>, constructor));
+    templ->InstanceTemplate()->SetInternalFieldCount(1);
+    T::BuildPrototype(isolate, templ);
+    gin::PerIsolateData::From(isolate)->SetFunctionTemplate(&kWrapperInfo,
+                                                            templ);
+  }
+
+  static v8::Local<v8::FunctionTemplate> GetConstructor(v8::Isolate* isolate) {
+    // Fill the object template.
+    auto* data = gin::PerIsolateData::From(isolate);
+    auto templ = data->GetFunctionTemplate(&kWrapperInfo);
+    if (templ.IsEmpty()) {
+      templ = v8::FunctionTemplate::New(isolate);
+      templ->InstanceTemplate()->SetInternalFieldCount(1);
+      T::BuildPrototype(isolate, templ);
+      data->SetFunctionTemplate(&kWrapperInfo, templ);
+    }
+    return templ;
+  }
+
+ protected:
+  // Init the class with T::BuildPrototype.
+  void Init(v8::Isolate* isolate) {
+    v8::Local<v8::FunctionTemplate> templ = GetConstructor(isolate);
+
+    // |wrapper| may be empty in some extreme cases, e.g., when
+    // Object.prototype.constructor is overwritten.
+    v8::Local<v8::Object> wrapper;
+    if (!templ->InstanceTemplate()
+             ->NewInstance(isolate->GetCurrentContext())
+             .ToLocal(&wrapper)) {
+      // The current wrappable object will be no longer managed by V8. Delete
+      // this now.
+      delete this;
+      return;
+    }
+    InitWith(isolate, wrapper);
+  }
+
+ private:
+  static gin::WrapperInfo kWrapperInfo;
+};
+
+// static
+template <typename T>
+gin::WrapperInfo Wrappable<T>::kWrapperInfo = {gin::kEmbedderNativeGin};
+
+}  // namespace gin_helper
+
+namespace gin {
+
+template <typename T>
+struct Converter<
+    T*,
+    typename std::enable_if<
+        std::is_convertible<T*, gin_helper::WrappableBase*>::value>::type> {
+  static v8::Local<v8::Value> ToV8(v8::Isolate* isolate, T* val) {
+    if (val)
+      return val->GetWrapper();
+    else
+      return v8::Null(isolate);
+  }
+
+  static bool FromV8(v8::Isolate* isolate, v8::Local<v8::Value> val, T** out) {
+    *out = static_cast<T*>(static_cast<gin_helper::WrappableBase*>(
+        gin_helper::internal::FromV8Impl(isolate, val)));
+    return *out != nullptr;
+  }
+};
+
+}  // namespace gin
+
+#endif  // ELECTRON_SHELL_COMMON_GIN_HELPER_WRAPPABLE_H_
diff --git a/libcef/renderer/embed/shell/common/gin_helper/wrappable_base.h b/libcef/renderer/embed/shell/common/gin_helper/wrappable_base.h
new file mode 100644
index 000000000..87ba126d1
--- /dev/null
+++ b/libcef/renderer/embed/shell/common/gin_helper/wrappable_base.h
@@ -0,0 +1,70 @@
+// Copyright 2013 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE.chromium file.
+
+#ifndef ELECTRON_SHELL_COMMON_GIN_HELPER_WRAPPABLE_BASE_H_
+#define ELECTRON_SHELL_COMMON_GIN_HELPER_WRAPPABLE_BASE_H_
+
+#include "v8/include/v8.h"
+
+namespace gin {
+class Arguments;
+}
+
+namespace gin_helper {
+
+// Wrappable is a base class for C++ objects that have corresponding v8 wrapper
+// objects. To retain a Wrappable object on the stack, use a gin::Handle.
+//
+// USAGE:
+// // my_class.h
+// class MyClass : Wrappable<MyClass> {
+//  public:
+//   ...
+// };
+//
+// Subclasses should also typically have private constructors and expose a
+// static Create function that returns a gin::Handle. Forcing creators through
+// this static Create function will enforce that clients actually create a
+// wrapper for the object. If clients fail to create a wrapper for a wrappable
+// object, the object will leak because we use the weak callback from the
+// wrapper as the signal to delete the wrapped object.
+class WrappableBase {
+ public:
+  WrappableBase();
+  WrappableBase(const WrappableBase&) = delete;
+  WrappableBase& operator=(const WrappableBase&) = delete;
+  virtual ~WrappableBase();
+
+  // Retrieve the v8 wrapper object corresponding to this object.
+  v8::Local<v8::Object> GetWrapper() const;
+  v8::MaybeLocal<v8::Object> GetWrapper(v8::Isolate* isolate) const;
+
+  // Returns the Isolate this object is created in.
+  v8::Isolate* isolate() const { return isolate_; }
+
+ protected:
+  // Called after the "_init" method gets called in JavaScript.
+  virtual void AfterInit(v8::Isolate* isolate) {}
+
+  // Bind the C++ class to the JS wrapper.
+  // This method should only be called by classes using Constructor.
+  virtual void InitWith(v8::Isolate* isolate, v8::Local<v8::Object> wrapper);
+
+  // Helper to init with arguments.
+  void InitWithArgs(gin::Arguments* args);
+
+  v8::Global<v8::Object> wrapper_;  // Weak
+
+ private:
+  static void FirstWeakCallback(
+      const v8::WeakCallbackInfo<WrappableBase>& data);
+  static void SecondWeakCallback(
+      const v8::WeakCallbackInfo<WrappableBase>& data);
+
+  v8::Isolate* isolate_ = nullptr;
+};
+
+}  // namespace gin_helper
+
+#endif  // ELECTRON_SHELL_COMMON_GIN_HELPER_WRAPPABLE_BASE_H_
diff --git a/libcef/renderer/render_frame_observer.cc b/libcef/renderer/render_frame_observer.cc
index bd172c8e9..1f954acdf 100644
--- a/libcef/renderer/render_frame_observer.cc
+++ b/libcef/renderer/render_frame_observer.cc
@@ -14,7 +14,10 @@
 #pragma warning(default : 4996)
 #endif
 #endif
-
+#include "embed/node_bindings.h"
+#include "embed/node_includes.h"
+#include "embed/shell/common/gin_helper/event_emitter_caller.h"
+#include "embed/shell/common/gin_helper/microtasks_scope.h"
 #include "libcef/renderer/render_frame_observer.h"
 
 #include "libcef/common/app_manager.h"
@@ -115,7 +118,16 @@ void CefRenderFrameObserver::DraggableRegionsChanged() {
     frame_->OnDraggableRegionsChanged();
   }
 }
-
+static std::shared_ptr<electron::NodeBindings> node_bindings_;
+// The node::Environment::GetCurrent API does not return nullptr when it
+// is called for a context without node::Environment, so we have to keep
+// a book of the environments created.
+static std::set<node::Environment*> environments_;
+
+// Getting main script context from web frame would lazily initializes
+// its script context. Doing so in a web page without scripts would trigger
+// assertion, so we have to keep a book of injected web frames.
+static std::set<content::RenderFrame*> injected_frames_;
 void CefRenderFrameObserver::DidCreateScriptContext(
     v8::Handle<v8::Context> context,
     int world_id) {
@@ -134,7 +146,51 @@ void CefRenderFrameObserver::DidCreateScriptContext(
     handler = application->GetRenderProcessHandler();
 
   CefRefPtr<CefFrameImpl> framePtr = browserPtr->GetWebFrameImpl(frame);
-
+  do {
+    // load node.js
+    // only load node.js in render main frame, neither in sub-frames nor in
+    // devtools.
+    // TODO: create node.js in devtools render process will cause something
+    // like:
+    //  `Uncaught Error: Cannot find module '../../lib/codemirror`
+    bool is_devtools = frame->GetDocument().Url().ProtocolIs("devtools");
+    if (!framePtr->IsMain() || is_devtools) {
+      break;
+    }
+    if (node_bindings_ == nullptr) {
+      node_bindings_ = std::shared_ptr<electron::NodeBindings>(
+          electron::NodeBindings::Create(
+              electron::NodeBindings::BrowserEnvironment::kRenderer));
+      node_bindings_->Initialize();
+      node_bindings_->PrepareMessageLoop();
+    }
+    injected_frames_.insert(render_frame());
+    bool initialized = node::InitializeContext(context);
+    CHECK(initialized);
+
+    node::Environment* env =
+        node_bindings_->CreateEnvironment(context, nullptr);
+
+    // If we have disabled the site instance overrides we should prevent loading
+    // any non-context aware native module.
+    env->options()->force_context_aware = true;
+
+    // We do not want to crash the renderer process on unhandled rejections.
+    env->options()->unhandled_rejections = "warn";
+
+    environments_.insert(env);
+    //
+    //// Load everything.
+    node_bindings_->LoadEnvironment(env);
+    //
+    if (node_bindings_->uv_env() == nullptr) {
+      //  Make uv loop being wrapped by window context.
+      node_bindings_->set_uv_env(env);
+
+      // Give the node loop a run to make sure everything is ready.
+      node_bindings_->RunMessageLoop();
+    }
+  } while (0);
   if (handler) {
     v8::Isolate* isolate = blink::MainThreadIsolate();
     v8::HandleScope handle_scope(isolate);
@@ -181,6 +237,45 @@ void CefRenderFrameObserver::WillReleaseScriptContext(
       }
     }
   }
+  do {
+    if (node_bindings_ == nullptr) {
+      break;
+    }
+
+    if (injected_frames_.erase(render_frame()) == 0)
+      break;
+
+    node::Environment* env = node::Environment::GetCurrent(context);
+    if (environments_.erase(env) == 0)
+      break;
+
+    // related issues/pull/pathes:
+    // 1. <https://github.com/electron/electron/issues/3699>
+    // 2. <https://github.com/electron/electron/pull/15759>
+    // 3. <https://github.com/electron/electron/pull/4329>
+    // 4.
+    // <https://github.com/electron/electron/blob/main/patches/chromium/blink_local_frame.patch>
+    // It seems that the frontend need the exit event to do some cleanup, and
+    // it is not safe to emit this event in document.onload. Electron emit this
+    // event in WillReleaseScriptContext, therefore, `blink_local_frame.patch`
+    // needed to be applied to allow script execution in this scope.
+    //
+    gin_helper::EmitEvent(env->isolate(), env->process_object(), "exit");
+
+    // The main frame may be replaced.
+    if (env == node_bindings_->uv_env())
+      node_bindings_->set_uv_env(nullptr);
+
+    // Destroy the node environment.  We only do this if node support has been
+    // enabled for sub-frames to avoid a change-of-behavior / introduce crashes
+    // for existing users.
+    // We also do this if we have disable electron site instance overrides to
+    // avoid memory leaks
+    gin_helper::MicrotasksScope microtasks_scope(env->isolate());
+    node::FreeEnvironment(env);
+    if (env == node_bindings_->uv_env())
+      node::FreeIsolateData(node_bindings_->isolate_data());
+  } while (0);
 
   CefV8ReleaseContext(context);
 }
-- 
2.36.1.windows.1

